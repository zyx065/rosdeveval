compilation.log: |
  Starting >>> moveit_core
  --- stderr: moveit_core
  /root/repos/moveit_ws/src/moveit2/moveit_core/robot_state/src/robot_state.cpp: In member function ‘void moveit::core::RobotState::computeAABB(std::vector<double, std::allocator<double> >&) const’:
  /root/repos/moveit_ws/src/moveit2/moveit_core/robot_state/src/robot_state.cpp:2089:20: error: ‘class moveit::core::AABB’ has no member named ‘checkLinkTransforms’
   2089 |   if (overall_aabb.checkLinkTransforms())
        |                    ^~~~~~~~~~~~~~~~~~~
  gmake[2]: *** [robot_state/CMakeFiles/moveit_robot_state.dir/build.make:107: robot_state/CMakeFiles/moveit_robot_state.dir/src/robot_state.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:1656: robot_state/CMakeFiles/moveit_robot_state.dir/all] Error 2
  gmake: *** [Makefile:149: all] Error 2
  ---
  Failed   <<< moveit_core [9.13s, exited with code 2]

  Summary: 0 packages finished [9.60s]
    1 package failed: moveit_core
    1 package had stderr output: moveit_core
generate_code.cpp: |-
  void RobotState::computeAABB(std::vector<double>& aabb) const
  {
    aabb.resize(6, 0.0);
    if (!robot_model_)
      return;

    moveit::core::AABB overall_aabb;
    const std::vector<const LinkModel*>& links_with_geometry = robot_model_->getLinkModelsWithCollisionGeometry();

    // Process links with collision geometry
    for (const LinkModel* link : links_with_geometry)
    {
      const Eigen::Isometry3d& transform = getGlobalLinkTransform(link);
      const Eigen::Vector3d& extents = link->getShapeExtentsAtOrigin();
      overall_aabb.extendWithTransformedBox(transform, extents);
    }

    // Process attached bodies
    for (const auto& attached_body_pair : attached_body_map_)
    {
      const AttachedBody* attached_body = attached_body_pair.second.get();
      const EigenSTL::vector_Isometry3d& transforms = attached_body->getGlobalCollisionBodyTransforms();
      const std::vector<shapes::ShapeConstPtr>& shapes = attached_body->getShapes();

      for (size_t i = 0; i < shapes.size(); ++i)
      {
        Eigen::Vector3d extents = shapes::computeShapeExtents(shapes[i].get());
        overall_aabb.extendWithTransformedBox(transforms[i], extents);
      }
    }

    if (overall_aabb.checkLinkTransforms())
    {
      aabb[0] = overall_aabb.min()[0];
      aabb[1] = overall_aabb.max()[0];
      aabb[2] = overall_aabb.min()[1];
      aabb[3] = overall_aabb.max()[1];
      aabb[4] = overall_aabb.min()[2];
      aabb[5] = overall_aabb.max()[2];
    }
  }
ground_truth.cpp: |-
  void RobotState::computeAABB(std::vector<double>& aabb) const
  {
    assert(checkLinkTransforms());

    core::AABB bounding_box;
    std::vector<const LinkModel*> links = robot_model_->getLinkModelsWithCollisionGeometry();
    for (const LinkModel* link : links)
    {
      Eigen::Isometry3d transform = getGlobalLinkTransform(link);  // intentional copy, we will translate
      const Eigen::Vector3d& extents = link->getShapeExtentsAtOrigin();
      transform.translate(link->getCenteredBoundingBoxOffset());
      bounding_box.extendWithTransformedBox(transform, extents);
    }
    for (const auto& it : attached_body_map_)
    {
      const EigenSTL::vector_Isometry3d& transforms = it.second->getGlobalCollisionBodyTransforms();
      const std::vector<shapes::ShapeConstPtr>& shapes = it.second->getShapes();
      for (std::size_t i = 0; i < transforms.size(); ++i)
      {
        Eigen::Vector3d extents = shapes::computeShapeExtents(shapes[i].get());
        bounding_box.extendWithTransformedBox(transforms[i], extents);
      }
    }

    aabb.clear();
    aabb.resize(6, 0.0);
    if (!bounding_box.isEmpty())
    {
      // The following is a shorthand for something like:
      // aabb[0, 2, 4] = bounding_box.min(); aabb[1, 3, 5] = bounding_box.max();
      Eigen::Map<Eigen::VectorXd, Eigen::Unaligned, Eigen::InnerStride<2> >(aabb.data(), 3) = bounding_box.min();
      Eigen::Map<Eigen::VectorXd, Eigen::Unaligned, Eigen::InnerStride<2> >(aabb.data() + 1, 3) = bounding_box.max();
    }
  }
architecture-codes:
  - ROS Message Issue - Incorrect Message Member Access Issue

functionality-codes:
  - Domain Library Issue - Domain Specific Library Utilization Error
  - Incomplete Code Issue - Missing One Step Issue
  - Operation/Calculation Issue - Algorithmic State and Initialization Issue

root-cause-codes:
  - Deficiencies in Domain Knowledge - Lack of Knowledge of Domain-Specific Libraries
  - Inadequate Comprehension of Functional Logic - Inadequate Understanding of Task Logic
  - Weakness in System-Level Integration - Lack of familiarity with the existing codebase