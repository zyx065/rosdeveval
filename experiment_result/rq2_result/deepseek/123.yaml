compilation.log: |
  Starting >>> moveit_servo
  --- stderr: moveit_servo
  /root/repos/moveit_ws/src/moveit2/moveit_ros/moveit_servo/src/pose_tracking.cpp: In member function ‘void moveit_servo::PoseTracking::targetPoseCallback(const ConstSharedPtr&)’:
  /root/repos/moveit_ws/src/moveit2/moveit_ros/moveit_servo/src/pose_tracking.cpp:268:37: error: no match for ‘operator=’ (operand types are ‘geometry_msgs::msg::PoseStamped’ {aka ‘geometry_msgs::msg::PoseStamped_<std::allocator<void> >’} and ‘geometry_msgs::msg::PoseStamped_<std::allocator<void> >::_pose_type’ {aka ‘geometry_msgs::msg::Pose_<std::allocator<void> >’})
    268 |     target_pose_ = transformed_pose.pose;
        |                                     ^~~~
  In file included from /root/repos/moveit_ws/install/moveit_msgs/include/moveit_msgs/moveit_msgs/msg/detail/visibility_constraint__struct.hpp:21,
                   from /root/repos/moveit_ws/install/moveit_msgs/include/moveit_msgs/moveit_msgs/msg/detail/constraints__struct.hpp:26,
                   from /root/repos/moveit_ws/install/moveit_msgs/include/moveit_msgs/moveit_msgs/msg/constraints.hpp:7,
                   from /root/repos/moveit_ws/install/moveit_core/include/moveit/kinematic_constraints/kinematic_constraint.h:46,
                   from /root/repos/moveit_ws/install/moveit_core/include/moveit/planning_scene/planning_scene.h:45,
                   from /root/repos/moveit_ws/install/moveit_ros_planning/include/moveit/planning_scene_monitor/planning_scene_monitor.h:43,
                   from /root/repos/moveit_ws/src/moveit2/moveit_ros/moveit_servo/include/moveit_servo/servo_parameters.h:46,
                   from /root/repos/moveit_ws/src/moveit2/moveit_ros/moveit_servo/include/moveit_servo/pose_tracking.h:44,
                   from /root/repos/moveit_ws/src/moveit2/moveit_ros/moveit_servo/src/pose_tracking.cpp:35:
  /opt/ros/humble/include/geometry_msgs/geometry_msgs/msg/detail/pose_stamped__struct.hpp:38:8: note: candidate: ‘geometry_msgs::msg::PoseStamped_<std::allocator<void> >& geometry_msgs::msg::PoseStamped_<std::allocator<void> >::operator=(const geometry_msgs::msg::PoseStamped_<std::allocator<void> >&)’
     38 | struct PoseStamped_
        |        ^~~~~~~~~~~~
  /opt/ros/humble/include/geometry_msgs/geometry_msgs/msg/detail/pose_stamped__struct.hpp:38:8: note:   no known conversion for argument 1 from ‘geometry_msgs::msg::PoseStamped_<std::allocator<void> >::_pose_type’ {aka ‘geometry_msgs::msg::Pose_<std::allocator<void> >’} to ‘const geometry_msgs::msg::PoseStamped_<std::allocator<void> >&’
  /opt/ros/humble/include/geometry_msgs/geometry_msgs/msg/detail/pose_stamped__struct.hpp:38:8: note: candidate: ‘geometry_msgs::msg::PoseStamped_<std::allocator<void> >& geometry_msgs::msg::PoseStamped_<std::allocator<void> >::operator=(geometry_msgs::msg::PoseStamped_<std::allocator<void> >&&)’
  /opt/ros/humble/include/geometry_msgs/geometry_msgs/msg/detail/pose_stamped__struct.hpp:38:8: note:   no known conversion for argument 1 from ‘geometry_msgs::msg::PoseStamped_<std::allocator<void> >::_pose_type’ {aka ‘geometry_msgs::msg::Pose_<std::allocator<void> >’} to ‘geometry_msgs::msg::PoseStamped_<std::allocator<void> >&&’
  gmake[2]: *** [CMakeFiles/pose_tracking.dir/build.make:76: CMakeFiles/pose_tracking.dir/src/pose_tracking.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:230: CMakeFiles/pose_tracking.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< moveit_servo [10.6s, exited with code 2]

  Summary: 0 packages finished [11.2s]
    1 package failed: moveit_servo
    1 package had stderr output: moveit_servo
generate_code.cpp: "void PoseTracking::targetPoseCallback(const geometry_msgs::msg::PoseStamped::ConstSharedPtr&\
  \ msg)\n{\n  // Lock mutex to protect shared data\n  std::lock_guard<std::mutex>\
  \ lock(target_pose_mtx_);\n  \n  try\n  {\n    // Transform the target pose to the\
  \ planning frame\n    geometry_msgs::msg::PoseStamped transformed_pose;\n    transformed_pose\
  \ = transform_buffer_.transform(*msg, planning_frame_, tf2::durationFromSec(0.1));\n\
  \    \n    // Update the target pose with the transformed pose\n    target_pose_\
  \ = transformed_pose.pose;\n    \n    RCLCPP_DEBUG(LOGGER, \"Successfully transformed\
  \ target pose to planning frame: %s\", planning_frame_.c_str());\n  }\n  catch (tf2::TransformException&\
  \ ex)\n  {\n    RCLCPP_WARN(LOGGER, \"Failed to transform target pose to planning\
  \ frame: %s. Error: %s\", \n                planning_frame_.c_str(), ex.what());\n\
  \  }\n}"
ground_truth.cpp: |-
  void PoseTracking::targetPoseCallback(const geometry_msgs::msg::PoseStamped::ConstSharedPtr& msg)
  {
    std::lock_guard<std::mutex> lock(target_pose_mtx_);
    target_pose_ = *msg;
    // If the target pose is not defined in planning frame, transform the target pose.
    if (target_pose_.header.frame_id != planning_frame_)
    {
      try
      {
        geometry_msgs::msg::TransformStamped target_to_planning_frame = transform_buffer_.lookupTransform(
            planning_frame_, target_pose_.header.frame_id, rclcpp::Time(0), rclcpp::Duration(100ms));
        tf2::doTransform(target_pose_, target_pose_, target_to_planning_frame);

        // Prevent doTransform from copying a stamp of 0, which will cause the haveRecentTargetPose check to fail servo motions
        target_pose_.header.stamp = node_->now();
      }
      catch (const tf2::TransformException& ex)
      {
        RCLCPP_WARN_STREAM(LOGGER, ex.what());
        return;
      }
    }
  }
architecture-codes:
  - ROS Message Issue - Message Operation Issue
  - ROS Message Issue - Message Initialization Issue
  - ROS Logger Issue - Log Level and Frequency Issue
  - ROS Timer Issue - Clock Source Usage Issue

functionality-codes:
  - Condition Issue - Conditional Check Missing Issue
  - Domain Library Issue - Domain Specific Library Utilization Error
  - Incomplete Code Issue - Missing Multiple Steps Issue

root-cause-codes:
  - Inadequate Comprehension of Functional Logic - Inadequate Understanding of Task Logic
  - Deficiencies in Domain Knowledge - Insufficient understanding of ROS Programming
  - Deficiencies in Domain Knowledge - Lack of ROS development best practices
  - Weakness in System-Level Integration - Lack of familiarity with the existing codebase