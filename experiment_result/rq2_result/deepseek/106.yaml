compilation.log: |
  Starting >>> autoware_ekf_localizer
  --- stderr: autoware_ekf_localizer
  /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_ekf_localizer/src/state_transition.cpp: In function ‘autoware::ekf_localizer::Matrix6d autoware::ekf_localizer::create_state_transition_matrix(const Vector6d&, double)’:
  /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_ekf_localizer/src/state_transition.cpp:77:18: error: unused variable ‘wz’ [-Werror=unused-variable]
     77 |     const double wz = X_curr(5);
        |                  ^~
  cc1plus: all warnings being treated as errors
  gmake[2]: *** [CMakeFiles/autoware_ekf_localizer.dir/build.make:146: CMakeFiles/autoware_ekf_localizer.dir/src/state_transition.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:175: CMakeFiles/autoware_ekf_localizer.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_ekf_localizer [1.32s, exited with code 2]

  Summary: 0 packages finished [2.72s]
    1 package failed: autoware_ekf_localizer
    1 package had stderr output: autoware_ekf_localizer
generate_code.cpp: "Matrix6d create_state_transition_matrix(const Vector6d & X_curr,\
  \ const double dt) {\n    Matrix6d F = Matrix6d::Identity();\n    \n    const double\
  \ yaw = X_curr(2);\n    const double vx = X_curr(4);\n    const double wz = X_curr(5);\n\
  \    \n    // Position x and y depend on yaw and velocity\n    F(0, 2) = -vx * sin(yaw)\
  \ * dt;\n    F(0, 4) = cos(yaw) * dt;\n    F(1, 2) = vx * cos(yaw) * dt;\n    F(1,\
  \ 4) = sin(yaw) * dt;\n    \n    // Yaw depends on angular velocity\n    F(2, 5)\
  \ = dt;\n    \n    return F;\n}"
ground_truth.cpp: |-
  Matrix6d create_state_transition_matrix(const Vector6d & X_curr, const double dt)
  {
    const double yaw = X_curr(IDX::YAW);
    const double yaw_bias = X_curr(IDX::YAWB);
    const double vx = X_curr(IDX::VX);

    Matrix6d a = Matrix6d::Identity();
    a(IDX::X, IDX::YAW) = -vx * sin(yaw + yaw_bias) * dt;
    a(IDX::X, IDX::YAWB) = -vx * sin(yaw + yaw_bias) * dt;
    a(IDX::X, IDX::VX) = cos(yaw + yaw_bias) * dt;
    a(IDX::Y, IDX::YAW) = vx * cos(yaw + yaw_bias) * dt;
    a(IDX::Y, IDX::YAWB) = vx * cos(yaw + yaw_bias) * dt;
    a(IDX::Y, IDX::VX) = sin(yaw + yaw_bias) * dt;
    a(IDX::YAW, IDX::WZ) = dt;
    return a;
  }
architecture-codes:
  - ROS Parameter Issue - Use Non-existent Parameter Issue 
functionality-codes:
  - Incomplete Code Issue - Missing Multiple Steps Issue 
  - Operation/Calculation Issue - Violation of Physical & Kinematic Constraints Issue 
root-cause-codes:
  - Inadequate Comprehension of Functional Logic - Inadequate Understanding of Task Logic 
  - Deficiencies in Domain Knowledge - Insufficient understanding of ROS Programming
  - Weakness in System-Level Integration - Lack of familiarity with the existing codebase 