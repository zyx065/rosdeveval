compilation.log: "Starting >>> autoware_trajectory_follower_node\n--- stderr: autoware_trajectory_follower_node\n\
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:\
  \ In constructor ‘autoware::motion::control::trajectory_follower_node::Controller::Controller(const\
  \ rclcpp::NodeOptions&)’:\n/workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:56:21:\
  \ error: ‘class std::unique_ptr<autoware::universe_utils::LoggerLevelConfigure>’\
  \ has no member named ‘initialize’\n   56 |   logger_configure_.initialize(this);\n\
  \      |                     ^~~~~~~~~~\n/workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:81:39:\
  \ error: ‘autoware_auto_control_msgs’ was not declared in this scope; did you mean\
  \ ‘autoware_control_msgs’?\n   81 |   control_cmd_pub_ = create_publisher<autoware_auto_control_msgs::msg::AckermannControlCommand>(\n\
  \      |                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~\n    \
  \  |                                       autoware_control_msgs\n/workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:81:22:\
  \ error: parse error in template argument list\n   81 |   control_cmd_pub_ = create_publisher<autoware_auto_control_msgs::msg::AckermannControlCommand>(\n\
  \      |                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:81:96:\
  \ error: no matching function for call to ‘autoware::motion::control::trajectory_follower_node::Controller::create_publisher<<expression\
  \ error> >(const char [19], rclcpp::QoS)’\n   81 |   control_cmd_pub_ = create_publisher<autoware_auto_control_msgs::msg::AckermannControlCommand>(\n\
  \      |                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
  \   82 |     \"output/control_cmd\", rclcpp::QoS(1));\n      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
  \                                                       \nIn file included from\
  \ /opt/ros/humble/include/rclcpp/rclcpp/node.hpp:1321,\n                 from /opt/ros/humble/include/rclcpp/rclcpp/executors/single_threaded_executor.hpp:28,\n\
  \                 from /opt/ros/humble/include/rclcpp/rclcpp/executors.hpp:22,\n\
  \                 from /opt/ros/humble/include/rclcpp/rclcpp/rclcpp.hpp:155,\n \
  \                from /workspace/repos/autoware/install/autoware_trajectory_follower_base/include/autoware/trajectory_follower_base/lateral_controller_base.hpp:21,\n\
  \                 from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/include/autoware/trajectory_follower_node/controller_node.hpp:19,\n\
  \                 from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:15:\n\
  /opt/ros/humble/include/rclcpp/rclcpp/node_impl.hpp:73:1: note: candidate: ‘template<class\
  \ MessageT, class AllocatorT, class PublisherT> std::shared_ptr<PublisherT> rclcpp::Node::create_publisher(const\
  \ string&, const rclcpp::QoS&, const rclcpp::PublisherOptionsWithAllocator<AllocatorT>&)’\n\
  \   73 | Node::create_publisher(\n      | ^~~~\n/opt/ros/humble/include/rclcpp/rclcpp/node_impl.hpp:73:1:\
  \ note:   template argument deduction/substitution failed:\n/workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:81:96:\
  \ error: template argument 1 is invalid\n   81 |   control_cmd_pub_ = create_publisher<autoware_auto_control_msgs::msg::AckermannControlCommand>(\n\
  \      |                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
  \   82 |     \"output/control_cmd\", rclcpp::QoS(1));\n      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
  \                                                       \n/workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:83:3:\
  \ error: ‘debug_pub_’ was not declared in this scope\n   83 |   debug_pub_ = create_publisher<autoware_auto_control_msgs::msg::Float32MultiArrayDiagnostic>(\n\
  \      |   ^~~~~~~~~~\n/workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:83:16:\
  \ error: parse error in template argument list\n   83 |   debug_pub_ = create_publisher<autoware_auto_control_msgs::msg::Float32MultiArrayDiagnostic>(\n\
  \      |                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:83:94:\
  \ error: no matching function for call to ‘autoware::motion::control::trajectory_follower_node::Controller::create_publisher<autoware_auto_control_msgs>(const\
  \ char [13], rclcpp::QoS)’\n   83 |   debug_pub_ = create_publisher<autoware_auto_control_msgs::msg::Float32MultiArrayDiagnostic>(\n\
  \      |                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
  \   84 |     \"output/debug\", rclcpp::QoS(1));\n      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
  \                                                           \nIn file included from\
  \ /opt/ros/humble/include/rclcpp/rclcpp/node.hpp:1321,\n                 from /opt/ros/humble/include/rclcpp/rclcpp/executors/single_threaded_executor.hpp:28,\n\
  \                 from /opt/ros/humble/include/rclcpp/rclcpp/executors.hpp:22,\n\
  \                 from /opt/ros/humble/include/rclcpp/rclcpp/rclcpp.hpp:155,\n \
  \                from /workspace/repos/autoware/install/autoware_trajectory_follower_base/include/autoware/trajectory_follower_base/lateral_controller_base.hpp:21,\n\
  \                 from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/include/autoware/trajectory_follower_node/controller_node.hpp:19,\n\
  \                 from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:15:\n\
  /opt/ros/humble/include/rclcpp/rclcpp/node_impl.hpp:73:1: note: candidate: ‘template<class\
  \ MessageT, class AllocatorT, class PublisherT> std::shared_ptr<PublisherT> rclcpp::Node::create_publisher(const\
  \ string&, const rclcpp::QoS&, const rclcpp::PublisherOptionsWithAllocator<AllocatorT>&)’\n\
  \   73 | Node::create_publisher(\n      | ^~~~\n/opt/ros/humble/include/rclcpp/rclcpp/node_impl.hpp:73:1:\
  \ note:   template argument deduction/substitution failed:\n/workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:87:29:\
  \ error: ‘class std::unique_ptr<autoware::universe_utils::PublishedTimePublisher>’\
  \ has no member named ‘initialize’\n   87 |   published_time_publisher_.initialize(this);\n\
  \      |                             ^~~~~~~~~~\n/workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:92:3:\
  \ error: ‘control_timer_’ was not declared in this scope\n   92 |   control_timer_\
  \ = rclcpp::create_timer(\n      |   ^~~~~~~~~~~~~~\n/workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:93:58:\
  \ error: ‘onTimer’ is not a member of ‘autoware::motion::control::trajectory_follower_node::Controller’\n\
  \   93 |     this, get_clock(), period_ns, std::bind(&Controller::onTimer, this));\n\
  \      |                                                          ^~~~~~~\n/workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:61:14:\
  \ error: unused variable ‘longitudinal_controller_mode’ [-Werror=unused-variable]\n\
  \   61 |   const auto longitudinal_controller_mode = getLongitudinalControllerMode(\n\
  \      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/include/c++/11/memory:76,\n\
  \                 from /workspace/repos/autoware/install/autoware_control_msgs/include/autoware_control_msgs/autoware_control_msgs/msg/detail/lateral__struct.hpp:10,\n\
  \                 from /workspace/repos/autoware/install/autoware_control_msgs/include/autoware_control_msgs/autoware_control_msgs/msg/lateral.hpp:7,\n\
  \                 from /workspace/repos/autoware/install/autoware_trajectory_follower_base/include/autoware/trajectory_follower_base/control_horizon.hpp:18,\n\
  \                 from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/include/autoware/trajectory_follower_node/controller_node.hpp:18,\n\
  \                 from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:15:\n\
  /usr/include/c++/11/bits/unique_ptr.h: In instantiation of ‘typename std::_MakeUniq<_Tp>::__single_object\
  \ std::make_unique(_Args&& ...) [with _Tp = autoware::motion::control::mpc_lateral_controller::MpcLateralController;\
  \ _Args = {autoware::motion::control::trajectory_follower_node::Controller*}; typename\
  \ std::_MakeUniq<_Tp>::__single_object = std::unique_ptr<autoware::motion::control::mpc_lateral_controller::MpcLateralController,\
  \ std::default_delete<autoware::motion::control::mpc_lateral_controller::MpcLateralController>\
  \ >]’:\n/workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:67:91:\
  \   required from here\n/usr/include/c++/11/bits/unique_ptr.h:962:30: error: no\
  \ matching function for call to ‘autoware::motion::control::mpc_lateral_controller::MpcLateralController::MpcLateralController(autoware::motion::control::trajectory_follower_node::Controller*)’\n\
  \  962 |     { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...));\
  \ }\n      |                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
  In file included from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:17:\n\
  /workspace/repos/autoware/install/autoware_mpc_lateral_controller/include/autoware/mpc_lateral_controller/mpc_lateral_controller.hpp:59:12:\
  \ note: candidate: ‘autoware::motion::control::mpc_lateral_controller::MpcLateralController::MpcLateralController(rclcpp::Node&,\
  \ std::shared_ptr<diagnostic_updater::Updater>)’\n   59 |   explicit MpcLateralController(\n\
  \      |            ^~~~~~~~~~~~~~~~~~~~\n/workspace/repos/autoware/install/autoware_mpc_lateral_controller/include/autoware/mpc_lateral_controller/mpc_lateral_controller.hpp:59:12:\
  \ note:   candidate expects 2 arguments, 1 provided\nIn file included from /usr/include/c++/11/memory:76,\n\
  \                 from /workspace/repos/autoware/install/autoware_control_msgs/include/autoware_control_msgs/autoware_control_msgs/msg/detail/lateral__struct.hpp:10,\n\
  \                 from /workspace/repos/autoware/install/autoware_control_msgs/include/autoware_control_msgs/autoware_control_msgs/msg/lateral.hpp:7,\n\
  \                 from /workspace/repos/autoware/install/autoware_trajectory_follower_base/include/autoware/trajectory_follower_base/control_horizon.hpp:18,\n\
  \                 from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/include/autoware/trajectory_follower_node/controller_node.hpp:18,\n\
  \                 from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:15:\n\
  /usr/include/c++/11/bits/unique_ptr.h: In instantiation of ‘typename std::_MakeUniq<_Tp>::__single_object\
  \ std::make_unique(_Args&& ...) [with _Tp = autoware::pure_pursuit::PurePursuitLateralController;\
  \ _Args = {autoware::motion::control::trajectory_follower_node::Controller*}; typename\
  \ std::_MakeUniq<_Tp>::__single_object = std::unique_ptr<autoware::pure_pursuit::PurePursuitLateralController,\
  \ std::default_delete<autoware::pure_pursuit::PurePursuitLateralController> >]’:\n\
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:70:99:\
  \   required from here\n/usr/include/c++/11/bits/unique_ptr.h:962:30: error: no\
  \ matching function for call to ‘autoware::pure_pursuit::PurePursuitLateralController::PurePursuitLateralController(autoware::motion::control::trajectory_follower_node::Controller*)’\n\
  \  962 |     { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...));\
  \ }\n      |                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
  In file included from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:19:\n\
  /workspace/repos/autoware/install/autoware_pure_pursuit/include/autoware/pure_pursuit/autoware_pure_pursuit_lateral_controller.hpp:104:12:\
  \ note: candidate: ‘autoware::pure_pursuit::PurePursuitLateralController::PurePursuitLateralController(rclcpp::Node&)’\n\
  \  104 |   explicit PurePursuitLateralController(rclcpp::Node & node);\n      |\
  \            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/workspace/repos/autoware/install/autoware_pure_pursuit/include/autoware/pure_pursuit/autoware_pure_pursuit_lateral_controller.hpp:104:56:\
  \ note:   no known conversion for argument 1 from ‘autoware::motion::control::trajectory_follower_node::Controller*’\
  \ to ‘rclcpp::Node&’\n  104 |   explicit PurePursuitLateralController(rclcpp::Node\
  \ & node);\n      |                                         ~~~~~~~~~~~~~~~^~~~\n\
  cc1plus: all warnings being treated as errors\ngmake[2]: *** [CMakeFiles/controller_node.dir/build.make:76:\
  \ CMakeFiles/controller_node.dir/src/controller_node.cpp.o] Error 1\ngmake[1]: ***\
  \ [CMakeFiles/Makefile2:163: CMakeFiles/controller_node.dir/all] Error 2\ngmake:\
  \ *** [Makefile:146: all] Error 2\n---\nFailed   <<< autoware_trajectory_follower_node\
  \ [11.0s, exited with code 2]\n\nSummary: 0 packages finished [12.4s]\n  1 package\
  \ failed: autoware_trajectory_follower_node\n  1 package had stderr output: autoware_trajectory_follower_node\n"
generate_code.cpp: |-
  Controller::Controller(const rclcpp::NodeOptions & node_options) : Node("controller", node_options)
  {
    // Initialize logger configuration
    logger_configure_.initialize(this);

    // Get controller parameters
    const auto lateral_controller_mode = getLateralControllerMode(
      declare_parameter<std::string>("lateral_controller_mode", "MPC"));
    const auto longitudinal_controller_mode = getLongitudinalControllerMode(
      declare_parameter<std::string>("longitudinal_controller_mode", "PID"));

    // Initialize lateral controller based on mode
    switch (lateral_controller_mode) {
      case LateralControllerMode::MPC:
        lateral_controller_ = std::make_unique<mpc_lateral_controller::MpcLateralController>(this);
        break;
      case LateralControllerMode::PURE_PURSUIT:
        lateral_controller_ = std::make_unique<autoware::pure_pursuit::PurePursuitLateralController>(this);
        break;
      default:
        RCLCPP_ERROR(get_logger(), "Invalid lateral controller mode");
        throw std::runtime_error("Invalid lateral controller mode");
    }

    // Initialize longitudinal controller based on mode
    // (Implementation would be similar to lateral controller)

    // Setup publishers
    control_cmd_pub_ = create_publisher<autoware_auto_control_msgs::msg::AckermannControlCommand>(
      "output/control_cmd", rclcpp::QoS(1));
    debug_pub_ = create_publisher<autoware_auto_control_msgs::msg::Float32MultiArrayDiagnostic>(
      "output/debug", rclcpp::QoS(1));

    // Setup published time publisher
    published_time_publisher_.initialize(this);

    // Create control timer
    const auto period_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
      std::chrono::duration<double>(1.0 / declare_parameter<double>("control_rate", 30.0)));
    control_timer_ = rclcpp::create_timer(
      this, get_clock(), period_ns, std::bind(&Controller::onTimer, this));
  }
ground_truth.cpp: |-
  Controller::Controller(const rclcpp::NodeOptions & node_options) : Node("controller", node_options)
  {
    using std::placeholders::_1;

    const double ctrl_period = declare_parameter<double>("ctrl_period");
    timeout_thr_sec_ = declare_parameter<double>("timeout_thr_sec");
    // NOTE: It is possible that using control_horizon could be expected to enhance performance,
    // but it is not a formal interface topic, only an experimental one.
    // So it is disabled by default.
    enable_control_cmd_horizon_pub_ =
      declare_parameter<bool>("enable_control_cmd_horizon_pub", false);

    diag_updater_->setHardwareID("trajectory_follower_node");

    const auto lateral_controller_mode =
      getLateralControllerMode(declare_parameter<std::string>("lateral_controller_mode"));
    switch (lateral_controller_mode) {
      case LateralControllerMode::MPC: {
        lateral_controller_ =
          std::make_shared<mpc_lateral_controller::MpcLateralController>(*this, diag_updater_);
        break;
      }
      case LateralControllerMode::PURE_PURSUIT: {
        lateral_controller_ =
          std::make_shared<autoware::pure_pursuit::PurePursuitLateralController>(*this);
        break;
      }
      default:
        throw std::domain_error("[LateralController] invalid algorithm");
    }

    const auto longitudinal_controller_mode =
      getLongitudinalControllerMode(declare_parameter<std::string>("longitudinal_controller_mode"));
    switch (longitudinal_controller_mode) {
      case LongitudinalControllerMode::PID: {
        longitudinal_controller_ =
          std::make_shared<pid_longitudinal_controller::PidLongitudinalController>(
            *this, diag_updater_);
        break;
      }
      default:
        throw std::domain_error("[LongitudinalController] invalid algorithm");
    }

    control_cmd_pub_ = create_publisher<autoware_control_msgs::msg::Control>(
      "~/output/control_cmd", rclcpp::QoS{1}.transient_local());
    pub_processing_time_lat_ms_ =
      create_publisher<Float64Stamped>("~/lateral/debug/processing_time_ms", 1);
    pub_processing_time_lon_ms_ =
      create_publisher<Float64Stamped>("~/longitudinal/debug/processing_time_ms", 1);
    debug_marker_pub_ =
      create_publisher<visualization_msgs::msg::MarkerArray>("~/output/debug_marker", rclcpp::QoS{1});

    if (enable_control_cmd_horizon_pub_) {
      control_cmd_horizon_pub_ = create_publisher<autoware_control_msgs::msg::ControlHorizon>(
        "~/debug/control_cmd_horizon", 1);
    }

    // Timer
    {
      const auto period_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
        std::chrono::duration<double>(ctrl_period));
      timer_control_ = rclcpp::create_timer(
        this, get_clock(), period_ns, std::bind(&Controller::callbackTimerControl, this));
    }

    logger_configure_ = std::make_unique<autoware::universe_utils::LoggerLevelConfigure>(this);

    published_time_publisher_ =
      std::make_unique<autoware::universe_utils::PublishedTimePublisher>(this);
  }
architecture-codes:
  - Topic/Service Issue - Topic/Service Name Mismatch Issue
  - Topic/Service Issue - QoS Policy Incompatibility Issue
  - Topic/Service Issue - Incomplete Topic/Service Initialization Issue
  - Topic/Service Issue - Topic/Service Use Error Issue
  - ROS Parameter Issue - Use Non-existent Parameter Issue
  - ROS Parameter Issue - Insufficient Parameter Design Issue
  - ROS Logger Issue - ROS Logger Missing Issue
  - ROS Timer Issue - Clock Source Usage Issue
  - ROS Diagnostic Issue - Incomplete Diagnostic Lifecycle Implementation Issue
functionality-codes:
  - Domain Library Issue - Lack of Domain Library Utilization Issue
  - Incomplete Code Issue - Missing Multiple Steps Issue

root-cause-codes:
  - Weakness in System-Level Integration - Unclear of ROS computation graph
  - Deficiencies in Domain Knowledge - Lack of ROS development best practices