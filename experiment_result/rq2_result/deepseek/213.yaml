compilation.log: |
  Starting >>> nav2_mppi_controller
  Finished <<< nav2_mppi_controller [0.78s]

  Summary: 1 package finished [1.08s]
generate_code.cpp: "inline float posePointAngle(\n  const geometry_msgs::msg::Pose\
  \ & pose, double point_x, double point_y, bool forward_preference)\n{\n  // Calculate\
  \ the vector from pose position to target point\n  double dx = point_x - pose.position.x;\n\
  \  double dy = point_y - pose.position.y;\n  \n  // Calculate the angle to the target\
  \ point\n  float target_angle = atan2(dy, dx);\n  \n  // Get the current yaw angle\
  \ from the pose's quaternion\n  tf2::Quaternion q(\n    pose.orientation.x,\n  \
  \  pose.orientation.y,\n    pose.orientation.z,\n    pose.orientation.w);\n  tf2::Matrix3x3\
  \ m(q);\n  double roll, pitch, yaw;\n  m.getRPY(roll, pitch, yaw);\n  \n  // Calculate\
  \ the angle difference\n  float angle_diff = target_angle - yaw;\n  \n  // Normalize\
  \ the angle to [-π, π]\n  while (angle_diff > M_PI) angle_diff -= 2.0 * M_PI;\n\
  \  while (angle_diff < -M_PI) angle_diff += 2.0 * M_PI;\n  \n  // If reversing is\
  \ allowed and the angle is better in reverse\n  if (forward_preference && fabs(angle_diff)\
  \ > M_PI_2) {\n    angle_diff = angle_diff > 0 ? angle_diff - M_PI : angle_diff\
  \ + M_PI;\n  }\n  \n  return angle_diff;\n}"
ground_truth.cpp: |-
  inline float posePointAngle(
    const geometry_msgs::msg::Pose & pose, double point_x, double point_y, bool forward_preference)
  {
    float pose_x = pose.position.x;
    float pose_y = pose.position.y;
    float pose_yaw = tf2::getYaw(pose.orientation);

    float yaw = atan2f(point_y - pose_y, point_x - pose_x);

    // If no preference for forward, return smallest angle either in heading or 180 of heading
    if (!forward_preference) {
      return std::min(
        fabs(angles::shortest_angular_distance(yaw, pose_yaw)),
        fabs(angles::shortest_angular_distance(yaw, angles::normalize_angle(pose_yaw + M_PI))));
    }

    return fabs(angles::shortest_angular_distance(yaw, pose_yaw));
  }
architecture-codes: []

functionality-codes:
  - Domain Library Issue - Lack of Domain Library Utilization Issue
  - Operation/Calculation Issue - Algorithmic State and Initialization Issue
  - Condition Issue - Condition Check Logic Misapplication Issue 
  - Constant Value Issue 

root-cause-codes:
  - Inadequate Comprehension of Functional Logic - Inadequate Understanding of Task Logic 
  - Deficiencies in Domain Knowledge - Lack of ROS development best practices 
  - Deficiencies in Domain Knowledge - Insufficient understanding of ROS Programming
  - Weakness in System-Level Integration - Lack of familiarity with the existing codebase 