compilation.log: |
  Starting >>> autoware_behavior_path_side_shift_module
  --- stderr: autoware_behavior_path_side_shift_module
  /workspace/repos/autoware/src/universe/autoware.universe/planning/behavior_path_planner/autoware_behavior_path_side_shift_module/src/utils.cpp: In function ‘void autoware::behavior_path_planner::setOrientation(tier4_planning_msgs::msg::PathWithLaneId*)’:
  /workspace/repos/autoware/src/universe/autoware.universe/planning/behavior_path_planner/autoware_behavior_path_side_shift_module/src/utils.cpp:37:46: error: ‘tier4_autoware_utils’ has not been declared
     37 |     path->points[i].point.pose.orientation = tier4_autoware_utils::createQuaternionFromYaw(std::atan2(dy, dx));
        |                                              ^~~~~~~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/planning/behavior_path_planner/autoware_behavior_path_side_shift_module/src/utils.cpp:45:53: error: ‘tier4_autoware_utils’ has not been declared
     45 |     path->points[last_idx].point.pose.orientation = tier4_autoware_utils::createQuaternionFromYaw(std::atan2(dy, dx));
        |                                                     ^~~~~~~~~~~~~~~~~~~~
  gmake[2]: *** [CMakeFiles/autoware_behavior_path_side_shift_module.dir/build.make:90: CMakeFiles/autoware_behavior_path_side_shift_module.dir/src/utils.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:178: CMakeFiles/autoware_behavior_path_side_shift_module.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_behavior_path_side_shift_module [11.9s, exited with code 2]

  Summary: 0 packages finished [13.3s]
    1 package failed: autoware_behavior_path_side_shift_module
    1 package had stderr output: autoware_behavior_path_side_shift_module
generate_code.cpp: |-
  void setOrientation(PathWithLaneId * path)
  {
    if (path == nullptr || path->points.empty()) {
      return;
    }

    // Set orientation for all points except the last one
    for (size_t i = 0; i < path->points.size() - 1; ++i) {
      const auto dx = path->points[i + 1].point.pose.position.x - path->points[i].point.pose.position.x;
      const auto dy = path->points[i + 1].point.pose.position.y - path->points[i].point.pose.position.y;
      path->points[i].point.pose.orientation = tier4_autoware_utils::createQuaternionFromYaw(std::atan2(dy, dx));
    }

    // Set orientation for the last point using the previous point
    if (path->points.size() > 1) {
      const auto last_idx = path->points.size() - 1;
      const auto dx = path->points[last_idx].point.pose.position.x - path->points[last_idx - 1].point.pose.position.x;
      const auto dy = path->points[last_idx].point.pose.position.y - path->points[last_idx - 1].point.pose.position.y;
      path->points[last_idx].point.pose.orientation = tier4_autoware_utils::createQuaternionFromYaw(std::atan2(dy, dx));
    }
  }
ground_truth.cpp: |-
  void setOrientation(PathWithLaneId * path)
  {
    // Reset orientation
    for (size_t idx = 0; idx < path->points.size(); ++idx) {
      double angle = 0.0;
      auto & pt = path->points.at(idx);
      if (idx + 1 < path->points.size()) {
        const auto next_pt = path->points.at(idx + 1);
        angle = std::atan2(
          next_pt.point.pose.position.y - pt.point.pose.position.y,
          next_pt.point.pose.position.x - pt.point.pose.position.x);
      } else if (idx != 0) {
        const auto prev_pt = path->points.at(idx - 1);
        angle = std::atan2(
          pt.point.pose.position.y - prev_pt.point.pose.position.y,
          pt.point.pose.position.x - prev_pt.point.pose.position.x);
      }
      tf2::Quaternion yaw_quat;
      yaw_quat.setRPY(0, 0, angle);
      pt.point.pose.orientation = tf2::toMsg(yaw_quat);
    }
  }

architecture-codes: []

functionality-codes:
  - Domain Library Issue - Domain Specific Library Utilization Error
  - Condition Issue - Condition Check Logic Misapplication Issue

root-cause-codes:
  - Deficiencies in Domain Knowledge - Lack of Knowledge of Domain-Specific Libraries
  - Deficiencies in Domain Knowledge - Insufficient understanding of ROS Programming
  - Weakness in System-Level Integration - Lack of familiarity with the existing codebase