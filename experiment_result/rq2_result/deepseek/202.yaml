compilation.log: |
  Starting >>> nav2_collision_monitor
  Finished <<< nav2_collision_monitor [0.46s]

  Summary: 1 package finished [0.71s]
generate_code.cpp: "double Polygon::getCollisionTime(\n  const std::vector<Point>\
  \ & collision_points,\n  const Velocity & velocity) const\n{\n  // If no velocity\
  \ or no collision points, return -1 (no collision)\n  if (velocity.x == 0.0 && velocity.y\
  \ == 0.0 && velocity.tw == 0.0) {\n    return -1.0;\n  }\n  if (collision_points.empty())\
  \ {\n    return -1.0;\n  }\n\n  double time = 0.0;\n  Pose current_pose;  // Starts\
  \ at origin (0,0,0)\n  Velocity current_velocity = velocity;\n  std::vector<Point>\
  \ transformed_points = collision_points;\n\n  while (time <= time_before_collision_)\
  \ {\n    // Check if any points are inside the polygon in current state\n    if\
  \ (getPointsInside(transformed_points) > 0) {\n      return time;\n    }\n\n   \
  \ // Project state forward by simulation_time_step_\n    projectState(simulation_time_step_,\
  \ current_pose, current_velocity);\n    \n    // Transform points to new pose\n\
  \    transformPoints(current_pose, transformed_points);\n    \n    time += simulation_time_step_;\n\
  \  }\n\n  // No collision detected within time horizon\n  return -1.0;\n}"
ground_truth.cpp: |-
  double Polygon::getCollisionTime(
    const std::vector<Point> & collision_points,
    const Velocity & velocity) const
  {
    // Initial robot pose is {0,0} in base_footprint coordinates
    Pose pose = {0.0, 0.0, 0.0};
    Velocity vel = velocity;

    // Array of points transformed to the frame concerned with pose on each simulation step
    std::vector<Point> points_transformed = collision_points;

    // Check static polygon
    if (getPointsInside(points_transformed) >= max_points_) {
      return 0.0;
    }

    // Robot movement simulation
    for (double time = 0.0; time <= time_before_collision_; time += simulation_time_step_) {
      // Shift the robot pose towards to the vel during simulation_time_step_ time interval
      // NOTE: vel is changing during the simulation
      projectState(simulation_time_step_, pose, vel);
      // Transform collision_points to the frame concerned with current robot pose
      points_transformed = collision_points;
      transformPoints(pose, points_transformed);
      // If the collision occurred on this stage, return the actual time before a collision
      // as if robot was moved with given velocity
      if (getPointsInside(points_transformed) > max_points_) {
        return time;
      }
    }

    // There is no collision
    return -1.0;
  }
architecture-codes:
  - ROS Message Issue - Message Initialization Issue 
  - ROS Timer Issue - Clock Source Usage Issue 

functionality-codes:
  - Condition Issue - Condition Check Logic Misapplication Issue
  - Incomplete Code Issue - Missing Multiple Steps Issue
  - Operation/Calculation Issue - Data Structure Semantic Misinterpretation Issue 

root-cause-codes:
  - Inadequate Comprehension of Functional Logic - Inadequate Understanding of Task Logic
  - Deficiencies in Domain Knowledge - Lack of Knowledge of Domain-Specific Libraries 
  - Deficiencies in Domain Knowledge - Lack of ROS development best practices 