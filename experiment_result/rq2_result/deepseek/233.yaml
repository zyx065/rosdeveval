compilation.log: |
  Starting >>> autoware_autonomous_emergency_braking
  --- stderr: autoware_autonomous_emergency_braking
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_autonomous_emergency_braking/src/node.cpp: In member function ‘rcl_interfaces::msg::SetParametersResult autoware::motion::control::autonomous_emergency_braking::AEB::onParameter(const std::vector<rclcpp::Parameter>&)’:
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_autonomous_emergency_braking/src/node.cpp:237:5: error: ‘updateParam’ was not declared in this scope; did you mean ‘autoware::universe_utils::updateParam’?
    237 |     updateParam(parameters, "publish_debug_pointcloud", publish_debug_pointcloud_);
        |     ^~~~~~~~~~~
        |     autoware::universe_utils::updateParam
  In file included from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_autonomous_emergency_braking/src/node.cpp:23:
  /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/ros/update_param.hpp:26:6: note: ‘autoware::universe_utils::updateParam’ declared here
     26 | bool updateParam(const std::vector<rclcpp::Parameter> & params, const std::string & name, T & value)
        |      ^~~~~~~~~~~
  gmake[2]: *** [CMakeFiles/autoware_autonomous_emergency_braking_node.dir/build.make:76: CMakeFiles/autoware_autonomous_emergency_braking_node.dir/src/node.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:187: CMakeFiles/autoware_autonomous_emergency_braking_node.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_autonomous_emergency_braking [18.2s, exited with code 2]

  Summary: 0 packages finished [19.6s]
    1 package failed: autoware_autonomous_emergency_braking
    1 package had stderr output: autoware_autonomous_emergency_braking
generate_code.cpp: |-
  rcl_interfaces::msg::SetParametersResult AEB::onParameter(
    const std::vector<rclcpp::Parameter> & parameters)
  {
    rcl_interfaces::msg::SetParametersResult result;
    result.successful = true;
    result.reason = "";

    try {
      // Boolean parameters
      updateParam(parameters, "publish_debug_pointcloud", publish_debug_pointcloud_);
      updateParam(parameters, "publish_debug_markers", publish_debug_markers_);
      updateParam(parameters, "use_predicted_trajectory", use_predicted_trajectory_);
      updateParam(parameters, "use_imu_path", use_imu_path_);
      updateParam(parameters, "limit_imu_path_lat_dev", limit_imu_path_lat_dev_);
      updateParam(parameters, "limit_imu_path_length", limit_imu_path_length_);
      updateParam(parameters, "use_pointcloud_data", use_pointcloud_data_);
      updateParam(parameters, "use_predicted_object_data", use_predicted_object_data_);
      updateParam(parameters, "use_object_velocity_calculation", use_object_velocity_calculation_);
      updateParam(parameters, "check_autoware_state", check_autoware_state_);

      // Double parameters
      updateParam(parameters, "imu_path_lat_dev_threshold", imu_path_lat_dev_threshold_);
      updateParam(parameters, "path_footprint_extra_margin", path_footprint_extra_margin_);
      updateParam(parameters, "speed_calculation_expansion_margin", speed_calculation_expansion_margin_);
      updateParam(parameters, "detection_range_min_height", detection_range_min_height_);
      updateParam(parameters, "detection_range_max_height_margin", detection_range_max_height_margin_);
      updateParam(parameters, "voxel_grid_x", voxel_grid_x_);
      updateParam(parameters, "voxel_grid_y", voxel_grid_y_);
      updateParam(parameters, "voxel_grid_z", voxel_grid_z_);
      updateParam(parameters, "min_generated_imu_path_length", min_generated_imu_path_length_);
      updateParam(parameters, "max_generated_imu_path_length", max_generated_imu_path_length_);
      updateParam(parameters, "expand_width", expand_width_);
      updateParam(parameters, "longitudinal_offset_margin", longitudinal_offset_margin_);
      updateParam(parameters, "t_response", t_response_);
      updateParam(parameters, "a_ego_min", a_ego_min_);
      updateParam(parameters, "a_obj_min", a_obj_min_);
      updateParam(parameters, "cluster_tolerance", cluster_tolerance_);
      updateParam(parameters, "cluster_minimum_height", cluster_minimum_height_);
      updateParam(parameters, "imu_prediction_time_horizon", imu_prediction_time_horizon_);
      updateParam(parameters, "imu_prediction_time_interval", imu_prediction_time_interval_);
      updateParam(parameters, "mpc_prediction_time_horizon", mpc_prediction_time_horizon_);
      updateParam(parameters, "mpc_prediction_time_interval", mpc_prediction_time_interval_);

      // Integer parameters
      updateParam(parameters, "minimum_cluster_size", minimum_cluster_size_);
      updateParam(parameters, "maximum_cluster_size", maximum_cluster_size_);

    } catch (const rclcpp::ParameterTypeException & e) {
      result.successful = false;
      result.reason = e.what();
    }

    return result;
  }
ground_truth.cpp: |-
  rcl_interfaces::msg::SetParametersResult AEB::onParameter(
    const std::vector<rclcpp::Parameter> & parameters)
  {
    using autoware::universe_utils::updateParam;
    updateParam<bool>(parameters, "publish_debug_pointcloud", publish_debug_pointcloud_);
    updateParam<bool>(parameters, "publish_debug_markers", publish_debug_markers_);
    updateParam<bool>(parameters, "use_predicted_trajectory", use_predicted_trajectory_);
    updateParam<bool>(parameters, "use_imu_path", use_imu_path_);
    updateParam<bool>(parameters, "limit_imu_path_lat_dev", limit_imu_path_lat_dev_);
    updateParam<bool>(parameters, "limit_imu_path_length", limit_imu_path_length_);
    updateParam<bool>(parameters, "use_pointcloud_data", use_pointcloud_data_);
    updateParam<bool>(parameters, "use_predicted_object_data", use_predicted_object_data_);
    updateParam<bool>(
      parameters, "use_object_velocity_calculation", use_object_velocity_calculation_);
    updateParam<bool>(parameters, "check_autoware_state", check_autoware_state_);
    updateParam<double>(parameters, "path_footprint_extra_margin", path_footprint_extra_margin_);
    updateParam<double>(parameters, "imu_path_lat_dev_threshold", imu_path_lat_dev_threshold_);
    updateParam<double>(
      parameters, "speed_calculation_expansion_margin", speed_calculation_expansion_margin_);
    updateParam<double>(parameters, "detection_range_min_height", detection_range_min_height_);
    updateParam<double>(
      parameters, "detection_range_max_height_margin", detection_range_max_height_margin_);
    updateParam<double>(parameters, "voxel_grid_x", voxel_grid_x_);
    updateParam<double>(parameters, "voxel_grid_y", voxel_grid_y_);
    updateParam<double>(parameters, "voxel_grid_z", voxel_grid_z_);
    updateParam<double>(parameters, "min_generated_imu_path_length", min_generated_imu_path_length_);
    updateParam<double>(parameters, "max_generated_imu_path_length", max_generated_imu_path_length_);
    updateParam<double>(parameters, "expand_width", expand_width_);
    updateParam<double>(parameters, "longitudinal_offset_margin", longitudinal_offset_margin_);
    updateParam<double>(parameters, "t_response", t_response_);
    updateParam<double>(parameters, "a_ego_min", a_ego_min_);
    updateParam<double>(parameters, "a_obj_min", a_obj_min_);

    updateParam<double>(parameters, "cluster_tolerance", cluster_tolerance_);
    updateParam<double>(parameters, "cluster_minimum_height", cluster_minimum_height_);
    updateParam<int>(parameters, "minimum_cluster_size", minimum_cluster_size_);
    updateParam<int>(parameters, "maximum_cluster_size", maximum_cluster_size_);

    updateParam<double>(parameters, "imu_prediction_time_horizon", imu_prediction_time_horizon_);
    updateParam<double>(parameters, "imu_prediction_time_interval", imu_prediction_time_interval_);
    updateParam<double>(parameters, "mpc_prediction_time_horizon", mpc_prediction_time_horizon_);
    updateParam<double>(parameters, "mpc_prediction_time_interval", mpc_prediction_time_interval_);

    {  // Object history data keeper setup
      auto [previous_obstacle_keep_time, collision_keeping_sec] = collision_data_keeper_.getTimeout();
      updateParam<double>(parameters, "previous_obstacle_keep_time", previous_obstacle_keep_time);
      updateParam<double>(parameters, "collision_keeping_sec", collision_keeping_sec);
      collision_data_keeper_.setTimeout(collision_keeping_sec, previous_obstacle_keep_time);
    }

    rcl_interfaces::msg::SetParametersResult result;
    result.successful = true;
    result.reason = "success";
    return result;
  }
architecture-codes:
  - ROS Parameter Issue - Use Non-existent Parameter Issue 
  - ROS Parameter Issue - Insufficient Parameter Design Issue
functionality-codes:
  - Incomplete Code Issue - Missing Multiple Steps Issue 

root-cause-codes:
  - Deficiencies in Domain Knowledge - Insufficient understanding of ROS Programming 
  - Deficiencies in Domain Knowledge - Lack of ROS development best practices 
  - Inadequate Comprehension of Functional Logic - Inadequate Understanding of System Requirements
  - Weakness in System-Level Integration - Lack of familiarity with the existing codebase 