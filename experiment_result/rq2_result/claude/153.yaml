compilation.log: |
  Starting >>> moveit_servo
  Finished <<< moveit_servo [0.74s]

  Summary: 1 package finished [1.21s]
generate_code.cpp: |
  void enforceVelocityLimits(const moveit::core::JointModelGroup* joint_model_group, const double publish_period,
                            sensor_msgs::msg::JointState& joint_state, const double override_velocity_scaling_factor)
  {
    if (!joint_model_group || publish_period <= 0.0)
      return;

    const std::vector<std::string>& joint_names = joint_model_group->getVariableNames();
    const std::size_t num_joints = joint_names.size();
    
    if (joint_state.velocity.size() != num_joints || joint_state.position.size() != num_joints)
      return;

    // Convert velocity vector to Eigen format for scaling calculation
    Eigen::VectorXd velocity_vector(num_joints);
    for (std::size_t i = 0; i < num_joints; ++i)
    {
      velocity_vector[i] = joint_state.velocity[i];
    }

    // Determine scaling factor
    double scaling_factor = 1.0;
    if (override_velocity_scaling_factor > 0.0)
    {
      scaling_factor = std::min(1.0, override_velocity_scaling_factor);
    }
    else
    {
      scaling_factor = getVelocityScalingFactor(joint_model_group, velocity_vector);
    }

    // Apply scaling to velocities and update positions
    for (std::size_t i = 0; i < num_joints; ++i)
    {
      // Scale velocity
      joint_state.velocity[i] *= scaling_factor;
      
      // Update position based on scaled velocity and time period
      joint_state.position[i] += joint_state.velocity[i] * publish_period;
    }
  }
ground_truth.cpp: |-
  void enforceVelocityLimits(const moveit::core::JointModelGroup* joint_model_group, const double publish_period,
                             sensor_msgs::msg::JointState& joint_state, const double override_velocity_scaling_factor)
  {
    // Get the velocity scaling factor
    Eigen::VectorXd velocity =
        Eigen::Map<Eigen::VectorXd, Eigen::Unaligned>(joint_state.velocity.data(), joint_state.velocity.size());
    double velocity_scaling_factor = override_velocity_scaling_factor;
    // if the override velocity scaling factor is approximately zero then the user is not overriding the value.
    if (override_velocity_scaling_factor < 0.01)
      velocity_scaling_factor = getVelocityScalingFactor(joint_model_group, velocity);

    // Take a smaller step if the velocity scaling factor is less than 1
    if (velocity_scaling_factor < 1)
    {
      Eigen::VectorXd velocity_residuals = (1 - velocity_scaling_factor) * velocity;
      Eigen::VectorXd positions =
          Eigen::Map<Eigen::VectorXd, Eigen::Unaligned>(joint_state.position.data(), joint_state.position.size());
      positions -= velocity_residuals * publish_period;

      velocity *= velocity_scaling_factor;
      // Back to sensor_msgs type
      joint_state.velocity = std::vector<double>(velocity.data(), velocity.data() + velocity.size());
      joint_state.position = std::vector<double>(positions.data(), positions.data() + positions.size());
    }
  }
architecture-codes: []
functionality-codes:
  - Conditional Checks Issues - Conditional Check Logic Misapplication
  - Conditional Checks Issues - Conditional Check Missing
  - Domain Library Issues - Lack of Domain Library Utilization
  - Incomplete Code - Missing Multiple Steps
  - Operation/Calculation Error - Incorrect arithmetic operation
  - Garbage Code - Wrong logical
root-cause-codes:
  - Inadequate Comprehension of Functional Logic - Inadequate Understanding of Task Logic
  - Deficiencies in Domain Knowledge - Lack of Knowledge of Domain-Specific Libraries
  - Deficiencies in Domain Knowledge - Lack of ROS development best practices