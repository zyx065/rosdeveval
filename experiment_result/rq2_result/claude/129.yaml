compilation.log: |
  Starting >>> moveit_planners_ompl
  Finished <<< moveit_planners_ompl [0.97s]

  Summary: 1 package finished [1.42s]
generate_code.cpp: |
  void ConstrainedPlanningStateSpace::copyJointToOMPLState(ompl::base::State* ompl_state,
                                                          const moveit::core::RobotState& robot_state,
                                                          const moveit::core::JointModel* joint_model,
                                                          int ompl_state_joint_index) const
  {
      const double* robot_state_values = robot_state.getVariablePositions();
      int joint_first_variable_index = joint_model->getFirstVariableIndex();
      int joint_variable_count = joint_model->getVariableCount();
      
      for (int i = 0; i < joint_variable_count; ++i)
      {
          double* ompl_state_value = getValueAddressAtIndex(ompl_state, ompl_state_joint_index + i);
          *ompl_state_value = robot_state_values[joint_first_variable_index + i];
      }
  }
ground_truth.cpp: |-
  void ConstrainedPlanningStateSpace::copyJointToOMPLState(ompl::base::State* ompl_state,
                                                           const moveit::core::RobotState& robot_state,
                                                           const moveit::core::JointModel* joint_model,
                                                           int ompl_state_joint_index) const
  {
    assert(ompl_state != nullptr);
    assert(joint_model != nullptr);
    memcpy(getValueAddressAtIndex(ompl_state->as<ompl::base::ConstrainedStateSpace::StateType>()->getState(),
                                  ompl_state_joint_index),
           robot_state.getVariablePositions() + joint_model->getFirstVariableIndex(),
           joint_model->getVariableCount() * sizeof(double));

    // clear any cached info (such as validity known or not)
    ompl_state->as<ompl::base::ConstrainedStateSpace::StateType>()->getState()->as<StateType>()->clearKnownInformation();
  }
architecture-codes:
  - ROS Message Related Issues - Message Operation Issues
functionality-codes:
  - Conditional Checks Issues - Conditional Check Missing
  - Incomplete Code - Missing Multiple Steps
  - Domain Library Issues - Domain Specific Library Utilization Error
  - Reference Error - Wrong method
Root Cause Analysis:
  - Deficiencies in Domain Knowledge - Lack of Knowledge of Domain-Specific Libraries
  - Deficiencies in Domain Knowledge - Lack of ROS development best practices
  - Inadequate Comprehension of Functional Logic - Inadequate Understanding of System Requirements
  - Weakness in System-Level Integration - Lack of familiarity with the existing codebase