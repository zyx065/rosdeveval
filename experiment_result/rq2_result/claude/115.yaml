compilation.log: |
  Starting >>> autoware_motion_velocity_dynamic_obstacle_stop_module
  --- stderr: autoware_motion_velocity_dynamic_obstacle_stop_module
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp: In function ‘bool autoware::motion_velocity_planner::dynamic_obstacle_stop::is_unavoidable(const PredictedObject&, const Pose&, const std::optional<geometry_msgs::msg::Pose_<std::allocator<void> > >&, const autoware::motion_velocity_planner::dynamic_obstacle_stop::PlannerParam&)’:
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp:82:60: error: ‘const PredictedObject’ {aka ‘const struct autoware_perception_msgs::msg::PredictedObject_<std::allocator<void> >’} has no member named ‘pose’
     82 |     std::vector<geometry_msgs::msg::Pose>{ego_pose, object.pose}, 0, 1);
        |                                                            ^~~~
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp:82:64: error: no matching function for call to ‘std::vector<geometry_msgs::msg::Pose_<std::allocator<void> >, std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > > >::vector(<brace-enclosed initializer list>)’
     82 |     std::vector<geometry_msgs::msg::Pose>{ego_pose, object.pose}, 0, 1);
        |                                                                ^
  In file included from /usr/include/c++/11/vector:67,
                   from /usr/include/boost/geometry/geometries/linestring.hpp:19,
                   from /usr/include/boost/geometry/geometries/geometries.hpp:18,
                   from /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/geometry/boost_geometry.hpp:19,
                   from /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/types.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp:15:
  /usr/include/c++/11/bits/stl_vector.h:653:9: note: candidate: ‘template<class _InputIterator, class> std::vector<_Tp, _Alloc>::vector(_InputIterator, _InputIterator, const allocator_type&) [with _InputIterator = _InputIterator; <template-parameter-2-2> = <template-parameter-1-2>; _Tp = geometry_msgs::msg::Pose_<std::allocator<void> >; _Alloc = std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > >]’
    653 |         vector(_InputIterator __first, _InputIterator __last,
        |         ^~~~~~
  /usr/include/c++/11/bits/stl_vector.h:653:9: note:   template argument deduction/substitution failed:
  /usr/include/c++/11/bits/stl_vector.h:625:7: note: candidate: ‘std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = geometry_msgs::msg::Pose_<std::allocator<void> >; _Alloc = std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > >; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > >]’
    625 |       vector(initializer_list<value_type> __l,
        |       ^~~~~~
  /usr/include/c++/11/bits/stl_vector.h:625:43: note:   no known conversion for argument 1 from ‘const Pose’ {aka ‘const geometry_msgs::msg::Pose_<std::allocator<void> >’} to ‘std::initializer_list<geometry_msgs::msg::Pose_<std::allocator<void> > >’
    625 |       vector(initializer_list<value_type> __l,
        |              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~
  /usr/include/c++/11/bits/stl_vector.h:607:7: note: candidate: ‘std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>&&, const allocator_type&) [with _Tp = geometry_msgs::msg::Pose_<std::allocator<void> >; _Alloc = std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > >; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > >]’
    607 |       vector(vector&& __rv, const allocator_type& __m)
        |       ^~~~~~
  /usr/include/c++/11/bits/stl_vector.h:607:23: note:   no known conversion for argument 1 from ‘const Pose’ {aka ‘const geometry_msgs::msg::Pose_<std::allocator<void> >’} to ‘std::vector<geometry_msgs::msg::Pose_<std::allocator<void> >, std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > > >&&’
    607 |       vector(vector&& __rv, const allocator_type& __m)
        |              ~~~~~~~~~^~~~
  /usr/include/c++/11/bits/stl_vector.h:589:7: note: candidate: ‘std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>&&, const allocator_type&, std::false_type) [with _Tp = geometry_msgs::msg::Pose_<std::allocator<void> >; _Alloc = std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > >; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > >; std::false_type = std::integral_constant<bool, false>]’
    589 |       vector(vector&& __rv, const allocator_type& __m, false_type)
        |       ^~~~~~
  /usr/include/c++/11/bits/stl_vector.h:589:7: note:   candidate expects 3 arguments, 2 provided
  /usr/include/c++/11/bits/stl_vector.h:585:7: note: candidate: ‘std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>&&, const allocator_type&, std::true_type) [with _Tp = geometry_msgs::msg::Pose_<std::allocator<void> >; _Alloc = std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > >; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > >; std::true_type = std::integral_constant<bool, true>]’
    585 |       vector(vector&& __rv, const allocator_type& __m, true_type) noexcept
        |       ^~~~~~
  /usr/include/c++/11/bits/stl_vector.h:585:7: note:   candidate expects 3 arguments, 2 provided
  /usr/include/c++/11/bits/stl_vector.h:575:7: note: candidate: ‘std::vector<_Tp, _Alloc>::vector(const std::vector<_Tp, _Alloc>&, const allocator_type&) [with _Tp = geometry_msgs::msg::Pose_<std::allocator<void> >; _Alloc = std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > >; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > >]’
    575 |       vector(const vector& __x, const allocator_type& __a)
        |       ^~~~~~
  /usr/include/c++/11/bits/stl_vector.h:575:28: note:   no known conversion for argument 1 from ‘const Pose’ {aka ‘const geometry_msgs::msg::Pose_<std::allocator<void> >’} to ‘const std::vector<geometry_msgs::msg::Pose_<std::allocator<void> >, std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > > >&’
    575 |       vector(const vector& __x, const allocator_type& __a)
        |              ~~~~~~~~~~~~~~^~~
  /usr/include/c++/11/bits/stl_vector.h:572:7: note: candidate: ‘std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>&&) [with _Tp = geometry_msgs::msg::Pose_<std::allocator<void> >; _Alloc = std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > >]’
    572 |       vector(vector&&) noexcept = default;
        |       ^~~~~~
  /usr/include/c++/11/bits/stl_vector.h:572:7: note:   candidate expects 1 argument, 2 provided
  /usr/include/c++/11/bits/stl_vector.h:553:7: note: candidate: ‘std::vector<_Tp, _Alloc>::vector(const std::vector<_Tp, _Alloc>&) [with _Tp = geometry_msgs::msg::Pose_<std::allocator<void> >; _Alloc = std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > >]’
    553 |       vector(const vector& __x)
        |       ^~~~~~
  /usr/include/c++/11/bits/stl_vector.h:553:7: note:   candidate expects 1 argument, 2 provided
  /usr/include/c++/11/bits/stl_vector.h:522:7: note: candidate: ‘std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>::size_type, const value_type&, const allocator_type&) [with _Tp = geometry_msgs::msg::Pose_<std::allocator<void> >; _Alloc = std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > >; std::vector<_Tp, _Alloc>::size_type = long unsigned int; std::vector<_Tp, _Alloc>::value_type = geometry_msgs::msg::Pose_<std::allocator<void> >; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > >]’
    522 |       vector(size_type __n, const value_type& __value,
        |       ^~~~~~
  /usr/include/c++/11/bits/stl_vector.h:522:24: note:   no known conversion for argument 1 from ‘const Pose’ {aka ‘const geometry_msgs::msg::Pose_<std::allocator<void> >’} to ‘std::vector<geometry_msgs::msg::Pose_<std::allocator<void> >, std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > > >::size_type’ {aka ‘long unsigned int’}
    522 |       vector(size_type __n, const value_type& __value,
        |              ~~~~~~~~~~^~~
  /usr/include/c++/11/bits/stl_vector.h:510:7: note: candidate: ‘std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>::size_type, const allocator_type&) [with _Tp = geometry_msgs::msg::Pose_<std::allocator<void> >; _Alloc = std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > >; std::vector<_Tp, _Alloc>::size_type = long unsigned int; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > >]’
    510 |       vector(size_type __n, const allocator_type& __a = allocator_type())
        |       ^~~~~~
  /usr/include/c++/11/bits/stl_vector.h:510:24: note:   no known conversion for argument 1 from ‘const Pose’ {aka ‘const geometry_msgs::msg::Pose_<std::allocator<void> >’} to ‘std::vector<geometry_msgs::msg::Pose_<std::allocator<void> >, std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > > >::size_type’ {aka ‘long unsigned int’}
    510 |       vector(size_type __n, const allocator_type& __a = allocator_type())
        |              ~~~~~~~~~~^~~
  /usr/include/c++/11/bits/stl_vector.h:497:7: note: candidate: ‘std::vector<_Tp, _Alloc>::vector(const allocator_type&) [with _Tp = geometry_msgs::msg::Pose_<std::allocator<void> >; _Alloc = std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > >; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > >]’
    497 |       vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
        |       ^~~~~~
  /usr/include/c++/11/bits/stl_vector.h:497:7: note:   candidate expects 1 argument, 2 provided
  /usr/include/c++/11/bits/stl_vector.h:487:7: note: candidate: ‘std::vector<_Tp, _Alloc>::vector() [with _Tp = geometry_msgs::msg::Pose_<std::allocator<void> >; _Alloc = std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > >]’
    487 |       vector() = default;
        |       ^~~~~~
  /usr/include/c++/11/bits/stl_vector.h:487:7: note:   candidate expects 0 arguments, 2 provided
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp:85:48: error: ‘const struct autoware::motion_velocity_planner::dynamic_obstacle_stop::PlannerParam’ has no member named ‘collision_hysteresis’
     85 |   if (object_distance < stop_distance + params.collision_hysteresis) {
        |                                                ^~~~~~~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp:87:61: error: ‘const struct autoware::motion_velocity_planner::dynamic_obstacle_stop::PlannerParam’ has no member named ‘collision_probability_threshold’
     87 |     if (object.classification.front().probability >= params.collision_probability_threshold &&
        |                                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp:88:27: error: ‘const _kinematics_type’ {aka ‘const struct autoware_perception_msgs::msg::PredictedObjectKinematics_<std::allocator<void> >’} has no member named ‘initial_twist’
     88 |         object.kinematics.initial_twist.twist.linear.x > params.collision_velocity_threshold) {
        |                           ^~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp:88:65: error: ‘const struct autoware::motion_velocity_planner::dynamic_obstacle_stop::PlannerParam’ has no member named ‘collision_velocity_threshold’
     88 |         object.kinematics.initial_twist.twist.linear.x > params.collision_velocity_threshold) {
        |                                                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
  gmake[2]: *** [CMakeFiles/autoware_motion_velocity_dynamic_obstacle_stop_module.dir/build.make:132: CMakeFiles/autoware_motion_velocity_dynamic_obstacle_stop_module.dir/src/object_filtering.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:157: CMakeFiles/autoware_motion_velocity_dynamic_obstacle_stop_module.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_motion_velocity_dynamic_obstacle_stop_module [10.1s, exited with code 2]

  Summary: 0 packages finished [11.5s]
    1 package failed: autoware_motion_velocity_dynamic_obstacle_stop_module
    1 package had stderr output: autoware_motion_velocity_dynamic_obstacle_stop_module
generate_code.cpp: |-
  bool is_unavoidable(
    const autoware_perception_msgs::msg::PredictedObject & object,
    const geometry_msgs::msg::Pose & ego_pose,
    const std::optional<geometry_msgs::msg::Pose> & ego_earliest_stop_pose,
    const PlannerParam & params)
  {
    // If no earliest stop pose is available, consider it unavoidable
    if (!ego_earliest_stop_pose) {
      return true;
    }

    // Calculate the signed arc length between ego pose and earliest stop pose
    const double stop_distance = autoware::motion_utils::calcSignedArcLength(
      std::vector<geometry_msgs::msg::Pose>{ego_pose, *ego_earliest_stop_pose}, 0, 1);

    // Calculate the distance to the predicted object
    const double object_distance = autoware::motion_utils::calcSignedArcLength(
      std::vector<geometry_msgs::msg::Pose>{ego_pose, object.pose}, 0, 1);

    // Check if the object is within the collision risk zone
    if (object_distance < stop_distance + params.collision_hysteresis) {
      // Check object's probability and velocity
      if (object.classification.front().probability >= params.collision_probability_threshold &&
          object.kinematics.initial_twist.twist.linear.x > params.collision_velocity_threshold) {
        return true;
      }
    }

    return false;
  }
ground_truth.cpp: |-
  bool is_unavoidable(
    const autoware_perception_msgs::msg::PredictedObject & object,
    const geometry_msgs::msg::Pose & ego_pose,
    const std::optional<geometry_msgs::msg::Pose> & ego_earliest_stop_pose,
    const PlannerParam & params)
  {
    constexpr auto same_direction_diff_threshold = M_PI_2 + M_PI_4;
    const auto & o_pose = object.kinematics.initial_pose_with_covariance.pose;
    const auto o_yaw = tf2::getYaw(o_pose.orientation);
    const auto ego_yaw = tf2::getYaw(ego_pose.orientation);
    const auto yaw_diff = std::abs(universe_utils::normalizeRadian(o_yaw - ego_yaw));
    const auto opposite_heading = yaw_diff > same_direction_diff_threshold;
    const auto collision_distance_threshold =
      params.ego_lateral_offset + object.shape.dimensions.y / 2.0 + params.hysteresis;
    const auto lat_distance =
      std::abs(universe_utils::calcLateralDeviation(o_pose, ego_pose.position));
    auto has_collision = opposite_heading && lat_distance <= collision_distance_threshold;
    if (ego_earliest_stop_pose) {
      const auto direction_yaw = std::atan2(
        o_pose.position.y - ego_earliest_stop_pose->position.y,
        o_pose.position.x - ego_earliest_stop_pose->position.x);
      const auto yaw_diff_at_earliest_stop_pose =
        std::abs(universe_utils::normalizeRadian(o_yaw - direction_yaw));
      const auto lat_distance_at_earliest_stop_pose =
        std::abs(universe_utils::calcLateralDeviation(o_pose, ego_earliest_stop_pose->position));
      const auto collision_at_earliest_stop_pose =
        yaw_diff_at_earliest_stop_pose > same_direction_diff_threshold &&
        lat_distance_at_earliest_stop_pose <= collision_distance_threshold;
      has_collision |= collision_at_earliest_stop_pose;
    }
    return has_collision;
  }
architecture-codes:
  - ROS Message Related Issues - Incorrect Message Member Access
  - ROS Parameter Related Issues - Use Non-existent Parameter Issues
functionality-codes:
  - Domain Library Issues - Lack of Domain Library Utilization
  - Conditional Checks Issues - Conditional Check Logic Misapplication
  - Incomplete Code - Missing Multiple Steps
  - Operation/Calculation Error - Incorrect Comparison Operation
root-cause-codes:
  - Inadequate Comprehension of Functional Logic - Inadequate Understanding of Task Logic
  - Deficiencies in Domain Knowledge - Insufficient Understanding of ROS Programming
  - Deficiencies in Domain Knowledge - Lack of Knowledge of Domain-Specific Libraries
  - Weakness in System-Level Integration - Lack of Familiarity with the Existing Codebase