compilation.log: |
  Starting >>> autoware_autonomous_emergency_braking
  [Processing: autoware_autonomous_emergency_braking]
  Finished <<< autoware_autonomous_emergency_braking [44.2s]

  Summary: 1 package finished [45.6s]
generate_code.cpp: |-
  bool AEB::hasCollision(const double current_v, const ObjectData & closest_object)
  {
      // Calculate RSS (Responsibility Sensitive Safety) distance
      double rss_distance = (current_v * current_v) / (2.0 * 4.0); // Assuming deceleration of 4.0 m/s^2

      // Update collision data keeper with the closest object information
      collision_data_keeper_.setCollisionData(closest_object);

      // Publish debug RSS distance for logging/monitoring
      if (debug_rss_distance_publisher_)
      {
          tier4_debug_msgs::msg::Float32Stamped debug_msg;
          debug_msg.stamp = rclcpp::Clock().now();
          debug_msg.data = static_cast<float>(rss_distance);
          debug_rss_distance_publisher_->publish(debug_msg);
      }

      // Check if the distance to the object is less than or equal to the RSS distance
      bool collision_detected = closest_object.distance_to_object <= rss_distance;

      return collision_detected;
  }
ground_truth.cpp: |-
  bool AEB::hasCollision(const double current_v, const ObjectData & closest_object)
  {
    autoware::universe_utils::ScopedTimeTrack st(__func__, *time_keeper_);
    const double rss_dist = std::invoke([&]() {
      const double & obj_v = closest_object.velocity;
      const double & t = t_response_;
      const double pre_braking_covered_distance = std::abs(current_v) * t;
      const double braking_distance = (current_v * current_v) / (2 * std::fabs(a_ego_min_));
      const double ego_stopping_distance = pre_braking_covered_distance + braking_distance;
      const double obj_braking_distance = (obj_v > 0.0)
                                            ? -(obj_v * obj_v) / (2 * std::fabs(a_obj_min_))
                                            : (obj_v * obj_v) / (2 * std::fabs(a_obj_min_));
      return ego_stopping_distance + obj_braking_distance + longitudinal_offset_margin_;
    });

    tier4_debug_msgs::msg::Float32Stamped rss_distance_msg;
    rss_distance_msg.stamp = get_clock()->now();
    rss_distance_msg.data = rss_dist;
    debug_rss_distance_publisher_->publish(rss_distance_msg);

    if (closest_object.distance_to_object > rss_dist) return false;

    // collision happens
    ObjectData collision_data = closest_object;
    collision_data.rss = rss_dist;
    collision_data_keeper_.setCollisionData(collision_data);
    return true;
  }
architecture-codes:
  - ROS Parameter Related Issues - Use Non-exist Parameter
  - ROS Parameter Related Issues - Insufficient Parameter Design
  - ROS Timer Issues - Timestamp Processing Errors
  - Topic/Service Related Issues - Topic Use Error
functionality-codes:
  - Incomplete Code - Missing Multiple Steps
  - Operation/Calculation Error - Incorrect Arithmetic Operation
  - Conditional Checks Issues - Conditional Check Logic Misapplication
  - Domain Library Issues - Lack of Domain Library Utilization
  - Constant Value Error
root-cause-codes:
  - Inadequate Comprehension of Functional Logic - Inadequate Understanding of Task Logic
  - Deficiencies in Domain Knowledge - Insufficient Understanding of ROS Programming
  - Deficiencies in Domain Knowledge - Lack of ROS Development Best Practices
  - Weakness in System-Level Integration - Lack of Familiarity with the Existing Codebase