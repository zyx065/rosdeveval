compilation.log: |
  Starting >>> autoware_ar_tag_based_localizer
  --- stderr: autoware_ar_tag_based_localizer
  /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_landmark_based_localizer/autoware_ar_tag_based_localizer/src/ar_tag_based_localizer.cpp: In constructor ‘ArTagBasedLocalizer::ArTagBasedLocalizer(const rclcpp::NodeOptions&)’:
  /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_landmark_based_localizer/autoware_ar_tag_based_localizer/src/ar_tag_based_localizer.cpp:80:66: error: converting to ‘const ParameterDescriptor’ {aka ‘const rcl_interfaces::msg::ParameterDescriptor_<std::allocator<void> >’} from initializer list would use explicit constructor ‘rcl_interfaces::msg::ParameterDescriptor_<ContainerAllocator>::ParameterDescriptor_(rosidl_runtime_cpp::MessageInitialization) [with ContainerAllocator = std::allocator<void>]’ [-Werror]
     80 |     target_tag_ids_ = declare_parameter<std::vector<std::string>>("target_tag_ids", {});
        |                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_landmark_based_localizer/autoware_ar_tag_based_localizer/src/ar_tag_based_localizer.cpp:80:66: note: in C++11 and above a default constructor can be explicit
  /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_landmark_based_localizer/autoware_ar_tag_based_localizer/src/ar_tag_based_localizer.cpp:96:36: error: ‘aruco::PREDEFINED_DICTIONARY_NAME’ has not been declared
     96 |     detector_.setDictionary(aruco::PREDEFINED_DICTIONARY_NAME::DICT_4X4_50);
        |                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_landmark_based_localizer/autoware_ar_tag_based_localizer/src/ar_tag_based_localizer.cpp:101:41: error: ‘onMapBin’ is not a member of ‘ArTagBasedLocalizer’
    101 |         std::bind(&ArTagBasedLocalizer::onMapBin, this, std::placeholders::_1));
        |                                         ^~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_landmark_based_localizer/autoware_ar_tag_based_localizer/src/ar_tag_based_localizer.cpp:105:41: error: ‘onImage’ is not a member of ‘ArTagBasedLocalizer’
    105 |         std::bind(&ArTagBasedLocalizer::onImage, this, std::placeholders::_1));
        |                                         ^~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_landmark_based_localizer/autoware_ar_tag_based_localizer/src/ar_tag_based_localizer.cpp:109:41: error: ‘onCameraInfo’ is not a member of ‘ArTagBasedLocalizer’
    109 |         std::bind(&ArTagBasedLocalizer::onCameraInfo, this, std::placeholders::_1));
        |                                         ^~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_landmark_based_localizer/autoware_ar_tag_based_localizer/src/ar_tag_based_localizer.cpp:113:41: error: ‘onEKFPose’ is not a member of ‘ArTagBasedLocalizer’
    113 |         std::bind(&ArTagBasedLocalizer::onEKFPose, this, std::placeholders::_1));
        |                                         ^~~~~~~~~
  In file included from /usr/include/c++/11/memory:76,
                   from /workspace/repos/autoware/install/autoware_map_msgs/include/autoware_map_msgs/autoware_map_msgs/msg/detail/lanelet_map_bin__struct.hpp:10,
                   from /workspace/repos/autoware/install/autoware_map_msgs/include/autoware_map_msgs/autoware_map_msgs/msg/lanelet_map_bin.hpp:7,
                   from /workspace/repos/autoware/install/autoware_lanelet2_extension/include/autoware_lanelet2_extension/localization/landmark.hpp:18,
                   from /workspace/repos/autoware/install/autoware_landmark_manager/include/autoware/landmark_manager/landmark_manager.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_landmark_based_localizer/autoware_ar_tag_based_localizer/src/ar_tag_based_localizer.hpp:48,
                   from /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_landmark_based_localizer/autoware_ar_tag_based_localizer/src/ar_tag_based_localizer.cpp:45:
  /usr/include/c++/11/bits/unique_ptr.h: In instantiation of ‘typename std::_MakeUniq<_Tp>::__single_object std::make_unique(_Args&& ...) [with _Tp = autoware::localization_util::SmartPoseBuffer; _Args = {double&, double&}; typename std::_MakeUniq<_Tp>::__single_object = std::unique_ptr<autoware::localization_util::SmartPoseBuffer>]’:
  /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_landmark_based_localizer/autoware_ar_tag_based_localizer/src/ar_tag_based_localizer.cpp:92:86:   required from here
  /usr/include/c++/11/bits/unique_ptr.h:962:30: error: no matching function for call to ‘autoware::localization_util::SmartPoseBuffer::SmartPoseBuffer(double&, double&)’
    962 |     { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }
        |                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  In file included from /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_landmark_based_localizer/autoware_ar_tag_based_localizer/src/ar_tag_based_localizer.hpp:49,
                   from /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_landmark_based_localizer/autoware_ar_tag_based_localizer/src/ar_tag_based_localizer.cpp:45:
  /workspace/repos/autoware/install/autoware_localization_util/include/autoware/localization_util/smart_pose_buffer.hpp:42:3: note: candidate: ‘autoware::localization_util::SmartPoseBuffer::SmartPoseBuffer(const rclcpp::Logger&, const double&, const double&)’
     42 |   SmartPoseBuffer(
        |   ^~~~~~~~~~~~~~~
  /workspace/repos/autoware/install/autoware_localization_util/include/autoware/localization_util/smart_pose_buffer.hpp:42:3: note:   candidate expects 3 arguments, 2 provided
  cc1plus: all warnings being treated as errors
  gmake[2]: *** [CMakeFiles/autoware_ar_tag_based_localizer.dir/build.make:76: CMakeFiles/autoware_ar_tag_based_localizer.dir/src/ar_tag_based_localizer.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:159: CMakeFiles/autoware_ar_tag_based_localizer.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_ar_tag_based_localizer [7.43s, exited with code 2]

  Summary: 0 packages finished [8.86s]
    1 package failed: autoware_ar_tag_based_localizer
    1 package had stderr output: autoware_ar_tag_based_localizer
generate_code.cpp: |-
  ArTagBasedLocalizer::ArTagBasedLocalizer(const rclcpp::NodeOptions & options)
  : rclcpp::Node("ar_tag_based_localizer", options), cam_info_received_(false)
  {
      // Declare and get node parameters
      marker_size_ = declare_parameter<float>("marker_size", 0.1);
      target_tag_ids_ = declare_parameter<std::vector<std::string>>("target_tag_ids", {});
      base_covariance_ = declare_parameter<std::vector<double>>("base_covariance", {0.1, 0.1, 0.1, 0.1, 0.1, 0.1});
      distance_threshold_ = declare_parameter<double>("distance_threshold", 1.0);
      consider_orientation_ = declare_parameter<bool>("consider_orientation", true);
      ekf_time_tolerance_ = declare_parameter<double>("ekf_time_tolerance", 0.1);
      ekf_position_tolerance_ = declare_parameter<double>("ekf_position_tolerance", 0.5);

      // Initialize TF buffer and listener
      tf_buffer_ = std::make_unique<tf2_ros::Buffer>(get_clock());
      tf_listener_ = std::make_unique<tf2_ros::TransformListener>(*tf_buffer_);

      // Initialize EKF pose buffer
      ekf_pose_buffer_ = std::make_unique<autoware::localization_util::SmartPoseBuffer>(
          ekf_time_tolerance_, ekf_position_tolerance_);

      // Configure ArUco marker detector
      detector_.setDictionary(aruco::PREDEFINED_DICTIONARY_NAME::DICT_4X4_50);

      // Setup ROS subscribers
      map_bin_sub_ = create_subscription<LaneletMapBin>(
          "input/lanelet_map_bin", rclcpp::QoS(1),
          std::bind(&ArTagBasedLocalizer::onMapBin, this, std::placeholders::_1));

      image_sub_ = create_subscription<Image>(
          "input/image_raw", rclcpp::QoS(1),
          std::bind(&ArTagBasedLocalizer::onImage, this, std::placeholders::_1));

      cam_info_sub_ = create_subscription<CameraInfo>(
          "input/camera_info", rclcpp::QoS(1),
          std::bind(&ArTagBasedLocalizer::onCameraInfo, this, std::placeholders::_1));

      ekf_pose_sub_ = create_subscription<PoseWithCovarianceStamped>(
          "input/ekf_pose", rclcpp::QoS(1),
          std::bind(&ArTagBasedLocalizer::onEKFPose, this, std::placeholders::_1));

      // Setup ROS publishers
      pose_pub_ = create_publisher<PoseWithCovarianceStamped>("output/pose", rclcpp::QoS(1));
      image_pub_ = create_publisher<Image>("output/debug_image", rclcpp::QoS(1));
      detected_tag_pose_pub_ = create_publisher<PoseArray>("output/detected_tag_poses", rclcpp::QoS(1));
      mapped_tag_pose_pub_ = create_publisher<MarkerArray>("output/mapped_tag_poses", rclcpp::QoS(1));
      diag_pub_ = create_publisher<DiagnosticArray>("output/diagnostics", rclcpp::QoS(1));
  }
ground_truth.cpp: |-
  ArTagBasedLocalizer::ArTagBasedLocalizer(const rclcpp::NodeOptions & options)
  : rclcpp::Node("ar_tag_based_localizer", options), cam_info_received_(false)
  {
    /*
      Declare node parameters
    */
    marker_size_ = static_cast<float>(this->declare_parameter<double>("marker_size"));
    target_tag_ids_ = this->declare_parameter<std::vector<std::string>>("target_tag_ids");
    base_covariance_ = this->declare_parameter<std::vector<double>>("base_covariance");
    distance_threshold_ = this->declare_parameter<double>("distance_threshold");
    consider_orientation_ = this->declare_parameter<bool>("consider_orientation");
    ekf_time_tolerance_ = this->declare_parameter<double>("ekf_time_tolerance");
    ekf_position_tolerance_ = this->declare_parameter<double>("ekf_position_tolerance");
    std::string detection_mode = this->declare_parameter<std::string>("detection_mode");
    float min_marker_size = static_cast<float>(this->declare_parameter<double>("min_marker_size"));
    if (detection_mode == "DM_NORMAL") {
      detector_.setDetectionMode(aruco::DM_NORMAL, min_marker_size);
    } else if (detection_mode == "DM_FAST") {
      detector_.setDetectionMode(aruco::DM_FAST, min_marker_size);
    } else if (detection_mode == "DM_VIDEO_FAST") {
      detector_.setDetectionMode(aruco::DM_VIDEO_FAST, min_marker_size);
    } else {
      // Error
      RCLCPP_ERROR_STREAM(this->get_logger(), "Invalid detection_mode: " << detection_mode);
      return;
    }
    ekf_pose_buffer_ = std::make_unique<autoware::localization_util::SmartPoseBuffer>(
      this->get_logger(), ekf_time_tolerance_, ekf_position_tolerance_);

    /*
      Log parameter info
    */
    RCLCPP_INFO_STREAM(this->get_logger(), "min_marker_size: " << min_marker_size);
    RCLCPP_INFO_STREAM(this->get_logger(), "detection_mode: " << detection_mode);
    RCLCPP_INFO_STREAM(this->get_logger(), "thresMethod: " << detector_.getParameters().thresMethod);
    RCLCPP_INFO_STREAM(this->get_logger(), "marker_size_: " << marker_size_);

    /*
      tf
    */
    tf_buffer_ = std::make_unique<tf2_ros::Buffer>(this->get_clock());
    tf_listener_ = std::make_unique<tf2_ros::TransformListener>(*tf_buffer_);

    /*
      Subscribers
    */
    using std::placeholders::_1;
    map_bin_sub_ = this->create_subscription<LaneletMapBin>(
      "~/input/lanelet2_map", rclcpp::QoS(1).durability(rclcpp::DurabilityPolicy::TransientLocal),
      std::bind(&ArTagBasedLocalizer::map_bin_callback, this, _1));

    rclcpp::QoS qos_sub(rclcpp::QoSInitialization::from_rmw(rmw_qos_profile_default));
    qos_sub.best_effort();
    image_sub_ = this->create_subscription<Image>(
      "~/input/image", qos_sub, std::bind(&ArTagBasedLocalizer::image_callback, this, _1));
    cam_info_sub_ = this->create_subscription<CameraInfo>(
      "~/input/camera_info", qos_sub, std::bind(&ArTagBasedLocalizer::cam_info_callback, this, _1));
    ekf_pose_sub_ = this->create_subscription<PoseWithCovarianceStamped>(
      "~/input/ekf_pose", qos_sub, std::bind(&ArTagBasedLocalizer::ekf_pose_callback, this, _1));

    /*
      Publishers
    */
    const rclcpp::QoS qos_pub_once = rclcpp::QoS(rclcpp::KeepLast(1)).transient_local().reliable();
    const rclcpp::QoS qos_pub_periodic(rclcpp::QoSInitialization::from_rmw(rmw_qos_profile_default));
    pose_pub_ = this->create_publisher<PoseWithCovarianceStamped>(
      "~/output/pose_with_covariance", qos_pub_periodic);
    image_pub_ = this->create_publisher<Image>("~/debug/image", qos_pub_periodic);
    mapped_tag_pose_pub_ = this->create_publisher<MarkerArray>("~/debug/mapped_tag", qos_pub_once);
    detected_tag_pose_pub_ =
      this->create_publisher<PoseArray>("~/debug/detected_tag", qos_pub_periodic);
    diag_pub_ = this->create_publisher<DiagnosticArray>("/diagnostics", qos_pub_periodic);

    RCLCPP_INFO(this->get_logger(), "Setup of ar_tag_based_localizer node is successful!");
  }
architecture-codes:
  - Topic/Service Related Issues - Topic Name Mismatch Issues
  - Topic/Service Related Issues - QoS Policy Incompatibility
  - Topic/Service Related Issues - Callback Function Binding Signature Mismatch
  - ROS Parameter Related Issues - Insufficient Parameter Design
  - ROS Logger Issues - ROS Logger Missing Issue
functionality-codes:
  - Meet Requirement - No
  - Reference Error - Undefined name (onMapBin, onImage, onCameraInfo, onEKFPose don't exist)
  - Incomplete Code - Missing Multiple Steps (detection mode configuration, logging)
root-cause-codes:
  - Weakness in System-Level Integration - Lack of familiarity with the existing codebase