compilation.log: |
  Starting >>> autoware_raw_vehicle_cmd_converter
  --- stderr: autoware_raw_vehicle_cmd_converter
  /workspace/repos/autoware/src/universe/autoware.universe/vehicle/autoware_raw_vehicle_cmd_converter/src/brake_map.cpp: In member function ‘bool autoware::raw_vehicle_cmd_converter::BrakeMap::getBrake(double, double, double&)’:
  /workspace/repos/autoware/src/universe/autoware.universe/vehicle/autoware_raw_vehicle_cmd_converter/src/brake_map.cpp:50:53: error: ‘vel_ranges_’ was not declared in this scope
     50 |     double clamped_vel = CSVLoader::clampValue(vel, vel_ranges_);
        |                                                     ^~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/vehicle/autoware_raw_vehicle_cmd_converter/src/brake_map.cpp:51:53: error: ‘acc_ranges_’ was not declared in this scope
     51 |     double clamped_acc = CSVLoader::clampValue(acc, acc_ranges_);
        |                                                     ^~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/vehicle/autoware_raw_vehicle_cmd_converter/src/brake_map.cpp:54:59: error: ‘brake_map_table_’ was not declared in this scope; did you mean ‘brake_map_’?
     54 |     std::vector<double> row_keys = CSVLoader::getRowIndex(brake_map_table_);
        |                                                           ^~~~~~~~~~~~~~~~
        |                                                           brake_map_
  gmake[2]: *** [CMakeFiles/actuation_map_converter.dir/build.make:90: CMakeFiles/actuation_map_converter.dir/src/brake_map.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:163: CMakeFiles/actuation_map_converter.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_raw_vehicle_cmd_converter [2.61s, exited with code 2]

  Summary: 0 packages finished [3.98s]
    1 package failed: autoware_raw_vehicle_cmd_converter
    1 package had stderr output: autoware_raw_vehicle_cmd_converter
generate_code.cpp: |
  bool BrakeMap::getBrake(const double acc, const double vel, double & brake)
  {
      // Clamp velocity and acceleration to the map's valid ranges
      double clamped_vel = CSVLoader::clampValue(vel, vel_ranges_);
      double clamped_acc = CSVLoader::clampValue(acc, acc_ranges_);

      // Perform 2D interpolation using the brake map
      std::vector<double> row_keys = CSVLoader::getRowIndex(brake_map_table_);
      std::vector<double> col_keys = CSVLoader::getColumnIndex(brake_map_table_);

      // First, interpolate along velocity (rows)
      std::vector<double> interpolated_row_values;
      for (size_t col = 0; col < col_keys.size(); ++col) {
          std::vector<double> column_values;
          for (const auto& row : brake_map_table_) {
              column_values.push_back(row[col]);
          }
          
          double interpolated_value = autoware::interpolation::lerp(
              row_keys, column_values, clamped_vel);
          interpolated_row_values.push_back(interpolated_value);
      }

      // Then, interpolate along acceleration (columns)
      brake = autoware::interpolation::lerp(
          col_keys, interpolated_row_values, clamped_acc);

      return true;
  }
ground_truth.cpp: |-
  bool BrakeMap::getBrake(const double acc, const double vel, double & brake)
  {
    std::vector<double> interpolated_acc_vec;
    const double clamped_vel = CSVLoader::clampValue(vel, vel_index_, "brake: vel");

    // (throttle, vel, acc) map => (throttle, acc) map by fixing vel
    interpolated_acc_vec.reserve(brake_map_.size());
    for (const std::vector<double> & accelerations : brake_map_) {
      interpolated_acc_vec.push_back(
        autoware::interpolation::lerp(vel_index_, accelerations, clamped_vel));
    }

    // calculate brake
    // When the desired acceleration is smaller than the brake area, return max brake on the map
    // When the desired acceleration is greater than the brake area, return min brake on the map
    if (acc < interpolated_acc_vec.back()) {
      RCLCPP_WARN_SKIPFIRST_THROTTLE(
        logger_, clock_, 1000,
        "Exceeding the acc range. Desired acc: %f < min acc on map: %f. return max "
        "value.",
        acc, interpolated_acc_vec.back());
      brake = brake_index_.back();
      return true;
    }
    if (interpolated_acc_vec.front() < acc) {
      brake = brake_index_.front();
      return true;
    }

    std::reverse(std::begin(interpolated_acc_vec), std::end(interpolated_acc_vec));
    brake = autoware::interpolation::lerp(interpolated_acc_vec, brake_index_rev_, acc);

    return true;
  }
Architecture-codes:
  - ROS Logger Issues - ROS Logger Missing Issue
functionality-codes:
  - Reference Error - Wrong Variable
  - Reference Error - Wrong Method
  - Incomplete Code - Missing Multiple Steps
  - Conditional Checks Issues - Conditional Check Missing
  - Operation/Calculation Error - Incorrect arithmetic operation
root-cause-codes:
  - Inadequate Comprehension of Functional Logic - Inadequate Understanding of Task Logic
  - Deficiencies in Domain Knowledge - Lack of ROS development best practices
  - Weakness in System-Level Integration - Lack of familiarity with the existing codebase