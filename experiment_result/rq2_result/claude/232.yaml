compilation.log: |
  Starting >>> autoware_autonomous_emergency_braking
  --- stderr: autoware_autonomous_emergency_braking
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_autonomous_emergency_braking/src/node.cpp: In constructor ‘autoware::motion::control::autonomous_emergency_braking::AEB::AEB(const rclcpp::NodeOptions&)’:
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_autonomous_emergency_braking/src/node.cpp:194:25: error: ‘onSetParameters’ is not a member of ‘autoware::motion::control::autonomous_emergency_braking::AEB’
    194 |         std::bind(&AEB::onSetParameters, this, std::placeholders::_1)
        |                         ^~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_autonomous_emergency_braking/src/node.cpp:204:5: error: ‘setupDiagnostics’ was not declared in this scope
    204 |     setupDiagnostics();
        |     ^~~~~~~~~~~~~~~~
  gmake[2]: *** [CMakeFiles/autoware_autonomous_emergency_braking_node.dir/build.make:76: CMakeFiles/autoware_autonomous_emergency_braking_node.dir/src/node.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:187: CMakeFiles/autoware_autonomous_emergency_braking_node.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_autonomous_emergency_braking [18.3s, exited with code 2]

  Summary: 0 packages finished [19.8s]
    1 package failed: autoware_autonomous_emergency_braking
    1 package had stderr output: autoware_autonomous_emergency_braking
generate_code.cpp: |-
  AEB::AEB(const rclcpp::NodeOptions & node_options)
  : Node("AEB", node_options),
    vehicle_info_(autoware::vehicle_info_utils::VehicleInfoUtils(*this).getVehicleInfo()),
    collision_data_keeper_(this->get_clock())
  {
      // Parameter declarations and initializations
      declare_parameter<bool>("publish_debug_pointcloud", false);
      declare_parameter<bool>("publish_debug_markers", false);
      declare_parameter<bool>("use_predicted_trajectory", true);
      declare_parameter<bool>("use_imu_path", true);
      declare_parameter<bool>("limit_imu_path_lat_dev", true);
      declare_parameter<bool>("limit_imu_path_length", true);
      declare_parameter<bool>("use_pointcloud_data", true);
      declare_parameter<bool>("use_predicted_object_data", true);
      declare_parameter<bool>("use_object_velocity_calculation", true);
      declare_parameter<bool>("check_autoware_state", true);

      // Get parameter values
      publish_debug_pointcloud_ = get_parameter("publish_debug_pointcloud").as_bool();
      publish_debug_markers_ = get_parameter("publish_debug_markers").as_bool();
      use_predicted_trajectory_ = get_parameter("use_predicted_trajectory").as_bool();
      use_imu_path_ = get_parameter("use_imu_path").as_bool();
      limit_imu_path_lat_dev_ = get_parameter("limit_imu_path_lat_dev").as_bool();
      limit_imu_path_length_ = get_parameter("limit_imu_path_length").as_bool();
      use_pointcloud_data_ = get_parameter("use_pointcloud_data").as_bool();
      use_predicted_object_data_ = get_parameter("use_predicted_object_data").as_bool();
      use_object_velocity_calculation_ = get_parameter("use_object_velocity_calculation").as_bool();
      check_autoware_state_ = get_parameter("check_autoware_state").as_bool();

      // Publisher initializations
      pub_obstacle_pointcloud_ = create_publisher<sensor_msgs::msg::PointCloud2>(
          "~/output/obstacle_pointcloud", rclcpp::QoS(1)
      );
      debug_marker_publisher_ = create_publisher<MarkerArray>(
          "~/debug/markers", rclcpp::QoS(1)
      );
      virtual_wall_publisher_ = create_publisher<MarkerArray>(
          "~/output/virtual_wall", rclcpp::QoS(1)
      );
      debug_rss_distance_publisher_ = create_publisher<tier4_debug_msgs::msg::Float32Stamped>(
          "~/debug/rss_distance", rclcpp::QoS(1)
      );
      metrics_pub_ = create_publisher<MetricArray>(
          "~/metrics", rclcpp::QoS(1)
      );

      // Setup parameter callback
      set_param_res_ = add_on_set_parameters_callback(
          std::bind(&AEB::onSetParameters, this, std::placeholders::_1)
      );

      // Initialize timer for periodic execution
      timer_ = create_wall_timer(
          std::chrono::milliseconds(100),
          std::bind(&AEB::onTimer, this)
      );

      // Diagnostics setup
      setupDiagnostics();
  }
ground_truth.cpp: |-
  AEB::AEB(const rclcpp::NodeOptions & node_options)
  : Node("AEB", node_options),
    vehicle_info_(autoware::vehicle_info_utils::VehicleInfoUtils(*this).getVehicleInfo()),
    collision_data_keeper_(this->get_clock())
  {
    // Publisher
    {
      pub_obstacle_pointcloud_ =
        this->create_publisher<sensor_msgs::msg::PointCloud2>("~/debug/obstacle_pointcloud", 1);
      debug_marker_publisher_ = this->create_publisher<MarkerArray>("~/debug/markers", 1);
      virtual_wall_publisher_ = this->create_publisher<MarkerArray>("~/virtual_wall", 1);
      debug_rss_distance_publisher_ =
        this->create_publisher<tier4_debug_msgs::msg::Float32Stamped>("~/debug/rss_distance", 1);
      metrics_pub_ = this->create_publisher<MetricArray>("~/metrics", 1);
    }
    // Diagnostics
    {
      updater_.setHardwareID("autonomous_emergency_braking");
      updater_.add("aeb_emergency_stop", this, &AEB::onCheckCollision);
    }
    // parameter
    publish_debug_pointcloud_ = declare_parameter<bool>("publish_debug_pointcloud");
    publish_debug_markers_ = declare_parameter<bool>("publish_debug_markers");
    use_predicted_trajectory_ = declare_parameter<bool>("use_predicted_trajectory");
    use_imu_path_ = declare_parameter<bool>("use_imu_path");
    limit_imu_path_lat_dev_ = declare_parameter<bool>("limit_imu_path_lat_dev");
    limit_imu_path_length_ = declare_parameter<bool>("limit_imu_path_length");
    use_pointcloud_data_ = declare_parameter<bool>("use_pointcloud_data");
    use_predicted_object_data_ = declare_parameter<bool>("use_predicted_object_data");
    use_object_velocity_calculation_ = declare_parameter<bool>("use_object_velocity_calculation");
    check_autoware_state_ = declare_parameter<bool>("check_autoware_state");
    path_footprint_extra_margin_ = declare_parameter<double>("path_footprint_extra_margin");
    imu_path_lat_dev_threshold_ = declare_parameter<double>("imu_path_lat_dev_threshold");
    speed_calculation_expansion_margin_ =
      declare_parameter<double>("speed_calculation_expansion_margin");
    detection_range_min_height_ = declare_parameter<double>("detection_range_min_height");
    detection_range_max_height_margin_ =
      declare_parameter<double>("detection_range_max_height_margin");
    voxel_grid_x_ = declare_parameter<double>("voxel_grid_x");
    voxel_grid_y_ = declare_parameter<double>("voxel_grid_y");
    voxel_grid_z_ = declare_parameter<double>("voxel_grid_z");
    min_generated_imu_path_length_ = declare_parameter<double>("min_generated_imu_path_length");
    max_generated_imu_path_length_ = declare_parameter<double>("max_generated_imu_path_length");
    expand_width_ = declare_parameter<double>("expand_width");
    longitudinal_offset_margin_ = declare_parameter<double>("longitudinal_offset_margin");
    t_response_ = declare_parameter<double>("t_response");
    a_ego_min_ = declare_parameter<double>("a_ego_min");
    a_obj_min_ = declare_parameter<double>("a_obj_min");

    cluster_tolerance_ = declare_parameter<double>("cluster_tolerance");
    cluster_minimum_height_ = declare_parameter<double>("cluster_minimum_height");
    minimum_cluster_size_ = declare_parameter<int>("minimum_cluster_size");
    maximum_cluster_size_ = declare_parameter<int>("maximum_cluster_size");

    imu_prediction_time_horizon_ = declare_parameter<double>("imu_prediction_time_horizon");
    imu_prediction_time_interval_ = declare_parameter<double>("imu_prediction_time_interval");
    mpc_prediction_time_horizon_ = declare_parameter<double>("mpc_prediction_time_horizon");
    mpc_prediction_time_interval_ = declare_parameter<double>("mpc_prediction_time_interval");

    {  // Object history data keeper setup
      const auto previous_obstacle_keep_time =
        declare_parameter<double>("previous_obstacle_keep_time");
      const auto collision_keeping_sec = declare_parameter<double>("collision_keeping_sec");
      collision_data_keeper_.setTimeout(collision_keeping_sec, previous_obstacle_keep_time);
    }

    // Parameter Callback
    set_param_res_ =
      add_on_set_parameters_callback(std::bind(&AEB::onParameter, this, std::placeholders::_1));

    // start time
    const double aeb_hz = declare_parameter<double>("aeb_hz");
    const auto period_ns = rclcpp::Rate(aeb_hz).period();
    timer_ = rclcpp::create_timer(this, this->get_clock(), period_ns, std::bind(&AEB::onTimer, this));

    debug_processing_time_detail_pub_ =
      create_publisher<autoware::universe_utils::ProcessingTimeDetail>(
        "~/debug/processing_time_detail_ms", 1);
    time_keeper_ =
      std::make_shared<autoware::universe_utils::TimeKeeper>(debug_processing_time_detail_pub_);
  }
architecture-codes:
- Topic/Service Related Issues - Topic Name Mismatch
- ROS Parameter Related Issues - Insufficient Parameter Design
- ROS Timer Issues
- ROS Diagnostic Issues
functionality-codes:
  - Reference Error - Wrong method
  - Reference Error - Undefined name
  - Incomplete Code - Missing Multiple Steps
  - Constant Value Error
Root Cause Analysis:
  - Inadequate Comprehension of Functional Logic - Inadequate Understanding of System Requirements
  - Inadequate Comprehension of Functional Logic - Lack of ROS development best practices
  - Weakness in System-Level Integration - Lack of familiarity with the existing codebase