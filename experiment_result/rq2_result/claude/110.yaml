compilation.log: |
  Starting >>> autoware_surround_obstacle_checker
  --- stderr: autoware_surround_obstacle_checker
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_surround_obstacle_checker/src/node.cpp: In member function ‘std::pair<bool, std::optional<rclcpp::Time> > autoware::surround_obstacle_checker::SurroundObstacleCheckerNode::isStopRequired(bool, bool, const autoware::surround_obstacle_checker::State&, const std::optional<rclcpp::Time>&, double) const’:
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_surround_obstacle_checker/src/node.cpp:381:44: error: unused parameter ‘is_vehicle_stopped’ [-Werror=unused-parameter]
    381 |   const bool is_obstacle_found, const bool is_vehicle_stopped, const State & state,
        |                                 ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_surround_obstacle_checker/src/node.cpp:381:78: error: unused parameter ‘state’ [-Werror=unused-parameter]
    381 |   const bool is_obstacle_found, const bool is_vehicle_stopped, const State & state,
        |                                                                ~~~~~~~~~~~~~~^~~~~
  In file included from /workspace/repos/autoware/build/autoware_surround_obstacle_checker/surround_obstacle_checker_node_parameters/include/surround_obstacle_checker_node_parameters.hpp:23,
                   from /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_surround_obstacle_checker/src/node.hpp:21,
                   from /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_surround_obstacle_checker/src/node.cpp:15:
  /opt/ros/humble/include/parameter_traits/parameter_traits/parameter_traits.hpp: In function ‘void __static_initialization_and_destruction_0(int, int)’:
  /opt/ros/humble/include/parameter_traits/parameter_traits/parameter_traits.hpp:51:13: warning: ‘parameter_traits::OK’ is deprecated: When returning tl::expected<void, std::string> default construct for OK with `{}`. [-Wdeprecated-declarations]
     51 | auto static OK
        |             ^~
  /opt/ros/humble/include/parameter_traits/parameter_traits/parameter_traits.hpp:51:13: note: declared here
  cc1plus: all warnings being treated as errors
  gmake[2]: *** [CMakeFiles/autoware_surround_obstacle_checker.dir/build.make:90: CMakeFiles/autoware_surround_obstacle_checker.dir/src/node.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:187: CMakeFiles/autoware_surround_obstacle_checker.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_surround_obstacle_checker [22.6s, exited with code 2]

  Summary: 0 packages finished [24.0s]
    1 package failed: autoware_surround_obstacle_checker
    1 package had stderr output: autoware_surround_obstacle_checker
generate_code.cpp: |-
  auto SurroundObstacleCheckerNode::isStopRequired(
    const bool is_obstacle_found, const bool is_vehicle_stopped, const State & state,
    const std::optional<rclcpp::Time> & last_obstacle_found_time, const double time_threshold) const
    -> std::pair<bool, std::optional<rclcpp::Time>>
  {
      // If an obstacle is currently found, reset/set the obstacle first detection time
      if (is_obstacle_found) {
          return {true, rclcpp::Clock().now()};
      }

      // If no obstacle is found, check if we need to maintain stop based on previous detection
      if (last_obstacle_found_time.has_value()) {
          // Calculate time since last obstacle was detected
          auto current_time = rclcpp::Clock().now();
          auto time_since_last_obstacle = current_time - last_obstacle_found_time.value();

          // If time since last obstacle is within threshold, continue stopping
          if (time_since_last_obstacle.seconds() < time_threshold) {
              return {true, last_obstacle_found_time};
          }
      }

      // No need to stop if no recent obstacle detection
      return {false, std::nullopt};
  }
ground_truth.cpp: |-
  auto SurroundObstacleCheckerNode::isStopRequired(
    const bool is_obstacle_found, const bool is_vehicle_stopped, const State & state,
    const std::optional<rclcpp::Time> & last_obstacle_found_time, const double time_threshold) const
    -> std::pair<bool, std::optional<rclcpp::Time>>
  {
    if (!is_vehicle_stopped) {
      return std::make_pair(false, std::nullopt);
    }

    if (is_obstacle_found) {
      return std::make_pair(true, this->now());
    }

    if (state != State::STOP) {
      return std::make_pair(false, std::nullopt);
    }

    // Keep stop state
    if (last_obstacle_found_time.has_value()) {
      const auto elapsed_time = this->now() - last_obstacle_found_time.value();
      if (elapsed_time.seconds() <= time_threshold) {
        return std::make_pair(true, last_obstacle_found_time.value());
      }
    }

    return std::make_pair(false, std::nullopt);
  }
architecture-codes:
  - ROS Timer Issues - Timestamp Processing Errors
functionality-codes:
  - Conditional Checks Issues - Conditional Check Missing
  - Incomplete Code - Missing Multiple Steps
  - Reference Error - Wrong Method
  - Conditional Checks Issues - Conditional Check Logic Misapplication
root-cause-codes:
  - Inadequate Comprehension of Functional Logic - Inadequate Understanding of Task Logic
  - Deficiencies in Domain Knowledge - Insufficient Understanding of ROS Programming
  - Deficiencies in Domain Knowledge - Lack of ROS Development Best Practices
  - Inadequate Comprehension of Functional Logic - Inadequate Understanding of System Requirements