compilation.log: |
  Starting >>> autoware_pid_longitudinal_controller
  Finished <<< autoware_pid_longitudinal_controller [12.8s]

  Summary: 1 package finished [14.2s]
generate_code.cpp: |
  RTCInterface::RTCInterface(rclcpp::Node * node, const std::string & name, const bool enable_rtc)
  : clock_{node->get_clock()},
    logger_{node->get_logger().get_child("RTCInterface[" + name + "]")},
    is_auto_mode_enabled_{!enable_rtc},
    is_locked_{false}
  {
      // Create a callback group for thread-safe operations
      callback_group_ = node->create_callback_group(
          rclcpp::CallbackGroupType::MutuallyExclusive
      );

      // Create timer for periodic status updates
      timer_ = node->create_wall_timer(
          std::chrono::milliseconds(100),
          std::bind(&RTCInterface::onTimer, this),
          callback_group_
      );

      // Create publishers for status messages
      pub_statuses_ = node->create_publisher<CooperateStatusArray>(
          "rtc_statuses", 
          rclcpp::QoS(10)
      );

      pub_auto_mode_status_ = node->create_publisher<AutoModeStatus>(
          "auto_mode_status", 
          rclcpp::QoS(10)
      );

      // Create services for commands and auto mode
      srv_commands_ = node->create_service<CooperateCommands>(
          "rtc_commands",
          std::bind(&RTCInterface::handleCommands, this, 
                    std::placeholders::_1, 
                    std::placeholders::_2),
          rmw_qos_profile_services_default,
          callback_group_
      );

      srv_auto_mode_ = node->create_service<AutoMode>(
          "set_auto_mode",
          std::bind(&RTCInterface::handleAutoMode, this, 
                    std::placeholders::_1, 
                    std::placeholders::_2),
          rmw_qos_profile_services_default,
          callback_group_
      );

      // Initialize module
      module_ = Module();
  }
ground_truth.cpp: |-
  double getPitchByTraj(
    const Trajectory & trajectory, const size_t start_idx, const double wheel_base)
  {
    // cannot calculate pitch
    if (trajectory.points.size() <= 1) {
      return 0.0;
    }

    const auto [prev_idx, next_idx] = [&]() {
      for (size_t i = start_idx + 1; i < trajectory.points.size(); ++i) {
        const double dist = autoware::universe_utils::calcDistance3d(
          trajectory.points.at(start_idx), trajectory.points.at(i));
        if (dist > wheel_base) {
          // calculate pitch from trajectory between rear wheel (nearest) and front center (i)
          return std::make_pair(start_idx, i);
        }
      }
      // NOTE: The ego pose is close to the goal.
      return std::make_pair(
        std::min(start_idx, trajectory.points.size() - 2), trajectory.points.size() - 1);
    }();

    return autoware::universe_utils::calcElevationAngle(
      trajectory.points.at(prev_idx).pose.position, trajectory.points.at(next_idx).pose.position);
  }
architecture-codes:
  - Topic/Service Related Issues - Topic Not Use
  - Topic/Service Related Issues - Topic Name Mismatch
  - ROS Parameter Related Issues - Insufficient Parameter Design
  - ROS Message Related Issues - Improper Message Type Usage Issue
  - ROS Timer Issues - Timer Not Needed
functionality-codes:
  -  Reference Error - Wrong method
  -  Reference Error - Undefined Name
  -  Garbage Code - Meaningless code snippet
  - Garbage Code - Wrong logical
  - Incomplete Code - Missing Multiple Steps
  - Conditional Checks Issues - Conditional Check Missing
root-cause-codes:
  - Inadequate Comprehension of Functional Logic - Inadequate Understanding of Task Logic
  - Inadequate Comprehension of Functional Logic - Inadequate Understanding of System Requirements
  - Deficiencies in Domain Knowledge - Insufficient understanding of ROS Programming
  - Deficiencies in Domain Knowledge - Lack of ROS development best practices
  - Weakness in System-Level Integration - Unclear of ROS computation graph
  - Weakness in System-Level Integration - Lack of familiarity with the existing codebase