compilation.log: |
  Starting >>> moveit_core
  --- stderr: moveit_core
  /root/repos/moveit_ws/src/moveit2/moveit_core/collision_detection/src/world.cpp: In member function ‘bool collision_detection::World::moveShapeInObject(const string&, const ShapeConstPtr&, const Isometry3d&)’:
  /root/repos/moveit_ws/src/moveit2/moveit_core/collision_detection/src/world.cpp:252:25: error: ‘MOVE_SHAPE’ is not a member of ‘collision_detection::World::Action’
    252 |     notify(obj, Action::MOVE_SHAPE);
        |                         ^~~~~~~~~~
  gmake[2]: *** [collision_detection/CMakeFiles/moveit_collision_detection.dir/build.make:149: collision_detection/CMakeFiles/moveit_collision_detection.dir/src/world.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:2189: collision_detection/CMakeFiles/moveit_collision_detection.dir/all] Error 2
  gmake: *** [Makefile:149: all] Error 2
  ---
  Failed   <<< moveit_core [2.49s, exited with code 2]

  Summary: 0 packages finished [2.96s]
    1 package failed: moveit_core
    1 package had stderr output: moveit_core
generate_code.cpp: |
  bool World::moveShapeInObject(const std::string& object_id, const shapes::ShapeConstPtr& shape,
                                const Eigen::Isometry3d& shape_pose)
  {
    auto it = objects_.find(object_id);
    if (it == objects_.end())
    {
      return false;
    }

    ObjectPtr& obj = it->second;
    bool found = false;

    // Search for the shape in the object
    for (size_t i = 0; i < obj->shapes_.size(); ++i)
    {
      if (obj->shapes_[i].get() == shape.get())
      {
        // Update the shape's pose
        obj->shape_poses_[i] = shape_pose;
        found = true;
        break;
      }
    }

    if (found)
    {
      // Notify observers about the object modification
      notify(obj, Action::MOVE_SHAPE);
      return true;
    }
    
    return false;
  }
ground_truth.cpp: |-
  bool World::moveShapeInObject(const std::string& object_id, const shapes::ShapeConstPtr& shape,
                                const Eigen::Isometry3d& shape_pose)
  {
    const auto it = objects_.find(object_id);
    if (it != objects_.end())
    {
      const unsigned int n = it->second->shapes_.size();
      for (unsigned int i = 0; i < n; ++i)
        if (it->second->shapes_[i] == shape)
        {
          ensureUnique(it->second);
          ASSERT_ISOMETRY(shape_pose)  // unsanitized input, could contain a non-isometry
          it->second->shape_poses_[i] = shape_pose;
          it->second->global_shape_poses_[i] = it->second->pose_ * shape_pose;

          notify(it->second, MOVE_SHAPE);
          return true;
        }
    }
    return false;
  }
architecture-codes:     
  - ROS Message Related Issues - Message Operation Issues
functionality-codes:
  - Reference Error - Wrong method
  - Incomplete Code - Missing Multiple Steps
  - Conditional Checks Issues - Conditional Check Logic Misapplication
Root Cause Analysis:
  - Inadequate Comprehension of Functional Logic - Inadequate Understanding of Task logic
  - Deficiencies in Domain Knowledge - Lack of familiarity with the existing codebase
  - Deficiencies in Domain Knowledge - Lack of ROS development best practices