compilation.log: |
  Starting >>> autoware_universe_utils
  Finished <<< autoware_universe_utils [10.3s]

  Summary: 1 package finished [11.7s]
generate_code.cpp: |
  geometry_msgs::msg::Polygon rotatePolygon(
    const geometry_msgs::msg::Polygon & polygon, const double & angle)
  {
    geometry_msgs::msg::Polygon rotated_polygon;
    
    // Create rotation matrix
    double cos_theta = std::cos(angle);
    double sin_theta = std::sin(angle);
    
    // Rotate each point of the polygon
    for (const auto & point : polygon.points) {
      geometry_msgs::msg::Point32 rotated_point;
      
      // Apply rotation matrix: [cos(θ) -sin(θ); sin(θ) cos(θ)]
      rotated_point.x = point.x * cos_theta - point.y * sin_theta;
      rotated_point.y = point.x * sin_theta + point.y * cos_theta;
      rotated_point.z = point.z;  // Z-coordinate remains unchanged
      
      rotated_polygon.points.push_back(rotated_point);
    }
    
    return rotated_polygon;
  }
ground_truth.cpp: |-
  geometry_msgs::msg::Polygon rotatePolygon(
    const geometry_msgs::msg::Polygon & polygon, const double & angle)
  {
    const double cos = std::cos(angle);
    const double sin = std::sin(angle);
    geometry_msgs::msg::Polygon rotated_polygon;
    for (const auto & point : polygon.points) {
      auto rotated_point = point;
      rotated_point.x = cos * point.x - sin * point.y;
      rotated_point.y = sin * point.x + cos * point.y;
      rotated_polygon.points.push_back(rotated_point);
    }
    return rotated_polygon;
  }
architecture-codes: []
functionality-codes:
  - Minor inefficiency
root-cause-codes:
  - Weakness in System-Level Integration - Lack of familiarity with the existing codebase
