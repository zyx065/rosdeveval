compilation.log: |
  Starting >>> moveit_core
  --- stderr: moveit_core
  /root/repos/moveit_ws/src/moveit2/moveit_core/robot_state/src/robot_state.cpp: In member function ‘void moveit::core::RobotState::computeAABB(std::vector<double, std::allocator<double> >&) const’:
  /root/repos/moveit_ws/src/moveit2/moveit_core/robot_state/src/robot_state.cpp:2117:37: error: ‘const class shapes::Mesh’ has no member named ‘bounding_box’
   2117 |         box = Eigen::Vector3d(mesh->bounding_box.extents[0] / 2.0,
        |                                     ^~~~~~~~~~~~
  /root/repos/moveit_ws/src/moveit2/moveit_core/robot_state/src/robot_state.cpp:2118:36: error: ‘const class shapes::Mesh’ has no member named ‘bounding_box’
   2118 |                              mesh->bounding_box.extents[1] / 2.0,
        |                                    ^~~~~~~~~~~~
  /root/repos/moveit_ws/src/moveit2/moveit_core/robot_state/src/robot_state.cpp:2119:36: error: ‘const class shapes::Mesh’ has no member named ‘bounding_box’
   2119 |                              mesh->bounding_box.extents[2] / 2.0);
        |                                    ^~~~~~~~~~~~
  /root/repos/moveit_ws/src/moveit2/moveit_core/robot_state/src/robot_state.cpp:2124:42: error: no matching function for call to ‘computeShapeExtents(const shapes::ShapeType&)’
   2124 |         box = shapes::computeShapeExtents(shapes[i]->type);
        |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~
  In file included from /root/repos/moveit_ws/src/moveit2/moveit_core/robot_state/src/robot_state.cpp:39:
  /opt/ros/humble/include/geometric_shapes/geometric_shapes/shape_operations.h:62:17: note: candidate: ‘Eigen::Vector3d shapes::computeShapeExtents(const ShapeMsg&)’
     62 | Eigen::Vector3d computeShapeExtents(const ShapeMsg& shape_msg);
        |                 ^~~~~~~~~~~~~~~~~~~
  /opt/ros/humble/include/geometric_shapes/geometric_shapes/shape_operations.h:62:53: note:   no known conversion for argument 1 from ‘const shapes::ShapeType’ to ‘const ShapeMsg&’ {aka ‘const boost::variant<shape_msgs::msg::SolidPrimitive_<std::allocator<void> >, shape_msgs::msg::Mesh_<std::allocator<void> >, shape_msgs::msg::Plane_<std::allocator<void> > >&’}
     62 | Eigen::Vector3d computeShapeExtents(const ShapeMsg& shape_msg);
        |                                     ~~~~~~~~~~~~~~~~^~~~~~~~~
  /opt/ros/humble/include/geometric_shapes/geometric_shapes/shape_operations.h:65:17: note: candidate: ‘Eigen::Vector3d shapes::computeShapeExtents(const shapes::Shape*)’
     65 | Eigen::Vector3d computeShapeExtents(const Shape* shape);
        |                 ^~~~~~~~~~~~~~~~~~~
  /opt/ros/humble/include/geometric_shapes/geometric_shapes/shape_operations.h:65:50: note:   no known conversion for argument 1 from ‘const shapes::ShapeType’ to ‘const shapes::Shape*’
     65 | Eigen::Vector3d computeShapeExtents(const Shape* shape);
        |                                     ~~~~~~~~~~~~~^~~~~
  gmake[2]: *** [robot_state/CMakeFiles/moveit_robot_state.dir/build.make:107: robot_state/CMakeFiles/moveit_robot_state.dir/src/robot_state.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:1656: robot_state/CMakeFiles/moveit_robot_state.dir/all] Error 2
  gmake: *** [Makefile:149: all] Error 2
  ---
  Failed   <<< moveit_core [8.85s, exited with code 2]

  Summary: 0 packages finished [9.31s]
    1 package failed: moveit_core
    1 package had stderr output: moveit_core
generate_code.cpp: |
  void RobotState::computeAABB(std::vector<double>& aabb) const
  {
    if (!robot_model_)
    {
      aabb.resize(6, 0.0);
      return;
    }

    // Initialize AABB to max/min values
    aabb.resize(6);
    aabb[0] = aabb[2] = aabb[4] = std::numeric_limits<double>::max();    // min x, y, z
    aabb[1] = aabb[3] = aabb[5] = -std::numeric_limits<double>::max();   // max x, y, z

    bool has_geometry = false;

    // Process all links with collision geometry
    const std::vector<const LinkModel*>& links = robot_model_->getLinkModelsWithCollisionGeometry();
    for (const LinkModel* link : links)
    {
      const Eigen::Isometry3d& transform = getGlobalLinkTransform(link);
      
      // Get the shape extents and centered bounding box offset
      const Eigen::Vector3d& extents = link->getShapeExtentsAtOrigin();
      const Eigen::Vector3d& centered_offset = link->getCenteredBoundingBoxOffset();
      
      // Create a box representing the link's bounding volume
      Eigen::Vector3d box = extents / 2.0;
      
      // Update the AABB with this link's transformed bounding box
      Eigen::Vector3d min_corner = transform * (centered_offset - box);
      Eigen::Vector3d max_corner = transform * (centered_offset + box);
      
      // Update the global AABB
      for (int i = 0; i < 3; ++i)
      {
        if (min_corner[i] < aabb[i * 2])
          aabb[i * 2] = min_corner[i];
        if (max_corner[i] > aabb[i * 2 + 1])
          aabb[i * 2 + 1] = max_corner[i];
      }
      
      has_geometry = true;
    }

    // Process all attached bodies
    for (const auto& attached_body_pair : attached_body_map_)
    {
      const AttachedBody& attached_body = *attached_body_pair.second;
      const EigenSTL::vector_Isometry3d& transforms = attached_body.getGlobalCollisionBodyTransforms();
      const std::vector<shapes::ShapeConstPtr>& shapes = attached_body.getShapes();
      
      for (std::size_t i = 0; i < transforms.size(); ++i)
      {
        // Get the shape extents
        Eigen::Vector3d box;
        if (shapes[i]->type == shapes::MESH)
        {
          // For meshes, we need to compute the extents
          const shapes::Mesh* mesh = static_cast<const shapes::Mesh*>(shapes[i].get());
          box = Eigen::Vector3d(mesh->bounding_box.extents[0] / 2.0,
                              mesh->bounding_box.extents[1] / 2.0,
                              mesh->bounding_box.extents[2] / 2.0);
        }
        else
        {
          // For primitive shapes, we can directly use their dimensions
          box = shapes::computeShapeExtents(shapes[i]->type);
        }
        
        // Update the AABB with this attached body's transformed bounding box
        Eigen::Vector3d min_corner = transforms[i] * (-box);
        Eigen::Vector3d max_corner = transforms[i] * box;
        
        // Update the global AABB
        for (int j = 0; j < 3; ++j)
        {
          if (min_corner[j] < aabb[j * 2])
            aabb[j * 2] = min_corner[j];
          if (max_corner[j] > aabb[j * 2 + 1])
            aabb[j * 2 + 1] = max_corner[j];
        }
        
        has_geometry = true;
      }
    }

    // If no geometry was found, set AABB to zeros
    if (!has_geometry)
    {
      aabb[0] = aabb[1] = aabb[2] = aabb[3] = aabb[4] = aabb[5] = 0.0;
    }
  }
ground_truth.cpp: |-
  void RobotState::computeAABB(std::vector<double>& aabb) const
  {
    assert(checkLinkTransforms());

    core::AABB bounding_box;
    std::vector<const LinkModel*> links = robot_model_->getLinkModelsWithCollisionGeometry();
    for (const LinkModel* link : links)
    {
      Eigen::Isometry3d transform = getGlobalLinkTransform(link);  // intentional copy, we will translate
      const Eigen::Vector3d& extents = link->getShapeExtentsAtOrigin();
      transform.translate(link->getCenteredBoundingBoxOffset());
      bounding_box.extendWithTransformedBox(transform, extents);
    }
    for (const auto& it : attached_body_map_)
    {
      const EigenSTL::vector_Isometry3d& transforms = it.second->getGlobalCollisionBodyTransforms();
      const std::vector<shapes::ShapeConstPtr>& shapes = it.second->getShapes();
      for (std::size_t i = 0; i < transforms.size(); ++i)
      {
        Eigen::Vector3d extents = shapes::computeShapeExtents(shapes[i].get());
        bounding_box.extendWithTransformedBox(transforms[i], extents);
      }
    }

    aabb.clear();
    aabb.resize(6, 0.0);
    if (!bounding_box.isEmpty())
    {
      // The following is a shorthand for something like:
      // aabb[0, 2, 4] = bounding_box.min(); aabb[1, 3, 5] = bounding_box.max();
      Eigen::Map<Eigen::VectorXd, Eigen::Unaligned, Eigen::InnerStride<2> >(aabb.data(), 3) = bounding_box.min();
      Eigen::Map<Eigen::VectorXd, Eigen::Unaligned, Eigen::InnerStride<2> >(aabb.data() + 1, 3) = bounding_box.max();
    }
  }
architecture-codes: []
functionality-codes:
  - Reference Error - Wrong method
  - Domain Library Issues - Lack of Domain Library Utilization
  - Conditional Checks Issues - Conditional Check Logic Misapplication
  - Operation/Calculation Error - Incorrect arithmetic operation
  - Incomplete Code - Missing one step
  - Constant Value Error
root-cause-codes:
  - Deficiencies in Domain Knowledge - Lack of Knowledge of Domain-Specific Libraries
  - Deficiencies in Domain Knowledge - Insufficient understanding of ROS Programming
  - Weakness in System-Level Integration - Lack of familiarity with the existing codebase
  - Inadequate Comprehension of Functional Logic - Inadequate Understanding of Task Logic