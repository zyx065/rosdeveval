compilation.log: |
  Starting >>> autoware_motion_velocity_dynamic_obstacle_stop_module
  --- stderr: autoware_motion_velocity_dynamic_obstacle_stop_module
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp: In function ‘bool autoware::motion_velocity_planner::dynamic_obstacle_stop::is_not_too_close(const PredictedObject&, const autoware::motion_velocity_planner::dynamic_obstacle_stop::EgoData&, const double&)’:
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp:59:27: error: ‘const TrajectoryPoints’ {aka ‘const class std::vector<autoware_planning_msgs::msg::TrajectoryPoint_<std::allocator<void> > >’} has no member named ‘points’; did you mean ‘pointer’?
     59 |   if (ego_data.trajectory.points.empty()) {
        |                           ^~~~~~
        |                           pointer
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp:67:46: error: ‘const TrajectoryPoints’ {aka ‘const class std::vector<autoware_planning_msgs::msg::TrajectoryPoint_<std::allocator<void> > >’} has no member named ‘points’; did you mean ‘pointer’?
     67 |   for (size_t i = 0; i < ego_data.trajectory.points.size(); ++i) {
        |                                              ^~~~~~
        |                                              pointer
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp:69:27: error: ‘const TrajectoryPoints’ {aka ‘const class std::vector<autoware_planning_msgs::msg::TrajectoryPoint_<std::allocator<void> > >’} has no member named ‘points’; did you mean ‘pointer’?
     69 |       ego_data.trajectory.points,
        |                           ^~~~~~
        |                           pointer
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp:70:16: error: ‘const struct autoware::motion_velocity_planner::dynamic_obstacle_stop::EgoData’ has no member named ‘current_idx’
     70 |       ego_data.current_idx,
        |                ^~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp:75:70: error: ‘const TrajectoryPoints’ {aka ‘const class std::vector<autoware_planning_msgs::msg::TrajectoryPoint_<std::allocator<void> > >’} has no member named ‘points’; did you mean ‘pointer’?
     75 |     geometry_msgs::msg::Point trajectory_point = ego_data.trajectory.points[i].pose.position;
        |                                                                      ^~~~~~
        |                                                                      pointer
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp:76:64: error: ‘const _kinematics_type’ {aka ‘const struct autoware_perception_msgs::msg::PredictedObjectKinematics_<std::allocator<void> >’} has no member named ‘pose_with_covariance’; did you mean ‘initial_pose_with_covariance’?
     76 |     geometry_msgs::msg::Point object_point = object.kinematics.pose_with_covariance.pose.position;
        |                                                                ^~~~~~~~~~~~~~~~~~~~
        |                                                                initial_pose_with_covariance
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp:78:12: error: unused variable ‘point_distance’ [-Werror=unused-variable]
     78 |     double point_distance = std::hypot(
        |            ^~~~~~~~~~~~~~
  cc1plus: all warnings being treated as errors
  gmake[2]: *** [CMakeFiles/autoware_motion_velocity_dynamic_obstacle_stop_module.dir/build.make:132: CMakeFiles/autoware_motion_velocity_dynamic_obstacle_stop_module.dir/src/object_filtering.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:157: CMakeFiles/autoware_motion_velocity_dynamic_obstacle_stop_module.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_motion_velocity_dynamic_obstacle_stop_module [9.93s, exited with code 2]

  Summary: 0 packages finished [11.3s]
    1 package failed: autoware_motion_velocity_dynamic_obstacle_stop_module
    1 package had stderr output: autoware_motion_velocity_dynamic_obstacle_stop_module
generate_code.cpp: |
   bool is_not_too_close(
   const autoware_perception_msgs::msg::PredictedObject & object, const EgoData & ego_data,
   const double & ego_longitudinal_offset)
   {
   // Check if ego trajectory is empty
   if (ego_data.trajectory.points.empty()) {
      return true;
   }

   // Find the closest point on ego trajectory to the object
   double min_distance = std::numeric_limits<double>::max();
   size_t closest_idx = 0;

   for (size_t i = 0; i < ego_data.trajectory.points.size(); ++i) {
      double distance = autoware::motion_utils::calcSignedArcLength(
         ego_data.trajectory.points, 
         ego_data.current_idx, 
         i
      ) + ego_longitudinal_offset;

      // Calculate Euclidean distance between trajectory point and object
      geometry_msgs::msg::Point trajectory_point = ego_data.trajectory.points[i].pose.position;
      geometry_msgs::msg::Point object_point = object.kinematics.pose_with_covariance.pose.position;
      
      double point_distance = std::hypot(
         trajectory_point.x - object_point.x, 
         trajectory_point.y - object_point.y
      );

      // Update minimum distance
      if (std::abs(distance) < std::abs(min_distance)) {
         min_distance = distance;
         closest_idx = i;
      }
   }

   // Define safe distance threshold (adjust as needed)
   const double safe_distance_threshold = 5.0;  // meters

   // Check if object is beyond safe distance
   return std::abs(min_distance) > safe_distance_threshold;
   }
ground_truth.cpp: |-
  bool is_not_too_close(
    const autoware_perception_msgs::msg::PredictedObject & object, const EgoData & ego_data,
    const double & ego_longitudinal_offset)
  {
    const auto obj_arc_length = motion_utils::calcSignedArcLength(
      ego_data.trajectory, ego_data.pose.position,
      object.kinematics.initial_pose_with_covariance.pose.position);
    return std::abs(obj_arc_length) > ego_data.longitudinal_offset_to_first_trajectory_idx +
                                        ego_longitudinal_offset + object.shape.dimensions.x / 2.0;
  }
architecture-codes:
   - ROS Message Related Issues - Incorrect Message Member Access
   - ROS Message Related Issues - Message Operation Issues
functionality-codes:
   - Reference Error - Wrong Variable
   - Incomplete Code - Missing Multiple Steps
   - Conditional Checks Issues - Conditional Check Logic Misapplication
   - Constant Value Error
   - Garbage Code - Meaningless code snippet
root-cause-codes:
   - Inadequate Comprehension of Functional Logic - Inadequate Understanding of Task Logic
   - Deficiencies in Domain Knowledge - Insufficient understanding of ROS Programming
   - Weakness in System-Level Integration - Lack of familiarity with the existing codebase