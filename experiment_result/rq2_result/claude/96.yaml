compilation.log: |
  Starting >>> perception_utils
  Finished <<< perception_utils [1.70s]

  Summary: 1 package finished [3.19s]
generate_code.cpp: |
  cv::Mat runLengthDecoder(const std::vector<uint8_t> & rle_data, const int rows, const int cols) {
      // Create an empty matrix with specified rows and columns
      cv::Mat decoded_matrix = cv::Mat::zeros(rows, cols, CV_8UC1);

      // Track current position in the decoded matrix
      int current_row = 0;
      int current_col = 0;

      // Iterate through RLE data in pairs (value, length)
      for (size_t i = 0; i < rle_data.size(); i += 2) {
          uint8_t pixel_value = rle_data[i];     // Current pixel value (0 or 1)
          uint8_t run_length = rle_data[i + 1];   // Length of the run

          // Fill the matrix with pixel_value for run_length times
          for (int j = 0; j < run_length; ++j) {
              if (current_row < rows && current_col < cols) {
                  decoded_matrix.at<uint8_t>(current_row, current_col) = pixel_value;
                  
                  // Move to next column, wrap to next row if needed
                  current_col++;
                  if (current_col >= cols) {
                      current_col = 0;
                      current_row++;
                  }
              }
          }
      }

      return decoded_matrix;
  }
ground_truth.cpp: |-
  cv::Mat runLengthDecoder(const std::vector<uint8_t> & rle_data, const int rows, const int cols)
  {
    cv::Mat mask(rows, cols, CV_8UC1, cv::Scalar(0));
    int idx = 0;
    int step = sizeof(uint8_t) + sizeof(int);
    for (size_t i = 0; i < rle_data.size(); i += step) {
      uint8_t value;
      int length;
      std::memcpy(&value, &rle_data[i], sizeof(uint8_t));
      std::memcpy(
        &length, &rle_data[i + 1],
        sizeof(
          int));  // under the condition that we know rle_data[i] only consume 1 element of the vector
      for (int j = 0; j < length; ++j) {
        int row_idx = static_cast<int>(idx / cols);
        int col_idx = static_cast<int>(idx % cols);
        mask.at<uint8_t>(row_idx, col_idx) = value;
        idx++;
        if (idx > rows * cols) {
          break;
        }
      }
    }
    return mask;
  }
architecture-codes: []
functionality-codes: 
  - Domain Library Issues - Domain Specific Library Utilization Error
  - Incomplete Code - Missing Multiple Steps
  - Constant Value Error
  - Operation/Calculation Error
root-cause-codes:
  - Inadequate Comprehension of Functional Logic - Inadequate Understanding of Task Logic
  - Deficiencies in Domain Knowledge - Lack of Knowledge of Domain-Specific Libraries
  - Deficiencies in Domain Knowledge - Insufficient understanding of ROS Programming