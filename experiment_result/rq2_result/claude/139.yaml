compilation.log: |
  Starting >>> moveit_core
  --- stderr: moveit_core
  /root/repos/moveit_ws/src/moveit2/moveit_core/robot_model/src/aabb.cpp: In member function ‘void moveit::core::AABB::extendWithTransformedBox(const Isometry3d&, const Vector3d&)’:
  /root/repos/moveit_ws/src/moveit2/moveit_core/robot_model/src/aabb.cpp:56:5: error: ‘min_’ was not declared in this scope; did you mean ‘min’?
     56 |     min_[0] = std::min(min_[0], corners[i][0]);
        |     ^~~~
        |     min
  /root/repos/moveit_ws/src/moveit2/moveit_core/robot_model/src/aabb.cpp:60:5: error: ‘max_’ was not declared in this scope; did you mean ‘max’?
     60 |     max_[0] = std::max(max_[0], corners[i][0]);
        |     ^~~~
        |     max
  gmake[2]: *** [robot_model/CMakeFiles/moveit_robot_model.dir/build.make:79: robot_model/CMakeFiles/moveit_robot_model.dir/src/aabb.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:1596: robot_model/CMakeFiles/moveit_robot_model.dir/all] Error 2
  gmake: *** [Makefile:149: all] Error 2
  ---
  Failed   <<< moveit_core [1.61s, exited with code 2]

  Summary: 0 packages finished [2.06s]
    1 package failed: moveit_core
    1 package had stderr output: moveit_core
generate_code.cpp: |-
  void moveit::core::AABB::extendWithTransformedBox(const Eigen::Isometry3d& transform, const Eigen::Vector3d& box)
  {
    // Create the 8 corners of the box
    Eigen::Vector3d corners[8];
    corners[0] = transform * Eigen::Vector3d(box[0], box[1], box[2]);
    corners[1] = transform * Eigen::Vector3d(box[0], box[1], -box[2]);
    corners[2] = transform * Eigen::Vector3d(box[0], -box[1], box[2]);
    corners[3] = transform * Eigen::Vector3d(box[0], -box[1], -box[2]);
    corners[4] = transform * Eigen::Vector3d(-box[0], box[1], box[2]);
    corners[5] = transform * Eigen::Vector3d(-box[0], box[1], -box[2]);
    corners[6] = transform * Eigen::Vector3d(-box[0], -box[1], box[2]);
    corners[7] = transform * Eigen::Vector3d(-box[0], -box[1], -box[2]);

    // Find the min and max coordinates to extend the AABB
    for (int i = 0; i < 8; ++i)
    {
      min_[0] = std::min(min_[0], corners[i][0]);
      min_[1] = std::min(min_[1], corners[i][1]);
      min_[2] = std::min(min_[2], corners[i][2]);

      max_[0] = std::max(max_[0], corners[i][0]);
      max_[1] = std::max(max_[1], corners[i][1]);
      max_[2] = std::max(max_[2], corners[i][2]);
    }
  }
ground_truth.cpp: |-
  void moveit::core::AABB::extendWithTransformedBox(const Eigen::Isometry3d& transform, const Eigen::Vector3d& box)
  {
    // Method adapted from FCL src/shape/geometric_shapes_utility.cpp#computeBV<AABB, Box>(...) (BSD-licensed code):
    // https://github.com/flexible-collision-library/fcl/blob/fcl-0.4/src/shape/geometric_shapes_utility.cpp#L292
    // We don't call their code because it would need creating temporary objects, and their method is in floats.
    //
    // Here's a nice explanation why it works: https://zeuxcg.org/2010/10/17/aabb-from-obb-with-component-wise-abs/

    ASSERT_ISOMETRY(transform)  // unsanitized input, could contain non-isometry
    const Eigen::Matrix3d& r = transform.linear();
    const Eigen::Vector3d& t = transform.translation();

    double x_range = 0.5 * (fabs(r(0, 0) * box[0]) + fabs(r(0, 1) * box[1]) + fabs(r(0, 2) * box[2]));
    double y_range = 0.5 * (fabs(r(1, 0) * box[0]) + fabs(r(1, 1) * box[1]) + fabs(r(1, 2) * box[2]));
    double z_range = 0.5 * (fabs(r(2, 0) * box[0]) + fabs(r(2, 1) * box[1]) + fabs(r(2, 2) * box[2]));

    const Eigen::Vector3d v_delta(x_range, y_range, z_range);
    extend(t + v_delta);
    extend(t - v_delta);
  }
architecture-codes: []
functionality-codes:
  - Reference Error - Undefined Name
  - Incomplete Code - Missing Multiple Steps
  - Operation/Calculation Error - Incorrect arithmetic operation
  - Conditional Checks Issues - Conditional Check Missing
Root Cause Analysis:
  - Inadequate Comprehension of Functional Logic - Inadequate Understanding of Task Logic
  - Deficiencies in Domain Knowledge - Lack of Knowledge of Domain-Specific Libraries
  - Weakness in System-Level Integration - Lack of familiarity with the existing codebase
