compilation.log: |
  Starting >>> autoware_autonomous_emergency_braking
  --- stderr: autoware_autonomous_emergency_braking
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_autonomous_emergency_braking/src/node.cpp: In member function ‘void autoware::motion::control::autonomous_emergency_braking::AEB::onPointCloud(sensor_msgs::msg::PointCloud2_<std::allocator<void> >::ConstSharedPtr)’:
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_autonomous_emergency_braking/src/node.cpp:305:23: error: ‘using element_type = class autoware::universe_utils::TimeKeeper’ {aka ‘class autoware::universe_utils::TimeKeeper’} has no member named ‘tic’
    305 |         time_keeper_->tic("onPointCloud");
        |                       ^~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_autonomous_emergency_braking/src/node.cpp:315:80: error: no match for ‘operator*’ (operand type is ‘tf2_ros::Buffer’)
    315 |     auto transform_opt = getTransform("base_link", input_msg->header.frame_id, *tf_buffer_, get_logger());
        |                                                                                ^~~~~~~~~~~
  In file included from /opt/ros/humble/include/tf2/tf2/LinearMath/Quaternion.h:21,
                   from /opt/ros/humble/include/tf2_geometry_msgs/tf2_geometry_msgs/tf2_geometry_msgs.hpp:57,
                   from /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/geometry/geometry.hpp:40,
                   from /workspace/repos/autoware/install/autoware_motion_utils/include/autoware/motion_utils/trajectory/trajectory.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_autonomous_emergency_braking/include/autoware/autonomous_emergency_braking/node.hpp:20,
                   from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_autonomous_emergency_braking/src/node.cpp:15:
  /opt/ros/humble/include/tf2/tf2/LinearMath/Vector3.h:364:1: note: candidate: ‘tf2::Vector3 tf2::operator*(const tf2::Vector3&, const tf2::Vector3&)’
    364 | operator*(const Vector3& v1, const Vector3& v2)
        | ^~~~~~~~
  /opt/ros/humble/include/tf2/tf2/LinearMath/Vector3.h:364:1: note:   candidate expects 2 arguments, 1 provided
  /opt/ros/humble/include/tf2/tf2/LinearMath/Vector3.h:384:1: note: candidate: ‘tf2::Vector3 tf2::operator*(const tf2::Vector3&, const tf2Scalar&)’
    384 | operator*(const Vector3& v, const tf2Scalar& s)
        | ^~~~~~~~
  /opt/ros/humble/include/tf2/tf2/LinearMath/Vector3.h:384:1: note:   candidate expects 2 arguments, 1 provided
  /opt/ros/humble/include/tf2/tf2/LinearMath/Vector3.h:391:1: note: candidate: ‘tf2::Vector3 tf2::operator*(const tf2Scalar&, const tf2::Vector3&)’
    391 | operator*(const tf2Scalar& s, const Vector3& v)
        | ^~~~~~~~
  /opt/ros/humble/include/tf2/tf2/LinearMath/Vector3.h:391:1: note:   candidate expects 2 arguments, 1 provided
  In file included from /opt/ros/humble/include/tf2_geometry_msgs/tf2_geometry_msgs/tf2_geometry_msgs.hpp:57,
                   from /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/geometry/geometry.hpp:40,
                   from /workspace/repos/autoware/install/autoware_motion_utils/include/autoware/motion_utils/trajectory/trajectory.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_autonomous_emergency_braking/include/autoware/autonomous_emergency_braking/node.hpp:20,
                   from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_autonomous_emergency_braking/src/node.cpp:15:
  /opt/ros/humble/include/tf2/tf2/LinearMath/Quaternion.h:368:1: note: candidate: ‘tf2::Quaternion tf2::operator*(const tf2::Quaternion&, const tf2::Quaternion&)’
    368 | operator*(const Quaternion& q1, const Quaternion& q2) {
        | ^~~~~~~~
  /opt/ros/humble/include/tf2/tf2/LinearMath/Quaternion.h:368:1: note:   candidate expects 2 arguments, 1 provided
  /opt/ros/humble/include/tf2/tf2/LinearMath/Quaternion.h:376:1: note: candidate: ‘tf2::Quaternion tf2::operator*(const tf2::Quaternion&, const tf2::Vector3&)’
    376 | operator*(const Quaternion& q, const Vector3& w)
        | ^~~~~~~~
  /opt/ros/humble/include/tf2/tf2/LinearMath/Quaternion.h:376:1: note:   candidate expects 2 arguments, 1 provided
  /opt/ros/humble/include/tf2/tf2/LinearMath/Quaternion.h:385:1: note: candidate: ‘tf2::Quaternion tf2::operator*(const tf2::Vector3&, const tf2::Quaternion&)’
    385 | operator*(const Vector3& w, const Quaternion& q)
        | ^~~~~~~~
  /opt/ros/humble/include/tf2/tf2/LinearMath/Quaternion.h:385:1: note:   candidate expects 2 arguments, 1 provided
  In file included from /opt/ros/humble/include/tf2/tf2/LinearMath/Transform.h:21,
                   from /opt/ros/humble/include/tf2_geometry_msgs/tf2_geometry_msgs/tf2_geometry_msgs.hpp:58,
                   from /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/geometry/geometry.hpp:40,
                   from /workspace/repos/autoware/install/autoware_motion_utils/include/autoware/motion_utils/trajectory/trajectory.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_autonomous_emergency_braking/include/autoware/autonomous_emergency_braking/node.hpp:20,
                   from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_autonomous_emergency_braking/src/node.cpp:15:
  /opt/ros/humble/include/tf2/tf2/LinearMath/Matrix3x3.h:611:1: note: candidate: ‘tf2::Vector3 tf2::operator*(const tf2::Matrix3x3&, const tf2::Vector3&)’
    611 | operator*(const Matrix3x3& m, const Vector3& v)
        | ^~~~~~~~
  /opt/ros/humble/include/tf2/tf2/LinearMath/Matrix3x3.h:611:1: note:   candidate expects 2 arguments, 1 provided
  /opt/ros/humble/include/tf2/tf2/LinearMath/Matrix3x3.h:618:1: note: candidate: ‘tf2::Vector3 tf2::operator*(const tf2::Vector3&, const tf2::Matrix3x3&)’
    618 | operator*(const Vector3& v, const Matrix3x3& m)
        | ^~~~~~~~
  /opt/ros/humble/include/tf2/tf2/LinearMath/Matrix3x3.h:618:1: note:   candidate expects 2 arguments, 1 provided
  /opt/ros/humble/include/tf2/tf2/LinearMath/Matrix3x3.h:624:1: note: candidate: ‘tf2::Matrix3x3 tf2::operator*(const tf2::Matrix3x3&, const tf2::Matrix3x3&)’
    624 | operator*(const Matrix3x3& m1, const Matrix3x3& m2)
        | ^~~~~~~~
  /opt/ros/humble/include/tf2/tf2/LinearMath/Matrix3x3.h:624:1: note:   candidate expects 2 arguments, 1 provided
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_autonomous_emergency_braking/src/node.cpp:315:26: error: ‘getTransform’ was not declared in this scope; did you mean ‘autoware::motion::control::autonomous_emergency_braking::utils::getTransform’?
    315 |     auto transform_opt = getTransform("base_link", input_msg->header.frame_id, *tf_buffer_, get_logger());
        |                          ^~~~~~~~~~~~
        |                          autoware::motion::control::autonomous_emergency_braking::utils::getTransform
  In file included from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_autonomous_emergency_braking/src/node.cpp:16:
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_autonomous_emergency_braking/include/autoware/autonomous_emergency_braking/utils.hpp:121:53: note: ‘autoware::motion::control::autonomous_emergency_braking::utils::getTransform’ declared here
    121 | std::optional<geometry_msgs::msg::TransformStamped> getTransform(
        |                                                     ^~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_autonomous_emergency_braking/src/node.cpp:324:19: error: base operand of ‘->’ has non-pointer type ‘tf2_ros::Buffer’
    324 |         tf_buffer_->transform(*input_msg, *transformed_cloud_ptr, "base_link");
        |                   ^~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_autonomous_emergency_braking/src/node.cpp:338:37: error: ‘struct autoware::vehicle_info_utils::VehicleInfo’ has no member named ‘min_height_’
    338 |         if (height >= vehicle_info_.min_height_ - detection_range_min_height_ &&
        |                                     ^~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_autonomous_emergency_braking/src/node.cpp:339:37: error: ‘struct autoware::vehicle_info_utils::VehicleInfo’ has no member named ‘max_height_’
    339 |             height <= vehicle_info_.max_height_ + detection_range_max_height_margin_) {
        |                                     ^~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_autonomous_emergency_braking/src/node.cpp:361:23: error: ‘using element_type = class autoware::universe_utils::TimeKeeper’ {aka ‘class autoware::universe_utils::TimeKeeper’} has no member named ‘toc’
    361 |         time_keeper_->toc("onPointCloud");
        |                       ^~~
  gmake[2]: *** [CMakeFiles/autoware_autonomous_emergency_braking_node.dir/build.make:76: CMakeFiles/autoware_autonomous_emergency_braking_node.dir/src/node.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:187: CMakeFiles/autoware_autonomous_emergency_braking_node.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_autonomous_emergency_braking [19.1s, exited with code 2]

  Summary: 0 packages finished [20.4s]
    1 package failed: autoware_autonomous_emergency_braking
    1 package had stderr output: autoware_autonomous_emergency_braking
generate_code.cpp: |-
  void AEB::onPointCloud(const PointCloud2::ConstSharedPtr input_msg)
  {
      // Start timing for performance tracking
      if (time_keeper_) {
          time_keeper_->tic("onPointCloud");
      }

      // Check if input message is valid
      if (!input_msg) {
          RCLCPP_WARN(get_logger(), "Received null point cloud message");
          return;
      }

      // Transform point cloud to base_link frame
      auto transform_opt = getTransform("base_link", input_msg->header.frame_id, *tf_buffer_, get_logger());
      if (!transform_opt) {
          RCLCPP_WARN(get_logger(), "Failed to get transform for point cloud");
          return;
      }

      // Transform point cloud
      PointCloud2::SharedPtr transformed_cloud_ptr = std::make_shared<PointCloud2>();
      try {
          tf_buffer_->transform(*input_msg, *transformed_cloud_ptr, "base_link");
      } catch (const tf2::TransformException& ex) {
          RCLCPP_WARN(get_logger(), "Point cloud transform failed: %s", ex.what());
          return;
      }

      // Convert to PCL point cloud for processing
      pcl::PointCloud<pcl::PointXYZ>::Ptr pcl_cloud(new pcl::PointCloud<pcl::PointXYZ>());
      pcl::fromROSMsg(*transformed_cloud_ptr, *pcl_cloud);

      // Height filtering to remove false positives
      pcl::PointCloud<pcl::PointXYZ>::Ptr filtered_cloud(new pcl::PointCloud<pcl::PointXYZ>());
      for (const auto& point : pcl_cloud->points) {
          double height = point.z;
          if (height >= vehicle_info_.min_height_ - detection_range_min_height_ &&
              height <= vehicle_info_.max_height_ + detection_range_max_height_margin_) {
              filtered_cloud->points.push_back(point);
          }
      }
      filtered_cloud->width = filtered_cloud->points.size();
      filtered_cloud->height = 1;
      filtered_cloud->is_dense = true;

      // Voxel grid downsampling
      pcl::PointCloud<pcl::PointXYZ>::Ptr downsampled_cloud(new pcl::PointCloud<pcl::PointXYZ>());
      pcl::VoxelGrid<pcl::PointXYZ> voxel_grid;
      voxel_grid.setInputCloud(filtered_cloud);
      voxel_grid.setLeafSize(voxel_grid_x_, voxel_grid_y_, voxel_grid_z_);
      voxel_grid.filter(*downsampled_cloud);

      // Convert back to ROS message
      obstacle_ros_pointcloud_ptr_ = std::make_shared<PointCloud2>();
      pcl::toROSMsg(*downsampled_cloud, *obstacle_ros_pointcloud_ptr_);
      obstacle_ros_pointcloud_ptr_->header = transformed_cloud_ptr->header;

      // Stop timing
      if (time_keeper_) {
          time_keeper_->toc("onPointCloud");
      }
  }
ground_truth.cpp: |-
  void AEB::onPointCloud(const PointCloud2::ConstSharedPtr input_msg)
  {
    autoware::universe_utils::ScopedTimeTrack st(__func__, *time_keeper_);
    PointCloud::Ptr pointcloud_ptr(new PointCloud);
    pcl::fromROSMsg(*input_msg, *pointcloud_ptr);

    if (input_msg->header.frame_id != "base_link") {
      RCLCPP_ERROR_STREAM(
        get_logger(),
        "[AEB]: Input point cloud frame is not base_link and it is " << input_msg->header.frame_id);
      // transform pointcloud
      const auto logger = get_logger();
      const auto transform_stamped =
        utils::getTransform("base_link", input_msg->header.frame_id, tf_buffer_, logger);
      if (!transform_stamped.has_value()) return;

      // transform by using eigen matrix
      PointCloud2 transformed_points{};
      const Eigen::Matrix4f affine_matrix =
        tf2::transformToEigen(transform_stamped.value().transform).matrix().cast<float>();
      pcl_ros::transformPointCloud(affine_matrix, *input_msg, transformed_points);
      pcl::fromROSMsg(transformed_points, *pointcloud_ptr);
    }

    // apply z-axis filter for removing False Positive points
    PointCloud::Ptr height_filtered_pointcloud_ptr(new PointCloud);
    pcl::PassThrough<pcl::PointXYZ> height_filter;
    height_filter.setInputCloud(pointcloud_ptr);
    height_filter.setFilterFieldName("z");
    height_filter.setFilterLimits(
      detection_range_min_height_,
      vehicle_info_.vehicle_height_m + detection_range_max_height_margin_);
    height_filter.filter(*height_filtered_pointcloud_ptr);

    pcl::VoxelGrid<pcl::PointXYZ> filter;
    PointCloud::Ptr no_height_filtered_pointcloud_ptr(new PointCloud);
    filter.setInputCloud(height_filtered_pointcloud_ptr);
    filter.setLeafSize(voxel_grid_x_, voxel_grid_y_, voxel_grid_z_);
    filter.filter(*no_height_filtered_pointcloud_ptr);

    obstacle_ros_pointcloud_ptr_ = std::make_shared<PointCloud2>();

    pcl::toROSMsg(*no_height_filtered_pointcloud_ptr, *obstacle_ros_pointcloud_ptr_);
    obstacle_ros_pointcloud_ptr_->header = input_msg->header;
  }
architecture-codes:
  - ROS Timer Issues - Timestamp Processing Errors
  - ROS Message Related Issues - Incorrect Message Member Access
functionality-codes:
  - Meet Requirement - No 
  - Reference Error - Wrong Variable
  - Reference Error - Wrong Method
  - Reference Error - Undefined Name
  - Domain Library Issues - Domain Specific Library Utilization Error
  - Domain Library Issues - Lack of Domain Library Utilization
  - Conditional Checks Issues - Conditional Check Logic Misapplication
root-cause-codes:
  - Deficiencies in Domain Knowledge - Lack of ROS development best practices
  - Deficiencies in Domain Knowledge - Insufficient understanding of ROS Programming
  - Deficiencies in Domain Knowledge - Lack of Knowledge of Domain-Specific Libraries
  - Weakness in System-Level Integration - Lack of familiarity with the existing codebase