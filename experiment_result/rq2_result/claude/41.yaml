compilation.log: |
  Starting >>> autoware_traffic_light_arbiter
  --- stderr: autoware_traffic_light_arbiter
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_traffic_light_arbiter/src/traffic_light_arbiter.cpp: In member function ‘void autoware::TrafficLightArbiter::onMap(autoware_map_msgs::msg::LaneletMapBin_<std::allocator<void> >::ConstSharedPtr)’:
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_traffic_light_arbiter/src/traffic_light_arbiter.cpp:109:14: error: ‘lanelet::io_handlers’ has not been declared
    109 |     lanelet::io_handlers::BinMapLoader::loadBinMap(msg->data, map);
        |              ^~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_traffic_light_arbiter/src/traffic_light_arbiter.cpp:115:17: error: ‘TrafficLightConstPtr’ was not declared in this scope; did you mean ‘lanelet::TrafficLightConstPtr’?
    115 |     std::vector<TrafficLightConstPtr> pedestrian_signals;
        |                 ^~~~~~~~~~~~~~~~~~~~
        |                 lanelet::TrafficLightConstPtr
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_traffic_light_arbiter/src/traffic_light_arbiter.cpp:34:7: note: ‘lanelet::TrafficLightConstPtr’ declared here
     34 | using TrafficLightConstPtr = std::shared_ptr<const TrafficLight>;
        |       ^~~~~~~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_traffic_light_arbiter/src/traffic_light_arbiter.cpp:115:37: error: template argument 1 is invalid
    115 |     std::vector<TrafficLightConstPtr> pedestrian_signals;
        |                                     ^
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_traffic_light_arbiter/src/traffic_light_arbiter.cpp:115:37: error: template argument 2 is invalid
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_traffic_light_arbiter/src/traffic_light_arbiter.cpp:116:48: error: ‘using element_type = class lanelet::LaneletMap’ {aka ‘class lanelet::LaneletMap’} has no member named ‘regulatoryElements’; did you mean ‘regulatoryElementLayer’?
    116 |     for (const auto& regulatory_element : map->regulatoryElements()) {
        |                                                ^~~~~~~~~~~~~~~~~~
        |                                                regulatoryElementLayer
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_traffic_light_arbiter/src/traffic_light_arbiter.cpp:125:36: error: request for member ‘push_back’ in ‘pedestrian_signals’, which is of non-class type ‘int’
    125 |                 pedestrian_signals.push_back(traffic_light);
        |                                    ^~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_traffic_light_arbiter/src/traffic_light_arbiter.cpp:132:55: error: cannot convert ‘int’ to ‘const std::vector<std::shared_ptr<const lanelet::TrafficLight> >&’
    132 |         signal_match_validator_->setPedestrianSignals(pedestrian_signals);
        |                                                       ^~~~~~~~~~~~~~~~~~
        |                                                       |
        |                                                       int
  In file included from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_traffic_light_arbiter/include/autoware/traffic_light_arbiter/traffic_light_arbiter.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_traffic_light_arbiter/src/traffic_light_arbiter.cpp:15:
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_traffic_light_arbiter/include/autoware/traffic_light_arbiter/signal_match_validator.hpp:75:71: note:   initializing argument 1 of ‘void SignalMatchValidator::setPedestrianSignals(const std::vector<std::shared_ptr<const lanelet::TrafficLight> >&)’
     75 |   void setPedestrianSignals(const std::vector<TrafficLightConstPtr> & pedestrian_signals);
        |                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~
  gmake[2]: *** [CMakeFiles/autoware_traffic_light_arbiter.dir/build.make:76: CMakeFiles/autoware_traffic_light_arbiter.dir/src/traffic_light_arbiter.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:157: CMakeFiles/autoware_traffic_light_arbiter.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_traffic_light_arbiter [7.82s, exited with code 2]

  Summary: 0 packages finished [9.23s]
    1 package failed: autoware_traffic_light_arbiter
    1 package had stderr output: autoware_traffic_light_arbiter
generate_code.cpp: |-
  void TrafficLightArbiter::onMap(const LaneletMapBin::ConstSharedPtr msg)
  {
      // Check if signal matching is enabled
      if (!enable_signal_matching_) {
          return;
      }

      // Deserialize the lanelet map from the binary message
      lanelet::LaneletMapPtr map = std::make_shared<lanelet::LaneletMap>();
      lanelet::io_handlers::BinMapLoader::loadBinMap(msg->data, map);

      // Create a new set to store regulatory element IDs
      map_regulatory_elements_set_ = std::make_unique<std::unordered_set<lanelet::Id>>();

      // Extract traffic signals from the map
      std::vector<TrafficLightConstPtr> pedestrian_signals;
      for (const auto& regulatory_element : map->regulatoryElements()) {
          // Store the regulatory element ID
          map_regulatory_elements_set_->insert(regulatory_element->id());

          // Check if the regulatory element is a traffic light
          auto traffic_light = std::dynamic_pointer_cast<const lanelet::TrafficLight>(regulatory_element);
          if (traffic_light) {
              // If it's a pedestrian traffic light, add to pedestrian signals
              if (traffic_light->type() == "pedestrian") {
                  pedestrian_signals.push_back(traffic_light);
              }
          }
      }

      // Update pedestrian signals in the signal match validator
      if (signal_match_validator_) {
          signal_match_validator_->setPedestrianSignals(pedestrian_signals);
      }
  }
ground_truth.cpp: |-
  void TrafficLightArbiter::onMap(const LaneletMapBin::ConstSharedPtr msg)
  {
    const auto map = std::make_shared<lanelet::LaneletMap>();
    lanelet::utils::conversion::fromBinMsg(*msg, map);

    const auto signals = lanelet::filter_traffic_signals(map);
    map_regulatory_elements_set_ = std::make_unique<std::unordered_set<lanelet::Id>>();

    for (const auto & signal : signals) {
      map_regulatory_elements_set_->emplace(signal->id());
    }

    if (enable_signal_matching_) {
      // Filter only pedestrian signals to distinguish them in signal matching
      const auto pedestrian_signals = lanelet::filter_pedestrian_signals(map);
      signal_match_validator_->setPedestrianSignals(pedestrian_signals);
    }
  }
functionality-codes:
  - Meet Requirement - No
  - Domain Library Issues - Domain Specific Library Utilization Error
  - Domain Library Issues - Lack of Domain Library Utilization
  - Reference Error - Wrong method
  - Reference Error - Undefined Name
  - Conditional Checks Issues - Conditional Check Logic Misapplication
root-cause-codes:
  - Deficiencies in Domain Knowledge - Lack of Knowledge of Domain-Specific Libraries
  - Weakness in System-Level Integration - Lack of familiarity with the existing codebase
  - Inadequate Comprehension of Functional Logic - Inadequate Understanding of Task Logic