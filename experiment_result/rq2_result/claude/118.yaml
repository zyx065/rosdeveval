compilation.log: |
  Starting >>> autoware_motion_velocity_out_of_lane_module
  --- stderr: autoware_motion_velocity_out_of_lane_module
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_out_of_lane_module/src/filter_predicted_objects.cpp: In function ‘void autoware::motion_velocity_planner::out_of_lane::cut_predicted_path_beyond_line(autoware_perception_msgs::msg::PredictedPath&, const LineString2d&, double)’:
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_out_of_lane_module/src/filter_predicted_objects.cpp:46:66: error: conversion from ‘__gnu_cxx::__alloc_traits<std::allocator<geometry_msgs::msg::Pose_<std::allocator<void> > >, geometry_msgs::msg::Pose_<std::allocator<void> > >::value_type’ {aka ‘geometry_msgs::msg::Pose_<std::allocator<void> >’} to non-scalar type ‘geometry_msgs::msg::Point’ {aka ‘geometry_msgs::msg::Point_<std::allocator<void> >’} requested
     46 |     geometry_msgs::msg::Point front_point = predicted_path.path[i];
        |                                                                  ^
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_out_of_lane_module/src/filter_predicted_objects.cpp:50:25: error: ‘lineSegmentIntersection’ is not a member of ‘autoware::universe_utils’
     50 |     if (universe_utils::lineSegmentIntersection(
        |                         ^~~~~~~~~~~~~~~~~~~~~~~
  gmake[2]: *** [CMakeFiles/autoware_motion_velocity_out_of_lane_module.dir/build.make:104: CMakeFiles/autoware_motion_velocity_out_of_lane_module.dir/src/filter_predicted_objects.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:157: CMakeFiles/autoware_motion_velocity_out_of_lane_module.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_motion_velocity_out_of_lane_module [11.9s, exited with code 2]

  Summary: 0 packages finished [13.2s]
    1 package failed: autoware_motion_velocity_out_of_lane_module
    1 package had stderr output: autoware_motion_velocity_out_of_lane_module
generate_code.cpp: |
  void cut_predicted_path_beyond_line(
    autoware_perception_msgs::msg::PredictedPath & predicted_path,
    const universe_utils::LineString2d & stop_line, const double object_front_overhang)
  {
    // If the path is empty, return immediately
    if (predicted_path.path.empty()) {
      return;
    }

    // Find the first point beyond the stop line
    size_t cut_index = predicted_path.path.size();
    for (size_t i = 0; i < predicted_path.path.size(); ++i) {
      // Calculate the point at the front of the object, considering front overhang
      geometry_msgs::msg::Point front_point = predicted_path.path[i];
      front_point.x += object_front_overhang;

      // Check if this point intersects with the stop line
      if (universe_utils::lineSegmentIntersection(
            {front_point.x, front_point.y}, 
            stop_line.front(), 
            stop_line.back())) 
      {
        cut_index = i;
        break;
      }
    }

    // If an intersection is found, truncate the path
    if (cut_index < predicted_path.path.size()) {
      predicted_path.path.resize(cut_index + 1);
    }
  }
ground_truth.cpp: |-
  void cut_predicted_path_beyond_line(
    autoware_perception_msgs::msg::PredictedPath & predicted_path,
    const universe_utils::LineString2d & stop_line, const double object_front_overhang)
  {
    if (predicted_path.path.empty() || stop_line.size() < 2) return;

    auto stop_line_idx = 0UL;
    bool found = false;
    lanelet::BasicSegment2d path_segment;
    path_segment.first.x() = predicted_path.path.front().position.x;
    path_segment.first.y() = predicted_path.path.front().position.y;
    for (stop_line_idx = 1; stop_line_idx < predicted_path.path.size(); ++stop_line_idx) {
      path_segment.second.x() = predicted_path.path[stop_line_idx].position.x;
      path_segment.second.y() = predicted_path.path[stop_line_idx].position.y;
      if (boost::geometry::intersects(stop_line, path_segment)) {
        found = true;
        break;
      }
      path_segment.first = path_segment.second;
    }
    if (found) {
      auto cut_idx = stop_line_idx;
      double arc_length = 0;
      while (cut_idx > 0 && arc_length < object_front_overhang) {
        arc_length += universe_utils::calcDistance2d(
          predicted_path.path[cut_idx], predicted_path.path[cut_idx - 1]);
        --cut_idx;
      }
      predicted_path.path.resize(cut_idx);
    }
  }
architecture-codes:
  - ROS Message Related Issues - Incorrect Message Member Access
functionality-codes:
  - Reference Error - Wrong Method
  - Domain Library Issues - Lack of Domain Library Utilization
  - Incomplete Code - Missing Multiple Steps
  - Operation/Calculation Error - Incorrect Arithmetic Operation
  - Conditional Checks Issues - Conditional Check Logic Misapplication
  - Garbage Code - Wrong Logical
root-cause-codes:
  - Inadequate Comprehension of Functional Logic - Inadequate Understanding of Task Logic
  - Deficiencies in Domain Knowledge - Insufficient Understanding of ROS Programming
  - Deficiencies in Domain Knowledge - Lack of Knowledge of Domain-Specific Libraries
  - Weakness in System-Level Integration - Lack of Familiarity with the Existing Codebase