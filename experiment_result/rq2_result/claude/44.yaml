compilation.log: |
  Starting >>> autoware_obstacle_cruise_planner
  --- stderr: autoware_obstacle_cruise_planner
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_obstacle_cruise_planner/src/node.cpp: In constructor ‘autoware::motion_planning::ObstacleCruisePlannerNode::ObstacleCruisePlannerNode(const rclcpp::NodeOptions&)’:
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_obstacle_cruise_planner/src/node.cpp:507:21: error: no matching function for call to ‘autoware::motion_planning::ObstacleCruisePlannerNode::declare_parameters()’
    507 |   declare_parameters();
        |   ~~~~~~~~~~~~~~~~~~^~
  In file included from /opt/ros/humble/include/rclcpp/rclcpp/executors/single_threaded_executor.hpp:28,
                   from /opt/ros/humble/include/rclcpp/rclcpp/executors.hpp:22,
                   from /opt/ros/humble/include/rclcpp/rclcpp/rclcpp.hpp:155,
                   from /opt/ros/humble/include/tf2_ros/tf2_ros/buffer_interface.h:48,
                   from /opt/ros/humble/include/tf2_geometry_msgs/tf2_geometry_msgs/tf2_geometry_msgs.hpp:60,
                   from /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/geometry/geometry.hpp:40,
                   from /workspace/repos/autoware/install/autoware_motion_utils/include/autoware/motion_utils/trajectory/interpolation.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_obstacle_cruise_planner/include/autoware/obstacle_cruise_planner/common_structs.hpp:19,
                   from /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_obstacle_cruise_planner/include/autoware/obstacle_cruise_planner/node.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_obstacle_cruise_planner/src/node.cpp:15:
  /opt/ros/humble/include/rclcpp/rclcpp/node.hpp:478:3: note: candidate: ‘template<class ParameterT> std::vector<T> rclcpp::Node::declare_parameters(const string&, const std::map<std::__cxx11::basic_string<char>, ParameterT>&, bool)’
    478 |   declare_parameters(
        |   ^~~~~~~~~~~~~~~~~~
  /opt/ros/humble/include/rclcpp/rclcpp/node.hpp:478:3: note:   template argument deduction/substitution failed:
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_obstacle_cruise_planner/src/node.cpp:507:21: note:   candidate expects 3 arguments, 0 provided
    507 |   declare_parameters();
        |   ~~~~~~~~~~~~~~~~~~^~
  In file included from /opt/ros/humble/include/rclcpp/rclcpp/executors/single_threaded_executor.hpp:28,
                   from /opt/ros/humble/include/rclcpp/rclcpp/executors.hpp:22,
                   from /opt/ros/humble/include/rclcpp/rclcpp/rclcpp.hpp:155,
                   from /opt/ros/humble/include/tf2_ros/tf2_ros/buffer_interface.h:48,
                   from /opt/ros/humble/include/tf2_geometry_msgs/tf2_geometry_msgs/tf2_geometry_msgs.hpp:60,
                   from /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/geometry/geometry.hpp:40,
                   from /workspace/repos/autoware/install/autoware_motion_utils/include/autoware/motion_utils/trajectory/interpolation.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_obstacle_cruise_planner/include/autoware/obstacle_cruise_planner/common_structs.hpp:19,
                   from /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_obstacle_cruise_planner/include/autoware/obstacle_cruise_planner/node.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_obstacle_cruise_planner/src/node.cpp:15:
  /opt/ros/humble/include/rclcpp/rclcpp/node.hpp:492:3: note: candidate: ‘template<class ParameterT> std::vector<T> rclcpp::Node::declare_parameters(const string&, const std::map<std::__cxx11::basic_string<char>, std::pair<ParameterT, rcl_interfaces::msg::ParameterDescriptor_<std::allocator<void> > > >&, bool)’
    492 |   declare_parameters(
        |   ^~~~~~~~~~~~~~~~~~
  /opt/ros/humble/include/rclcpp/rclcpp/node.hpp:492:3: note:   template argument deduction/substitution failed:
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_obstacle_cruise_planner/src/node.cpp:507:21: note:   candidate expects 3 arguments, 0 provided
    507 |   declare_parameters();
        |   ~~~~~~~~~~~~~~~~~~^~
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_obstacle_cruise_planner/src/node.cpp: At global scope:
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_obstacle_cruise_planner/src/node.cpp:233:18: error: ‘std::vector<int> {anonymous}::getTargetObjectType(rclcpp::Node&, const string&)’ defined but not used [-Werror=unused-function]
    233 | std::vector<int> getTargetObjectType(rclcpp::Node & node, const std::string & param_prefix)
        |                  ^~~~~~~~~~~~~~~~~~~
  cc1plus: all warnings being treated as errors
  gmake[2]: *** [CMakeFiles/autoware_obstacle_cruise_planner_core.dir/build.make:76: CMakeFiles/autoware_obstacle_cruise_planner_core.dir/src/node.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:159: CMakeFiles/autoware_obstacle_cruise_planner_core.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_obstacle_cruise_planner [21.4s, exited with code 2]

  Summary: 0 packages finished [22.8s]
    1 package failed: autoware_obstacle_cruise_planner
    1 package had stderr output: autoware_obstacle_cruise_planner
generate_code.cpp: "ObstacleCruisePlannerNode::ObstacleCruisePlannerNode(const rclcpp::NodeOptions\
  \ & node_options)\n: Node(\"obstacle_cruise_planner\", node_options),\n  vehicle_info_(autoware::vehicle_info_utils::VehicleInfoUtils(*this).getVehicleInfo()),\n\
  \  debug_data_ptr_(std::make_shared<DebugData>())\n{\n  // Initialize TF buffer\
  \ and listener\n  tf_buffer_ = std::make_unique<tf2_ros::Buffer>(this->get_clock());\n\
  \  tf_listener_ = std::make_shared<tf2_ros::TransformListener>(*tf_buffer_);\n\n\
  \  // Declare and get node parameters\n  declare_parameters();\n  set_param_res_\
  \ = this->add_on_set_parameters_callback(\n    std::bind(&ObstacleCruisePlannerNode::onParam,\
  \ this, std::placeholders::_1));\n\n  // Initialize publishers\n  trajectory_pub_\
  \ = this->create_publisher<Trajectory>(\"~/output/trajectory\", 1);\n  vel_limit_pub_\
  \ = this->create_publisher<VelocityLimit>(\"~/output/velocity_limit\", 1);\n  clear_vel_limit_pub_\
  \ = this->create_publisher<VelocityLimitClearCommand>(\"~/output/clear_velocity_limit\"\
  , 1);\n  \n  // Debug publishers\n  if (enable_debug_info_) {\n    debug_marker_pub_\
  \ = this->create_publisher<MarkerArray>(\"~/debug/markers\", 1);\n    debug_cruise_wall_marker_pub_\
  \ = this->create_publisher<MarkerArray>(\"~/debug/cruise_wall_markers\", 1);\n \
  \   debug_stop_wall_marker_pub_ = this->create_publisher<MarkerArray>(\"~/debug/stop_wall_markers\"\
  , 1);\n    debug_slow_down_wall_marker_pub_ = this->create_publisher<MarkerArray>(\"\
  ~/debug/slow_down_wall_markers\", 1);\n    debug_stop_planning_info_pub_ = this->create_publisher<Float32MultiArrayStamped>(\"\
  ~/debug/stop_planning_info\", 1);\n    debug_cruise_planning_info_pub_ = this->create_publisher<Float32MultiArrayStamped>(\"\
  ~/debug/cruise_planning_info\", 1);\n    debug_slow_down_planning_info_pub_ = this->create_publisher<Float32MultiArrayStamped>(\"\
  ~/debug/slow_down_planning_info\", 1);\n  }\n\n  if (enable_calculation_time_info_)\
  \ {\n    debug_calculation_time_pub_ = this->create_publisher<Float64Stamped>(\"\
  ~/debug/calculation_time\", 1);\n  }\n\n  // Initialize subscribers\n  traj_sub_\
  \ = this->create_subscription<Trajectory>(\n    \"~/input/trajectory\", 1, \n  \
  \  std::bind(&ObstacleCruisePlannerNode::onTrajectory, this, std::placeholders::_1));\n\
  \n  // Initialize logger and published time publisher\n  logger_configure_ = std::make_unique<autoware::universe_utils::LoggerLevelConfigure>(this);\n\
  \  published_time_publisher_ = std::make_unique<autoware::universe_utils::PublishedTimePublisher>(this);\n\
  }"
ground_truth.cpp: |-
  ObstacleCruisePlannerNode::ObstacleCruisePlannerNode(const rclcpp::NodeOptions & node_options)
  : Node("obstacle_cruise_planner", node_options),
    vehicle_info_(autoware::vehicle_info_utils::VehicleInfoUtils(*this).getVehicleInfo()),
    debug_data_ptr_(std::make_shared<DebugData>())
  {
    using std::placeholders::_1;

    // subscriber
    traj_sub_ = create_subscription<Trajectory>(
      "~/input/trajectory", rclcpp::QoS{1},
      std::bind(&ObstacleCruisePlannerNode::onTrajectory, this, _1));

    // publisher
    trajectory_pub_ = create_publisher<Trajectory>("~/output/trajectory", 1);
    vel_limit_pub_ =
      create_publisher<VelocityLimit>("~/output/velocity_limit", rclcpp::QoS{1}.transient_local());
    clear_vel_limit_pub_ = create_publisher<VelocityLimitClearCommand>(
      "~/output/clear_velocity_limit", rclcpp::QoS{1}.transient_local());

    // debug publisher
    debug_calculation_time_pub_ = create_publisher<Float64Stamped>("~/debug/processing_time_ms", 1);
    debug_cruise_wall_marker_pub_ = create_publisher<MarkerArray>("~/virtual_wall/cruise", 1);
    debug_stop_wall_marker_pub_ = create_publisher<MarkerArray>("~/virtual_wall/stop", 1);
    debug_slow_down_wall_marker_pub_ = create_publisher<MarkerArray>("~/virtual_wall/slow_down", 1);
    debug_marker_pub_ = create_publisher<MarkerArray>("~/debug/marker", 1);
    debug_stop_planning_info_pub_ =
      create_publisher<Float32MultiArrayStamped>("~/debug/stop_planning_info", 1);
    debug_cruise_planning_info_pub_ =
      create_publisher<Float32MultiArrayStamped>("~/debug/cruise_planning_info", 1);
    debug_slow_down_planning_info_pub_ =
      create_publisher<Float32MultiArrayStamped>("~/debug/slow_down_planning_info", 1);

    // tf listener
    tf_buffer_ = std::make_unique<tf2_ros::Buffer>(get_clock());
    tf_listener_ = std::make_shared<tf2_ros::TransformListener>(*tf_buffer_);

    const auto longitudinal_info = LongitudinalInfo(*this);

    ego_nearest_param_ = EgoNearestParam(*this);

    enable_debug_info_ = declare_parameter<bool>("common.enable_debug_info");
    enable_calculation_time_info_ = declare_parameter<bool>("common.enable_calculation_time_info");
    enable_slow_down_planning_ = declare_parameter<bool>("common.enable_slow_down_planning");

    use_pointcloud_for_stop_ = declare_parameter<bool>("common.stop_obstacle_type.pointcloud");
    use_pointcloud_for_slow_down_ =
      declare_parameter<bool>("common.slow_down_obstacle_type.pointcloud");
    use_pointcloud_ = use_pointcloud_for_stop_ || use_pointcloud_for_slow_down_;

    behavior_determination_param_ = BehaviorDeterminationParam(*this);

    {  // planning algorithm
      const std::string planning_algorithm_param =
        declare_parameter<std::string>("common.planning_algorithm");
      planning_algorithm_ = getPlanningAlgorithmType(planning_algorithm_param);

      if (planning_algorithm_ == PlanningAlgorithm::OPTIMIZATION_BASE) {
        planner_ptr_ = std::make_unique<OptimizationBasedPlanner>(
          *this, longitudinal_info, vehicle_info_, ego_nearest_param_, debug_data_ptr_);
      } else if (planning_algorithm_ == PlanningAlgorithm::PID_BASE) {
        planner_ptr_ = std::make_unique<PIDBasedPlanner>(
          *this, longitudinal_info, vehicle_info_, ego_nearest_param_, debug_data_ptr_);
      } else {
        throw std::logic_error("Designated algorithm is not supported.");
      }

      min_behavior_stop_margin_ = declare_parameter<double>("common.min_behavior_stop_margin");
      additional_safe_distance_margin_on_curve_ =
        declare_parameter<double>("common.stop_on_curve.additional_safe_distance_margin");
      enable_approaching_on_curve_ =
        declare_parameter<bool>("common.stop_on_curve.enable_approaching");
      min_safe_distance_margin_on_curve_ =
        declare_parameter<double>("common.stop_on_curve.min_safe_distance_margin");
      suppress_sudden_obstacle_stop_ =
        declare_parameter<bool>("common.suppress_sudden_obstacle_stop");
      planner_ptr_->setParam(
        enable_debug_info_, enable_calculation_time_info_, use_pointcloud_, min_behavior_stop_margin_,
        enable_approaching_on_curve_, additional_safe_distance_margin_on_curve_,
        min_safe_distance_margin_on_curve_, suppress_sudden_obstacle_stop_);
    }

    {  // stop/cruise/slow down obstacle type
      inside_stop_obstacle_types_ = getTargetObjectType(*this, "common.stop_obstacle_type.inside.");
      outside_stop_obstacle_types_ = getTargetObjectType(*this, "common.stop_obstacle_type.outside.");
      inside_cruise_obstacle_types_ =
        getTargetObjectType(*this, "common.cruise_obstacle_type.inside.");
      outside_cruise_obstacle_types_ =
        getTargetObjectType(*this, "common.cruise_obstacle_type.outside.");
      slow_down_obstacle_types_ = getTargetObjectType(*this, "common.slow_down_obstacle_type.");
    }

    // set parameter callback
    set_param_res_ = this->add_on_set_parameters_callback(
      std::bind(&ObstacleCruisePlannerNode::onParam, this, std::placeholders::_1));

    logger_configure_ = std::make_unique<autoware::universe_utils::LoggerLevelConfigure>(this);
    published_time_publisher_ =
      std::make_unique<autoware::universe_utils::PublishedTimePublisher>(this);
  }
architecture-codes:
  - Topic/Service Related Issues - Topic Name Mismatch
  - Topic/Service Related Issues - QoS Policy Incompatibility
  - ROS Parameter Related Issues - Use Non-exist Parameter
  - ROS Parameter Related Issues - Insufficient Parameter Design
functionality-codes:
  - Reference Error - Wrong method
  - Incomplete Code - Missing Multiple Steps
  - Conditional Checks Issues - Conditional Check Logic Misapplication
Root Cause Analysis:
  - Inadequate Comprehension of Functional Logic - Inadequate Comprehension of Functional Logic
  - Deficiencies in Domain Knowledge - Insufficient understanding of ROS Programming
  - Deficiencies in Domain Knowledge - Lack of ROS development best practices
  - Weakness in System-Level Integration - Lack of familiarity with the existing codebase