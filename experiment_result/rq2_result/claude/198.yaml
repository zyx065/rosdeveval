compilation.log: |
  Starting >>> nav2_mppi_controller
  Finished <<< nav2_mppi_controller [0.58s]

  Summary: 1 package finished [0.87s]
generate_code.cpp: |-
  bool PathHandler::isWithinInversionTolerances(const geometry_msgs::msg::PoseStamped & robot_pose)
  {
    if (global_plan_up_to_inversion_.poses.empty()) {
      return false;
    }

    // Get the last pose in the inversion path
    const auto & last_inversion_pose = global_plan_up_to_inversion_.poses.back();

    // Calculate position difference
    double dx = robot_pose.pose.position.x - last_inversion_pose.pose.position.x;
    double dy = robot_pose.pose.position.y - last_inversion_pose.pose.position.y;
    double position_distance = std::sqrt(dx * dx + dy * dy);

    // Check position tolerance
    if (position_distance > inversion_xy_tolerance_) {
      return false;
    }

    // Calculate yaw difference
    tf2::Quaternion robot_quat, target_quat;
    tf2::fromMsg(robot_pose.pose.orientation, robot_quat);
    tf2::fromMsg(last_inversion_pose.pose.orientation, target_quat);

    double robot_yaw = tf2::getYaw(robot_quat);
    double target_yaw = tf2::getYaw(target_quat);

    double yaw_diff = std::abs(robot_yaw - target_yaw);
    // Normalize yaw difference to [0, pi]
    if (yaw_diff > M_PI) {
      yaw_diff = 2 * M_PI - yaw_diff;
    }

    // Check yaw tolerance
    if (yaw_diff > inversion_yaw_tolerance) {
      return false;
    }

    return true;
  }
ground_truth.cpp: |-
  bool PathHandler::isWithinInversionTolerances(const geometry_msgs::msg::PoseStamped & robot_pose)
  {
    // Keep full path if we are within tolerance of the inversion pose
    const auto last_pose = global_plan_up_to_inversion_.poses.back();
    float distance = hypotf(
      robot_pose.pose.position.x - last_pose.pose.position.x,
      robot_pose.pose.position.y - last_pose.pose.position.y);

    float angle_distance = angles::shortest_angular_distance(
      tf2::getYaw(robot_pose.pose.orientation),
      tf2::getYaw(last_pose.pose.orientation));

    return distance <= inversion_xy_tolerance_ && fabs(angle_distance) <= inversion_yaw_tolerance;
  }
architecture-codes:
  - ROS Parameter Related Issues - Use Non-exist Parameter
functionality-codes:
  - Domain Library Issues - Lack of Domain Library Utilization
  - Reference Error - Wrong method
  - Incomplete Code - Verbose Implementation
Root Cause Analysis:
  - Deficiencies in Domain Knowledge - Lack of Knowledge of Domain-Specific Libraries
  - Deficiencies in Domain Knowledge - Lack of ROS development best practices
  - Weakness in System-Level Integration - Lack of familiarity with the existing codebase