compilation.log: |
  Starting >>> autoware_radar_object_tracker
  --- stderr: autoware_radar_object_tracker
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_radar_object_tracker/src/utils/radar_object_tracker_utils.cpp: In function ‘bool autoware::radar_object_tracker::utils::checkCloseLaneletCondition(const std::pair<double, lanelet::Lanelet>&, const TrackedObject&, double, double)’:
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_radar_object_tracker/src/utils/radar_object_tracker_utils.cpp:72:70: error: conversion from ‘lanelet::ConstLineString3d’ to non-scalar type ‘const lanelet::LineString3d’ requested
     72 |   const lanelet::LineString3d centerline = current_lanelet.centerline();
        |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~^~
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_radar_object_tracker/src/utils/radar_object_tracker_utils.cpp:94:44: error: conversion from ‘const ConstPointType’ {aka ‘const lanelet::ConstPoint3d’} to non-scalar type ‘lanelet::Point3d’ requested
     94 |   lanelet::Point3d start = centerline.front();
        |                            ~~~~~~~~~~~~~~~~^~
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_radar_object_tracker/src/utils/radar_object_tracker_utils.cpp:95:41: error: conversion from ‘const ConstPointType’ {aka ‘const lanelet::ConstPoint3d’} to non-scalar type ‘lanelet::Point3d’ requested
     95 |   lanelet::Point3d end = centerline.back();
        |                          ~~~~~~~~~~~~~~~^~
  gmake[2]: *** [CMakeFiles/autoware_radar_object_tracker_utils.dir/build.make:90: CMakeFiles/autoware_radar_object_tracker_utils.dir/src/utils/radar_object_tracker_utils.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:161: CMakeFiles/autoware_radar_object_tracker_utils.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_radar_object_tracker [8.01s, exited with code 2]

  Summary: 0 packages finished [9.39s]
    1 package failed: autoware_radar_object_tracker
    1 package had stderr output: autoware_radar_object_tracker
generate_code.cpp: |
  bool checkCloseLaneletCondition(
    const std::pair<double, lanelet::Lanelet> & lanelet,
    const autoware_perception_msgs::msg::TrackedObject & object, const double max_distance_from_lane,
    const double max_angle_diff_from_lane)
  {
    // Extract the lanelet from the pair
    const lanelet::Lanelet& current_lanelet = lanelet.second;
    
    // Get the centerline of the lanelet
    const lanelet::LineString3d centerline = current_lanelet.centerline();
    
    // Calculate the closest point on the lanelet centerline to the object's position
    lanelet::Point3d object_point(lanelet::utils::getId(), 
                                  object.kinematics.pose_with_covariance.pose.position.x,
                                  object.kinematics.pose_with_covariance.pose.position.y,
                                  object.kinematics.pose_with_covariance.pose.position.z);
    
    // Calculate the lateral distance from the object to the lanelet centerline
    double lateral_distance = lanelet::geometry::distance(centerline, object_point);
    
    // Check if lateral distance is within the maximum allowed distance
    if (lateral_distance > max_distance_from_lane) {
      return false;
    }
    
    // Extract object's orientation (yaw)
    tf2::Quaternion object_quat;
    tf2::fromMsg(object.kinematics.pose_with_covariance.pose.orientation, object_quat);
    double object_yaw = tf2::getYaw(object_quat);
    
    // Get lanelet orientation (average direction of centerline)
    lanelet::Point3d start = centerline.front();
    lanelet::Point3d end = centerline.back();
    double lanelet_yaw = std::atan2(end.y() - start.y(), end.x() - start.x());
    
    // Normalize the angle difference
    double angle_diff = autoware::universe_utils::normalizeRadian(
      std::abs(object_yaw - lanelet_yaw)
    );
    
    // Check if angle difference is within the maximum allowed angle
    return angle_diff <= max_angle_diff_from_lane;
  }
ground_truth.cpp: |-
  bool checkCloseLaneletCondition(
    const std::pair<double, lanelet::Lanelet> & lanelet,
    const autoware_perception_msgs::msg::TrackedObject & object, const double max_distance_from_lane,
    const double max_angle_diff_from_lane)
  {
    if (lanelet.second.centerline().size() <= 1) {
      return false;
    }

    lanelet::BasicPoint2d search_point(
      object.kinematics.pose_with_covariance.pose.position.x,
      object.kinematics.pose_with_covariance.pose.position.y);
    if (!lanelet::geometry::inside(lanelet.second, search_point)) {
      const auto distance = lanelet.first;
      if (distance > max_distance_from_lane) {
        return false;
      }
    }

    const double object_yaw = tf2::getYaw(object.kinematics.pose_with_covariance.pose.orientation);
    const double lane_yaw = lanelet::utils::getLaneletAngle(
      lanelet.second, object.kinematics.pose_with_covariance.pose.position);
    double object_motion_yaw = object_yaw;
    bool velocity_is_reverted = object.kinematics.twist_with_covariance.twist.linear.x < 0.0;
    if (velocity_is_reverted) {
      object_motion_yaw = autoware::universe_utils::normalizeRadian(object_yaw + M_PI);
    }
    const double delta_yaw = object_motion_yaw - lane_yaw;
    const double normalized_delta_yaw = autoware::universe_utils::normalizeRadian(delta_yaw);
    const double abs_norm_delta_yaw = std::fabs(normalized_delta_yaw);

    if (abs_norm_delta_yaw > max_angle_diff_from_lane) {
      return false;
    }

    return true;
  }
architecture-codes: []
functionality-codes:
  - Reference Error - Wrong method
  - Domain Library Issues - Domain Specific Library Utilization Error
  - Domain Library Issues - Lack of Domain Library Utilization
  - Incomplete Code - Missing Multiple Steps
  - Conditional Checks Issues - Conditional Check Missing
  - Operation/Calculation Error - Incorrect arithmetic operation
root-cause-codes:
  - Deficiencies in Domain Knowledge - Lack of Knowledge of Domain-Specific Libraries
  - Deficiencies in Domain Knowledge - Insufficient understanding of ROS Programming
  - Inadequate Comprehension of Functional Logic - Inadequate Understanding of Task Logic