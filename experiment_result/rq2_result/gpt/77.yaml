compilation.log: |
  Starting >>> autoware_behavior_path_side_shift_module
  [Processing: autoware_behavior_path_side_shift_module]
  Finished <<< autoware_behavior_path_side_shift_module [34.0s]

  Summary: 1 package finished [35.4s]
generate_code.cpp: |-
  void setOrientation(PathWithLaneId * path)
  {
    if (path == nullptr || path->points.empty()) {
      return; // Return early if the path is null or empty
    }

    auto & points = path->points;

    for (size_t i = 0; i < points.size(); ++i) {
      geometry_msgs::msg::Pose & pose = points[i].point.pose;

      if (i < points.size() - 1) {
        // Calculate orientation based on the vector to the next point
        const auto & next_pose = points[i + 1].point.pose;
        double dx = next_pose.position.x - pose.position.x;
        double dy = next_pose.position.y - pose.position.y;
        double yaw = std::atan2(dy, dx);

        pose.orientation = tf2::toMsg(tf2::Quaternion(0.0, 0.0, std::sin(yaw / 2.0), std::cos(yaw / 2.0)));
      } else if (i > 0) {
        // For the last point, calculate orientation based on the vector from the previous point
        const auto & prev_pose = points[i - 1].point.pose;
        double dx = pose.position.x - prev_pose.position.x;
        double dy = pose.position.y - prev_pose.position.y;
        double yaw = std::atan2(dy, dx);

        pose.orientation = tf2::toMsg(tf2::Quaternion(0.0, 0.0, std::sin(yaw / 2.0), std::cos(yaw / 2.0)));
      }
    }
  }
ground_truth.cpp: |-
  void setOrientation(PathWithLaneId * path)
  {
    // Reset orientation
    for (size_t idx = 0; idx < path->points.size(); ++idx) {
      double angle = 0.0;
      auto & pt = path->points.at(idx);
      if (idx + 1 < path->points.size()) {
        const auto next_pt = path->points.at(idx + 1);
        angle = std::atan2(
          next_pt.point.pose.position.y - pt.point.pose.position.y,
          next_pt.point.pose.position.x - pt.point.pose.position.x);
      } else if (idx != 0) {
        const auto prev_pt = path->points.at(idx - 1);
        angle = std::atan2(
          pt.point.pose.position.y - prev_pt.point.pose.position.y,
          pt.point.pose.position.x - prev_pt.point.pose.position.x);
      }
      tf2::Quaternion yaw_quat;
      yaw_quat.setRPY(0, 0, angle);
      pt.point.pose.orientation = tf2::toMsg(yaw_quat);
    }
  }
