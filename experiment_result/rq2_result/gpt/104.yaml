compilation.log: |
  Starting >>> autoware_universe_utils
  Finished <<< autoware_universe_utils [10.4s]

  Summary: 1 package finished [11.7s]
generate_code.cpp: |-
  geometry_msgs::msg::Polygon rotatePolygon(
    const geometry_msgs::msg::Polygon & polygon, const double & angle)
  {
    geometry_msgs::msg::Polygon rotated_polygon;

    // Precompute sine and cosine of the angle for efficiency
    double cos_angle = std::cos(angle);
    double sin_angle = std::sin(angle);

    // Iterate through each point in the polygon
    for (const auto & point : polygon.points) {
      geometry_msgs::msg::Point32 rotated_point;

      // Apply 2D rotation transformation
      rotated_point.x = point.x * cos_angle - point.y * sin_angle;
      rotated_point.y = point.x * sin_angle + point.y * cos_angle;
      rotated_point.z = point.z; // Z-coordinate remains unchanged

      // Add the rotated point to the new polygon
      rotated_polygon.points.push_back(rotated_point);
    }

    return rotated_polygon;
  }
ground_truth.cpp: |-
  geometry_msgs::msg::Polygon rotatePolygon(
    const geometry_msgs::msg::Polygon & polygon, const double & angle)
  {
    const double cos = std::cos(angle);
    const double sin = std::sin(angle);
    geometry_msgs::msg::Polygon rotated_polygon;
    for (const auto & point : polygon.points) {
      auto rotated_point = point;
      rotated_point.x = cos * point.x - sin * point.y;
      rotated_point.y = sin * point.x + cos * point.y;
      rotated_polygon.points.push_back(rotated_point);
    }
    return rotated_polygon;
  }
