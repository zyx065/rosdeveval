compilation.log: |
  Starting >>> nav2_velocity_smoother
  Finished <<< nav2_velocity_smoother [0.23s]

  Summary: 1 package finished [0.52s]
generate_code.cpp: |-
  double VelocitySmoother::applyConstraints(
    const double v_curr, const double v_cmd,
    const double accel, const double decel, const double eta)
  {
      // Ensure eta is clamped between 0 and 1
      const double clamped_eta = std::max(0.0, std::min(1.0, eta));

      // Calculate the maximum allowed velocity change based on acceleration and deceleration
      const double max_increase = accel * clamped_eta;
      const double max_decrease = decel * clamped_eta;

      // Calculate the velocity difference
      const double delta_v = v_cmd - v_curr;

      // Apply constraints to the velocity change
      double constrained_delta_v;
      if (delta_v > 0) {
          // Accelerating: limit the increase to the maximum allowed acceleration
          constrained_delta_v = std::min(delta_v, max_increase);
      } else {
          // Decelerating: limit the decrease to the maximum allowed deceleration
          constrained_delta_v = std::max(delta_v, -max_decrease);
      }

      // Compute the new constrained velocity
      const double v_constrained = v_curr + constrained_delta_v;

      return v_constrained;
  }
ground_truth.cpp: |-
  double VelocitySmoother::applyConstraints(
    const double v_curr, const double v_cmd,
    const double accel, const double decel, const double eta)
  {
    double dv = v_cmd - v_curr;

    double v_component_max;
    double v_component_min;

    // Accelerating if magnitude of v_cmd is above magnitude of v_curr
    // and if v_cmd and v_curr have the same sign (i.e. speed is NOT passing through 0.0)
    // Decelerating otherwise
    if (abs(v_cmd) >= abs(v_curr) && v_curr * v_cmd >= 0.0) {
      v_component_max = accel / smoothing_frequency_;
      v_component_min = -accel / smoothing_frequency_;
    } else {
      v_component_max = -decel / smoothing_frequency_;
      v_component_min = decel / smoothing_frequency_;
    }

    return v_curr + std::clamp(eta * dv, v_component_min, v_component_max);
  }
