compilation.log: |
  Starting >>> nav2_costmap_2d
  --- stderr: nav2_costmap_2d
  /root/repos/nav_ws/src/nav2_costmap_2d/plugins/costmap_filters/binary_filter.cpp: In member function ‘virtual void nav2_costmap_2d::BinaryFilter::process(nav2_costmap_2d::Costmap2D&, int, int, int, int, const Pose2D&)’:
  /root/repos/nav_ws/src/nav2_costmap_2d/plugins/costmap_filters/binary_filter.cpp:183:7: error: ‘costmap_ros_’ was not declared in this scope
    183 |       costmap_ros_->getTfBuffer(), mask_frame_,
        |       ^~~~~~~~~~~~
  gmake[2]: *** [CMakeFiles/filters.dir/build.make:104: CMakeFiles/filters.dir/plugins/costmap_filters/binary_filter.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:321: CMakeFiles/filters.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< nav2_costmap_2d [4.61s, exited with code 2]

  Summary: 0 packages finished [4.87s]
    1 package failed: nav2_costmap_2d
    1 package had stderr output: nav2_costmap_2d
generate_code.cpp: |-
  void BinaryFilter::process(
    nav2_costmap_2d::Costmap2D & /*master_grid*/,
    int /*min_i*/, int /*min_j*/, int /*max_i*/, int /*max_j*/,
    const geometry_msgs::msg::Pose2D & pose)
  {
    // Check if the filter mask is available
    if (!filter_mask_) {
      RCLCPP_WARN(rclcpp::get_logger("BinaryFilter"), "Filter mask is not available.");
      return;
    }

    // Transform the robot's pose to the mask frame
    geometry_msgs::msg::Pose2D transformed_pose;
    try {
      transformPose(
        costmap_ros_->getTfBuffer(), mask_frame_,
        pose, transformed_pose, 0.0);
    } catch (const std::exception &e) {
      RCLCPP_WARN(rclcpp::get_logger("BinaryFilter"), "Failed to transform pose to mask frame: %s", e.what());
      return;
    }

    // Convert the transformed pose to map coordinates
    const double wx = transformed_pose.x;
    const double wy = transformed_pose.y;

    unsigned int mx, my;
    if (!filter_mask_->info.resolution ||
        !filter_mask_->info.width ||
        !filter_mask_->info.height) {
      RCLCPP_WARN(rclcpp::get_logger("BinaryFilter"), "Invalid filter mask metadata.");
      return;
    }

    const double resolution = filter_mask_->info.resolution;
    const double origin_x = filter_mask_->info.origin.position.x;
    const double origin_y = filter_mask_->info.origin.position.y;

    mx = static_cast<unsigned int>((wx - origin_x) / resolution);
    my = static_cast<unsigned int>((wy - origin_y) / resolution);

    // Check if the map coordinates are within bounds
    if (mx >= filter_mask_->info.width || my >= filter_mask_->info.height) {
      RCLCPP_WARN(rclcpp::get_logger("BinaryFilter"), "Robot is out of the filter mask bounds.");
      return;
    }

    // Get the mask value at the robot's position
    const int8_t mask_value = getMaskData(filter_mask_, mx, my);

    // Check if the mask value exceeds the flip threshold
    bool new_state = default_state_;
    if (mask_value > flip_threshold_) {
      new_state = !default_state_;
    }

    // Update the binary state if it has changed
    if (new_state != binary_state_) {
      changeState(new_state);
    }
  }
ground_truth.cpp: |-
  void BinaryFilter::process(
    nav2_costmap_2d::Costmap2D & /*master_grid*/,
    int /*min_i*/, int /*min_j*/, int /*max_i*/, int /*max_j*/,
    const geometry_msgs::msg::Pose2D & pose)
  {
    std::lock_guard<CostmapFilter::mutex_t> guard(*getMutex());

    if (!filter_mask_) {
      // Show warning message every 2 seconds to not litter an output
      RCLCPP_WARN_THROTTLE(
        logger_, *(clock_), 2000,
        "BinaryFilter: Filter mask was not received");
      return;
    }

    geometry_msgs::msg::Pose2D mask_pose;  // robot coordinates in mask frame

    // Transforming robot pose from current layer frame to mask frame
    if (!transformPose(global_frame_, pose, mask_frame_, mask_pose)) {
      return;
    }

    // Converting mask_pose robot position to filter_mask_ indexes (mask_robot_i, mask_robot_j)
    unsigned int mask_robot_i, mask_robot_j;
    if (!worldToMask(filter_mask_, mask_pose.x, mask_pose.y, mask_robot_i, mask_robot_j)) {
      // Robot went out of mask range. Set "false" state by-default
      RCLCPP_WARN(
        logger_,
        "BinaryFilter: Robot is outside of filter mask. Resetting binary state to default.");
      changeState(default_state_);
      return;
    }

    // Getting filter_mask data from cell where the robot placed
    int8_t mask_data = getMaskData(filter_mask_, mask_robot_i, mask_robot_j);
    if (mask_data == nav2_util::OCC_GRID_UNKNOWN) {
      // Corresponding filter mask cell is unknown.
      // Warn and do nothing.
      RCLCPP_WARN_THROTTLE(
        logger_, *(clock_), 2000,
        "BinaryFilter: Filter mask [%i, %i] data is unknown. Do nothing.",
        mask_robot_i, mask_robot_j);
      return;
    }
    // Check and flip binary state, if necessary
    if (base_ + mask_data * multiplier_ > flip_threshold_) {
      if (binary_state_ == default_state_) {
        changeState(!default_state_);
      }
    } else {
      if (binary_state_ != default_state_) {
        changeState(default_state_);
      }
    }
  }
