compilation.log: |
  Starting >>> autoware_map_based_prediction
  --- stderr: autoware_map_based_prediction
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_map_based_prediction/src/path_generator.cpp: In member function ‘autoware_perception_msgs::msg::PredictedPath autoware::map_based_prediction::PathGenerator::generatePathToTargetPoint(const TrackedObject&, const Vector2d&) const’:
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_map_based_prediction/src/path_generator.cpp:66:43: error: ‘const TrackedObject’ {aka ‘const struct autoware_perception_msgs::msg::TrackedObject_<std::allocator<void> >’} has no member named ‘pose’
     66 |   Eigen::Vector2d current_position(object.pose.position.x, object.pose.position.y);
        |                                           ^~~~
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_map_based_prediction/src/path_generator.cpp:66:67: error: ‘const TrackedObject’ {aka ‘const struct autoware_perception_msgs::msg::TrackedObject_<std::allocator<void> >’} has no member named ‘pose’
     66 |   Eigen::Vector2d current_position(object.pose.position.x, object.pose.position.y);
        |                                                                   ^~~~
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_map_based_prediction/src/path_generator.cpp:67:35: error: ‘const TrackedObject’ {aka ‘const struct autoware_perception_msgs::msg::TrackedObject_<std::allocator<void> >’} has no member named ‘velocity’
     67 |   Eigen::Vector2d velocity(object.velocity.x, object.velocity.y);
        |                                   ^~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_map_based_prediction/src/path_generator.cpp:67:54: error: ‘const TrackedObject’ {aka ‘const struct autoware_perception_msgs::msg::TrackedObject_<std::allocator<void> >’} has no member named ‘velocity’
     67 |   Eigen::Vector2d velocity(object.velocity.x, object.velocity.y);
        |                                                      ^~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_map_based_prediction/src/path_generator.cpp:89:39: error: ‘using element_type = class autoware::universe_utils::TimeKeeper’ {aka ‘class autoware::universe_utils::TimeKeeper’} has no member named ‘getCurrentTime’
     89 |   double current_time = time_keeper_->getCurrentTime();
        |                                       ^~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_map_based_prediction/src/path_generator.cpp:106:30: error: ‘const TrackedObject’ {aka ‘const struct autoware_perception_msgs::msg::TrackedObject_<std::allocator<void> >’} has no member named ‘pose’
    106 |     pose.position.z = object.pose.position.z; // Maintain the object's current z position
        |                              ^~~~
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_map_based_prediction/src/path_generator.cpp:107:24: error: ‘createQuaternionFromYaw’ was not declared in this scope; did you mean ‘autoware::universe_utils::createQuaternionFromYaw’?
    107 |     pose.orientation = createQuaternionFromYaw(yaw);
        |                        ^~~~~~~~~~~~~~~~~~~~~~~
        |                        autoware::universe_utils::createQuaternionFromYaw
  In file included from /workspace/repos/autoware/install/autoware_interpolation/include/autoware/interpolation/spline_interpolation.hpp:19,
                   from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_map_based_prediction/src/path_generator.cpp:18:
  /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/geometry/geometry.hpp:314:32: note: ‘autoware::universe_utils::createQuaternionFromYaw’ declared here
    314 | geometry_msgs::msg::Quaternion createQuaternionFromYaw(const double yaw);
        |                                ^~~~~~~~~~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_map_based_prediction/src/path_generator.cpp:110:20: error: ‘using PredictedPath = struct autoware_perception_msgs::msg::PredictedPath_<std::allocator<void> >’ {aka ‘struct autoware_perception_msgs::msg::PredictedPath_<std::allocator<void> >’} has no member named ‘poses’
    110 |     predicted_path.poses.push_back(pose);
        |                    ^~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_map_based_prediction/src/path_generator.cpp:117:18: error: ‘using PredictedPath = struct autoware_perception_msgs::msg::PredictedPath_<std::allocator<void> >’ {aka ‘struct autoware_perception_msgs::msg::PredictedPath_<std::allocator<void> >’} has no member named ‘start_time’
    117 |   predicted_path.start_time = current_time;
        |                  ^~~~~~~~~~
  gmake[2]: *** [CMakeFiles/map_based_prediction_node.dir/build.make:90: CMakeFiles/map_based_prediction_node.dir/src/path_generator.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:159: CMakeFiles/map_based_prediction_node.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_map_based_prediction [6.94s, exited with code 2]

  Summary: 0 packages finished [8.36s]
    1 package failed: autoware_map_based_prediction
    1 package had stderr output: autoware_map_based_prediction
generate_code.cpp: |-
  PredictedPath PathGenerator::generatePathToTargetPoint(
    const TrackedObject & object, const Eigen::Vector2d & point) const
  {
    // Initialize the predicted path
    PredictedPath predicted_path;

    // Extract the current position and velocity of the object
    Eigen::Vector2d current_position(object.pose.position.x, object.pose.position.y);
    Eigen::Vector2d velocity(object.velocity.x, object.velocity.y);

    // Calculate the direction vector toward the target point
    Eigen::Vector2d direction = point - current_position;
    double distance_to_target = direction.norm();

    // Normalize the direction vector
    if (distance_to_target > 0.0) {
      direction.normalize();
    } else {
      // If the object is already at the target point, return an empty path
      return predicted_path;
    }

    // Calculate the yaw angle based on the direction vector
    double yaw = std::atan2(direction.y(), direction.x());

    // Define the time step and maximum prediction duration
    const double time_step = 0.1; // seconds
    const double max_duration = 5.0; // seconds

    // Get the current time from the time keeper
    double current_time = time_keeper_->getCurrentTime();

    // Initialize the time variable
    double time = 0.0;

    // Generate poses along the path
    while (time < max_duration && distance_to_target > 0.0) {
      // Calculate the predicted position at the current time step
      Eigen::Vector2d predicted_position = current_position + velocity * time;

      // Update the distance to the target
      distance_to_target = (point - predicted_position).norm();

      // Create a pose for the predicted position
      geometry_msgs::msg::Pose pose;
      pose.position.x = predicted_position.x();
      pose.position.y = predicted_position.y();
      pose.position.z = object.pose.position.z; // Maintain the object's current z position
      pose.orientation = createQuaternionFromYaw(yaw);

      // Add the pose to the predicted path
      predicted_path.poses.push_back(pose);

      // Increment the time
      time += time_step;
    }

    // Set the start time of the predicted path
    predicted_path.start_time = current_time;

    return predicted_path;
  }
ground_truth.cpp: |-
  PredictedPath PathGenerator::generatePathToTargetPoint(
    const TrackedObject & object, const Eigen::Vector2d & point) const
  {
    std::unique_ptr<ScopedTimeTrack> st_ptr;
    if (time_keeper_) st_ptr = std::make_unique<ScopedTimeTrack>(__func__, *time_keeper_);

    PredictedPath predicted_path{};
    const double ep = 0.001;

    const auto & obj_pos = object.kinematics.pose_with_covariance.pose.position;
    const auto & obj_vel = object.kinematics.twist_with_covariance.twist.linear;

    const Eigen::Vector2d pedestrian_to_entry_point(point.x() - obj_pos.x, point.y() - obj_pos.y);
    const auto velocity = std::max(std::hypot(obj_vel.x, obj_vel.y), min_crosswalk_user_velocity_);
    const auto arrival_time = pedestrian_to_entry_point.norm() / velocity;

    const auto pedestrian_to_entry_point_normalized = pedestrian_to_entry_point.normalized();
    const auto pedestrian_to_entry_point_orientation =
      autoware::universe_utils::createQuaternionFromYaw(std::atan2(
        pedestrian_to_entry_point_normalized.y(), pedestrian_to_entry_point_normalized.x()));

    for (double dt = 0.0; dt < arrival_time + ep; dt += sampling_time_interval_) {
      geometry_msgs::msg::Pose world_frame_pose;
      world_frame_pose.position.x =
        obj_pos.x + velocity * pedestrian_to_entry_point_normalized.x() * dt;
      world_frame_pose.position.y =
        obj_pos.y + velocity * pedestrian_to_entry_point_normalized.y() * dt;
      world_frame_pose.position.z = obj_pos.z;
      world_frame_pose.orientation = pedestrian_to_entry_point_orientation;
      predicted_path.path.push_back(world_frame_pose);
      if (predicted_path.path.size() >= predicted_path.path.max_size()) {
        break;
      }
    }

    predicted_path.confidence = 1.0;
    predicted_path.time_step = rclcpp::Duration::from_seconds(sampling_time_interval_);

    return predicted_path;
  }
