compilation.log: |
  Starting >>> autoware_motion_velocity_dynamic_obstacle_stop_module
  --- stderr: autoware_motion_velocity_dynamic_obstacle_stop_module
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp: In function ‘bool autoware::motion_velocity_planner::dynamic_obstacle_stop::is_not_too_close(const PredictedObject&, const autoware::motion_velocity_planner::dynamic_obstacle_stop::EgoData&, const double&)’:
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp:63:25: error: ‘const TrajectoryPoints’ {aka ‘const class std::vector<autoware_planning_msgs::msg::TrajectoryPoint_<std::allocator<void> > >’} has no member named ‘points’; did you mean ‘pointer’?
     63 |     ego_data.trajectory.points, object_position);
        |                         ^~~~~~
        |                         pointer
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp:72:25: error: ‘const TrajectoryPoints’ {aka ‘const class std::vector<autoware_planning_msgs::msg::TrajectoryPoint_<std::allocator<void> > >’} has no member named ‘points’; did you mean ‘pointer’?
     72 |     ego_data.trajectory.points, ego_data.current_index, closest_idx);
        |                         ^~~~~~
        |                         pointer
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp:72:42: error: ‘const struct autoware::motion_velocity_planner::dynamic_obstacle_stop::EgoData’ has no member named ‘current_index’
     72 |     ego_data.trajectory.points, ego_data.current_index, closest_idx);
        |                                          ^~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp:78:39: error: ‘const struct autoware::motion_velocity_planner::dynamic_obstacle_stop::EgoData’ has no member named ‘safe_distance_threshold’
     78 |   return signed_arc_length > ego_data.safe_distance_threshold;
        |                                       ^~~~~~~~~~~~~~~~~~~~~~~
  gmake[2]: *** [CMakeFiles/autoware_motion_velocity_dynamic_obstacle_stop_module.dir/build.make:132: CMakeFiles/autoware_motion_velocity_dynamic_obstacle_stop_module.dir/src/object_filtering.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:157: CMakeFiles/autoware_motion_velocity_dynamic_obstacle_stop_module.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_motion_velocity_dynamic_obstacle_stop_module [10.1s, exited with code 2]

  Summary: 0 packages finished [11.5s]
    1 package failed: autoware_motion_velocity_dynamic_obstacle_stop_module
    1 package had stderr output: autoware_motion_velocity_dynamic_obstacle_stop_module
generate_code.cpp: |-
  bool is_not_too_close(
    const autoware_perception_msgs::msg::PredictedObject & object, const EgoData & ego_data,
    const double & ego_longitudinal_offset)
  {
    // Extract the object's position
    const auto & object_position = object.kinematics.initial_pose_with_covariance.pose.position;

    // Find the closest point on the ego trajectory to the object's position
    size_t closest_idx = motion_utils::findNearestIndex(
      ego_data.trajectory.points, object_position);

    if (!closest_idx) {
      // If no valid closest index is found, return true (object is not considered too close)
      return true;
    }

    // Calculate the signed arc length from the ego vehicle's current position to the closest point
    double signed_arc_length = motion_utils::calcSignedArcLength(
      ego_data.trajectory.points, ego_data.current_index, closest_idx);

    // Adjust the signed arc length by the ego longitudinal offset
    signed_arc_length -= ego_longitudinal_offset;

    // Check if the object is beyond the safe distance threshold
    return signed_arc_length > ego_data.safe_distance_threshold;
  }
ground_truth.cpp: |-
  bool is_not_too_close(
    const autoware_perception_msgs::msg::PredictedObject & object, const EgoData & ego_data,
    const double & ego_longitudinal_offset)
  {
    const auto obj_arc_length = motion_utils::calcSignedArcLength(
      ego_data.trajectory, ego_data.pose.position,
      object.kinematics.initial_pose_with_covariance.pose.position);
    return std::abs(obj_arc_length) > ego_data.longitudinal_offset_to_first_trajectory_idx +
                                        ego_longitudinal_offset + object.shape.dimensions.x / 2.0;
  }
