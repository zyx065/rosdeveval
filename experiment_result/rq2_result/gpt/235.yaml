compilation.log: |
  Starting >>> autoware_trajectory_follower_node
  --- stderr: autoware_trajectory_follower_node
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp: In member function ‘void autoware::motion::control::trajectory_follower_node::Controller::callbackTimerControl()’:
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:209:8: error: ‘input_data_’ was not declared in this scope; did you mean ‘InputData’?
    209 |   if (!input_data_.current_trajectory.points.empty() &&
        |        ^~~~~~~~~~~
        |        InputData
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:216:55: error: ‘class std::shared_ptr<autoware::motion::control::trajectory_follower::LateralControllerBase>’ has no member named ‘isReady’
    216 |     const bool is_lateral_ready = lateral_controller_.isReady(input_data_);
        |                                                       ^~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:217:65: error: ‘class std::shared_ptr<autoware::motion::control::trajectory_follower::LongitudinalControllerBase>’ has no member named ‘isReady’
    217 |     const bool is_longitudinal_ready = longitudinal_controller_.isReady(input_data_);
        |                                                                 ^~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:221:55: error: ‘class std::shared_ptr<autoware::motion::control::trajectory_follower::LateralControllerBase>’ has no member named ‘run’
    221 |       const auto lateral_output = lateral_controller_.run(input_data_);
        |                                                       ^~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:224:65: error: ‘class std::shared_ptr<autoware::motion::control::trajectory_follower::LongitudinalControllerBase>’ has no member named ‘run’
    224 |       const auto longitudinal_output = longitudinal_controller_.run(input_data_);
        |                                                                 ^~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:227:27: error: ‘class std::shared_ptr<autoware::motion::control::trajectory_follower::LateralControllerBase>’ has no member named ‘sync’
    227 |       lateral_controller_.sync(longitudinal_output.sync_data);
        |                           ^~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_trajectory_follower_node/src/controller_node.cpp:228:32: error: ‘class std::shared_ptr<autoware::motion::control::trajectory_follower::LongitudinalControllerBase>’ has no member named ‘sync’
    228 |       longitudinal_controller_.sync(lateral_output.sync_data);
        |                                ^~~~
  gmake[2]: *** [CMakeFiles/controller_node.dir/build.make:76: CMakeFiles/controller_node.dir/src/controller_node.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:163: CMakeFiles/controller_node.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_trajectory_follower_node [11.7s, exited with code 2]

  Summary: 0 packages finished [13.2s]
    1 package failed: autoware_trajectory_follower_node
    1 package had stderr output: autoware_trajectory_follower_node
generate_code.cpp: "void Controller::callbackTimerControl()\n{\n  // Input data validation\n\
  \  if (!input_data_.current_trajectory.points.empty() &&\n      input_data_.current_odometry.header.stamp\
  \ != rclcpp::Time(0) &&\n      input_data_.current_steering.stamp != rclcpp::Time(0)\
  \ &&\n      input_data_.current_accel.header.stamp != rclcpp::Time(0) &&\n     \
  \ input_data_.current_operation_mode.stamp != rclcpp::Time(0)) {\n    \n    // Check\
  \ if controllers are ready\n    const bool is_lateral_ready = lateral_controller_.isReady(input_data_);\n\
  \    const bool is_longitudinal_ready = longitudinal_controller_.isReady(input_data_);\n\
  \n    if (is_lateral_ready && is_longitudinal_ready) {\n      // Run lateral controller\n\
  \      const auto lateral_output = lateral_controller_.run(input_data_);\n\n   \
  \   // Run longitudinal controller\n      const auto longitudinal_output = longitudinal_controller_.run(input_data_);\n\
  \n      // Synchronize controllers\n      lateral_controller_.sync(longitudinal_output.sync_data);\n\
  \      longitudinal_controller_.sync(lateral_output.sync_data);\n\n      // Merge\
  \ control horizons\n      const auto control_horizon = mergeLatLonHorizon(\n   \
  \     lateral_output.control_cmd_horizon,\n        longitudinal_output.control_cmd_horizon,\n\
  \        input_data_.current_odometry.header.stamp);\n\n      if (control_horizon)\
  \ {\n        // Publish control commands\n        control_cmd_pub_->publish(control_horizon->control_cmd);\n\
  \n        // Publish debug markers\n        publishDebugMarker(input_data_, lateral_output);\n\
  \      }\n    }\n  }\n}"
ground_truth.cpp: |-
  void Controller::callbackTimerControl()
  {
    // 1. create input data
    const auto input_data = createInputData(*get_clock());
    if (!input_data) {
      RCLCPP_INFO_THROTTLE(
        get_logger(), *get_clock(), 5000, "Control is skipped since input data is not ready.");
      return;
    }

    // 2. check if controllers are ready
    const bool is_lat_ready = lateral_controller_->isReady(*input_data);
    const bool is_lon_ready = longitudinal_controller_->isReady(*input_data);
    if (!is_lat_ready || !is_lon_ready) {
      RCLCPP_INFO_THROTTLE(
        get_logger(), *get_clock(), 5000,
        "Control is skipped since lateral and/or longitudinal controllers are not ready to run.");
      return;
    }

    // 3. run controllers
    stop_watch_.tic("lateral");
    const auto lat_out = lateral_controller_->run(*input_data);
    publishProcessingTime(stop_watch_.toc("lateral"), pub_processing_time_lat_ms_);

    stop_watch_.tic("longitudinal");
    const auto lon_out = longitudinal_controller_->run(*input_data);
    publishProcessingTime(stop_watch_.toc("longitudinal"), pub_processing_time_lon_ms_);

    // 4. sync with each other controllers
    longitudinal_controller_->sync(lat_out.sync_data);
    lateral_controller_->sync(lon_out.sync_data);

    // TODO(Horibe): Think specification. This comes from the old implementation.
    if (isTimeOut(lon_out, lat_out)) return;

    // 5. publish control command
    autoware_control_msgs::msg::Control out;
    out.stamp = this->now();
    out.lateral = lat_out.control_cmd;
    out.longitudinal = lon_out.control_cmd;
    control_cmd_pub_->publish(out);

    // 6. publish debug
    published_time_publisher_->publish_if_subscribed(control_cmd_pub_, out.stamp);
    publishDebugMarker(*input_data, lat_out);

    // 7. publish experimental topic
    if (enable_control_cmd_horizon_pub_) {
      const auto control_horizon =
        mergeLatLonHorizon(lat_out.control_cmd_horizon, lon_out.control_cmd_horizon, this->now());
      if (control_horizon.has_value()) {
        control_cmd_horizon_pub_->publish(control_horizon.value());
      }
    }
  }
