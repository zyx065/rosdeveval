compilation.log: |
  Starting >>> autoware_pid_longitudinal_controller
  Finished <<< autoware_pid_longitudinal_controller [13.3s]

  Summary: 1 package finished [14.7s]
generate_code.cpp: |-
  double getPitchByTraj(
    const Trajectory & trajectory, const size_t start_idx, const double wheel_base)
  {
    // Check if the trajectory has enough points for calculation
    if (trajectory.points.size() <= start_idx + 1) {
      return 0.0; // Not enough points to calculate pitch
    }

    // Accumulate distance along the trajectory until it exceeds the wheel_base
    double accumulated_distance = 0.0;
    size_t end_idx = start_idx;

    for (size_t i = start_idx; i < trajectory.points.size() - 1; ++i) {
      const auto & current_point = trajectory.points[i].pose.position;
      const auto & next_point = trajectory.points[i + 1].pose.position;

      // Calculate the 3D distance between consecutive points
      accumulated_distance += autoware::universe_utils::calcDistance3d(current_point, next_point);

      // Check if the accumulated distance exceeds the wheel_base
      if (accumulated_distance >= wheel_base) {
        end_idx = i + 1;
        break;
      }
    }

    // If the accumulated distance is less than the wheel_base, return 0.0
    if (end_idx == start_idx) {
      return 0.0;
    }

    // Calculate the pitch angle using the elevation angle between start and end points
    const auto & start_point = trajectory.points[start_idx].pose.position;
    const auto & end_point = trajectory.points[end_idx].pose.position;

    return autoware::universe_utils::calcElevationAngle(start_point, end_point);
  }
ground_truth.cpp: |-
  double getPitchByTraj(
    const Trajectory & trajectory, const size_t start_idx, const double wheel_base)
  {
    // cannot calculate pitch
    if (trajectory.points.size() <= 1) {
      return 0.0;
    }

    const auto [prev_idx, next_idx] = [&]() {
      for (size_t i = start_idx + 1; i < trajectory.points.size(); ++i) {
        const double dist = autoware::universe_utils::calcDistance3d(
          trajectory.points.at(start_idx), trajectory.points.at(i));
        if (dist > wheel_base) {
          // calculate pitch from trajectory between rear wheel (nearest) and front center (i)
          return std::make_pair(start_idx, i);
        }
      }
      // NOTE: The ego pose is close to the goal.
      return std::make_pair(
        std::min(start_idx, trajectory.points.size() - 2), trajectory.points.size() - 1);
    }();

    return autoware::universe_utils::calcElevationAngle(
      trajectory.points.at(prev_idx).pose.position, trajectory.points.at(next_idx).pose.position);
  }
