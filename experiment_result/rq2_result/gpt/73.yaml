compilation.log: |
  Starting >>> autoware_autonomous_emergency_braking
  [Processing: autoware_autonomous_emergency_braking]
  Finished <<< autoware_autonomous_emergency_braking [41.7s]

  Summary: 1 package finished [43.0s]
generate_code.cpp: |-
  bool AEB::hasCollision(const double current_v, const ObjectData & closest_object)
  {
      // Calculate the RSS (Response Safety Space) distance
      double rss_distance = current_v * current_v / (2.0 * 9.8); // Assuming deceleration due to gravity (9.8 m/s^2)

      // Publish the RSS distance for debugging
      if (debug_rss_distance_publisher_) {
          auto debug_msg = tier4_debug_msgs::msg::Float32Stamped();
          debug_msg.stamp = closest_object.stamp;
          debug_msg.data = rss_distance;
          debug_rss_distance_publisher_->publish(debug_msg);
      }

      // Check if the closest object is a target and within the RSS distance
      if (closest_object.is_target && closest_object.distance_to_object <= rss_distance) {
          // Update collision data
          collision_data_keeper_.setCollisionData(closest_object);
          return true; // Collision detected
      }

      return false; // No collision
  }
ground_truth.cpp: |-
  bool AEB::hasCollision(const double current_v, const ObjectData & closest_object)
  {
    autoware::universe_utils::ScopedTimeTrack st(__func__, *time_keeper_);
    const double rss_dist = std::invoke([&]() {
      const double & obj_v = closest_object.velocity;
      const double & t = t_response_;
      const double pre_braking_covered_distance = std::abs(current_v) * t;
      const double braking_distance = (current_v * current_v) / (2 * std::fabs(a_ego_min_));
      const double ego_stopping_distance = pre_braking_covered_distance + braking_distance;
      const double obj_braking_distance = (obj_v > 0.0)
                                            ? -(obj_v * obj_v) / (2 * std::fabs(a_obj_min_))
                                            : (obj_v * obj_v) / (2 * std::fabs(a_obj_min_));
      return ego_stopping_distance + obj_braking_distance + longitudinal_offset_margin_;
    });

    tier4_debug_msgs::msg::Float32Stamped rss_distance_msg;
    rss_distance_msg.stamp = get_clock()->now();
    rss_distance_msg.data = rss_dist;
    debug_rss_distance_publisher_->publish(rss_distance_msg);

    if (closest_object.distance_to_object > rss_dist) return false;

    // collision happens
    ObjectData collision_data = closest_object;
    collision_data.rss = rss_dist;
    collision_data_keeper_.setCollisionData(collision_data);
    return true;
  }
