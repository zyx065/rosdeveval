compilation.log: "Starting >>> autoware_ground_segmentation\n--- stderr: autoware_ground_segmentation\n\
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_ground_segmentation/src/scan_ground_filter/node.cpp:\
  \ In constructor ‘autoware::ground_segmentation::ScanGroundFilterComponent::ScanGroundFilterComponent(const\
  \ rclcpp::NodeOptions&)’:\n/workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_ground_segmentation/src/scan_ground_filter/node.cpp:50:29:\
  \ error: ‘autoware::common’ has not been declared\n   50 |   vehicle_info_ = autoware::common::vehicle_info::VehicleInfo{\n\
  \      |                             ^~~~~~\n/workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_ground_segmentation/src/scan_ground_filter/node.cpp:\
  \ In lambda function:\n/workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_ground_segmentation/src/scan_ground_filter/node.cpp:106:39:\
  \ error: ‘class autoware::ground_segmentation::GridGroundFilter’ has no member named\
  \ ‘update_parameters’\n  106 |       return grid_ground_filter_ptr_->update_parameters(parameters);\n\
  \      |                                       ^~~~~~~~~~~~~~~~~\n/workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_ground_segmentation/src/scan_ground_filter/node.cpp:\
  \ In constructor ‘autoware::ground_segmentation::ScanGroundFilterComponent::ScanGroundFilterComponent(const\
  \ rclcpp::NodeOptions&)’:\n/workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_ground_segmentation/src/scan_ground_filter/node.cpp:104:50:\
  \ error: cannot convert ‘autoware::ground_segmentation::ScanGroundFilterComponent::ScanGroundFilterComponent(const\
  \ rclcpp::NodeOptions&)::<lambda(const std::vector<rclcpp::Parameter>&)>’ to ‘rclcpp::Node::OnParametersSetCallbackType’\
  \ {aka ‘std::function<rcl_interfaces::msg::SetParametersResult_<std::allocator<void>\
  \ >(const std::vector<rclcpp::Parameter>&)>’}\n  104 |   set_param_res_ = add_on_set_parameters_callback(\n\
  \      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n  105 |     [this](const\
  \ std::vector<rclcpp::Parameter> & parameters) {\n      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
  \  106 |       return grid_ground_filter_ptr_->update_parameters(parameters);\n\
  \      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
  \  107 |     });\n      |     ~~                                            \nIn\
  \ file included from /opt/ros/humble/include/rclcpp/rclcpp/executors/single_threaded_executor.hpp:28,\n\
  \                 from /opt/ros/humble/include/rclcpp/rclcpp/executors.hpp:22,\n\
  \                 from /opt/ros/humble/include/rclcpp/rclcpp/rclcpp.hpp:155,\n \
  \                from /opt/ros/humble/include/pcl_conversions/pcl_conversions/pcl_conversions.h:43,\n\
  \                 from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_ground_segmentation/src/scan_ground_filter/data.hpp:20,\n\
  \                 from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_ground_segmentation/src/scan_ground_filter/node.hpp:18,\n\
  \                 from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_ground_segmentation/src/scan_ground_filter/node.cpp:15:\n\
  /opt/ros/humble/include/rclcpp/rclcpp/node.hpp:934:62: note:   initializing argument\
  \ 1 of ‘rclcpp::node_interfaces::OnSetParametersCallbackHandle::SharedPtr rclcpp::Node::add_on_set_parameters_callback(rclcpp::Node::OnParametersSetCallbackType)’\n\
  \  934 |   add_on_set_parameters_callback(OnParametersSetCallbackType callback);\n\
  \      |                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~\n\
  In file included from /usr/include/c++/11/memory:76,\n                 from /opt/ros/humble/include/sensor_msgs/sensor_msgs/msg/detail/point_cloud2__struct.hpp:10,\n\
  \                 from /opt/ros/humble/include/sensor_msgs/sensor_msgs/msg/point_cloud2.hpp:7,\n\
  \                 from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_ground_segmentation/src/scan_ground_filter/data.hpp:18,\n\
  \                 from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_ground_segmentation/src/scan_ground_filter/node.hpp:18,\n\
  \                 from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_ground_segmentation/src/scan_ground_filter/node.cpp:15:\n\
  /usr/include/c++/11/bits/unique_ptr.h: In instantiation of ‘typename std::_MakeUniq<_Tp>::__single_object\
  \ std::make_unique(_Args&& ...) [with _Tp = autoware::universe_utils::DebugPublisher;\
  \ _Args = {autoware::ground_segmentation::ScanGroundFilterComponent*}; typename\
  \ std::_MakeUniq<_Tp>::__single_object = std::unique_ptr<autoware::universe_utils::DebugPublisher>]’:\n\
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_ground_segmentation/src/scan_ground_filter/node.cpp:76:84:\
  \   required from here\n/usr/include/c++/11/bits/unique_ptr.h:962:30: error: no\
  \ matching function for call to ‘autoware::universe_utils::DebugPublisher::DebugPublisher(autoware::ground_segmentation::ScanGroundFilterComponent*)’\n\
  \  962 |     { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...));\
  \ }\n      |                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
  In file included from /workspace/repos/autoware/install/autoware_pointcloud_preprocessor/include/autoware_pointcloud_preprocessor/autoware/pointcloud_preprocessor/filter.hpp:78,\n\
  \                 from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_ground_segmentation/src/scan_ground_filter/node.hpp:21,\n\
  \                 from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_ground_segmentation/src/scan_ground_filter/node.cpp:15:\n\
  /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/ros/debug_publisher.hpp:49:12:\
  \ note: candidate: ‘autoware::universe_utils::DebugPublisher::DebugPublisher(rclcpp::Node*,\
  \ const char*)’\n   49 |   explicit DebugPublisher(rclcpp::Node * node, const char\
  \ * ns) : node_(node), ns_(ns) {}\n      |            ^~~~~~~~~~~~~~\n/workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/ros/debug_publisher.hpp:49:12:\
  \ note:   candidate expects 2 arguments, 1 provided\n/workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/ros/debug_publisher.hpp:46:7:\
  \ note: candidate: ‘autoware::universe_utils::DebugPublisher::DebugPublisher(const\
  \ autoware::universe_utils::DebugPublisher&)’\n   46 | class DebugPublisher\n  \
  \    |       ^~~~~~~~~~~~~~\n/workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/ros/debug_publisher.hpp:46:7:\
  \ note:   no known conversion for argument 1 from ‘autoware::ground_segmentation::ScanGroundFilterComponent*’\
  \ to ‘const autoware::universe_utils::DebugPublisher&’\n/workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/ros/debug_publisher.hpp:46:7:\
  \ note: candidate: ‘autoware::universe_utils::DebugPublisher::DebugPublisher(autoware::universe_utils::DebugPublisher&&)’\n\
  /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/ros/debug_publisher.hpp:46:7:\
  \ note:   no known conversion for argument 1 from ‘autoware::ground_segmentation::ScanGroundFilterComponent*’\
  \ to ‘autoware::universe_utils::DebugPublisher&&’\nIn file included from /usr/include/c++/11/memory:76,\n\
  \                 from /opt/ros/humble/include/sensor_msgs/sensor_msgs/msg/detail/point_cloud2__struct.hpp:10,\n\
  \                 from /opt/ros/humble/include/sensor_msgs/sensor_msgs/msg/point_cloud2.hpp:7,\n\
  \                 from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_ground_segmentation/src/scan_ground_filter/data.hpp:18,\n\
  \                 from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_ground_segmentation/src/scan_ground_filter/node.hpp:18,\n\
  \                 from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_ground_segmentation/src/scan_ground_filter/node.cpp:15:\n\
  /usr/include/c++/11/bits/unique_ptr.h: In instantiation of ‘typename std::_MakeUniq<_Tp>::__single_object\
  \ std::make_unique(_Args&& ...) [with _Tp = autoware::ground_segmentation::GridGroundFilter;\
  \ _Args = {bool&, long unsigned int&, float&, float&, float&, autoware::vehicle_info_utils::VehicleInfo&,\
  \ bool&, float&, bool&, bool&, float&, float&, float&, float&, float&, float&, short\
  \ unsigned int&, float&}; typename std::_MakeUniq<_Tp>::__single_object = std::unique_ptr<autoware::ground_segmentation::GridGroundFilter>]’:\n\
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_ground_segmentation/src/scan_ground_filter/node.cpp:82:63:\
  \   required from here\n/usr/include/c++/11/bits/unique_ptr.h:962:30: error: no\
  \ matching function for call to ‘autoware::ground_segmentation::GridGroundFilter::GridGroundFilter(bool&,\
  \ long unsigned int&, float&, float&, float&, autoware::vehicle_info_utils::VehicleInfo&,\
  \ bool&, float&, bool&, bool&, float&, float&, float&, float&, float&, float&, short\
  \ unsigned int&, float&)’\n  962 |     { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...));\
  \ }\n      |                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
  In file included from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_ground_segmentation/src/scan_ground_filter/node.hpp:19,\n\
  \                 from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_ground_segmentation/src/scan_ground_filter/node.cpp:15:\n\
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_ground_segmentation/src/scan_ground_filter/grid_ground_filter.hpp:156:12:\
  \ note: candidate: ‘autoware::ground_segmentation::GridGroundFilter::GridGroundFilter(autoware::ground_segmentation::GridGroundFilterParameter&)’\n\
  \  156 |   explicit GridGroundFilter(GridGroundFilterParameter & param) : param_(param)\n\
  \      |            ^~~~~~~~~~~~~~~~\n/workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_ground_segmentation/src/scan_ground_filter/grid_ground_filter.hpp:156:12:\
  \ note:   candidate expects 1 argument, 18 provided\ngmake[2]: *** [CMakeFiles/autoware_ground_segmentation.dir/build.make:104:\
  \ CMakeFiles/autoware_ground_segmentation.dir/src/scan_ground_filter/node.cpp.o]\
  \ Error 1\ngmake[1]: *** [CMakeFiles/Makefile2:167: CMakeFiles/autoware_ground_segmentation.dir/all]\
  \ Error 2\ngmake: *** [Makefile:146: all] Error 2\n---\nFailed   <<< autoware_ground_segmentation\
  \ [10.9s, exited with code 2]\n\nSummary: 0 packages finished [12.4s]\n  1 package\
  \ failed: autoware_ground_segmentation\n  1 package had stderr output: autoware_ground_segmentation\n"
generate_code.cpp: |-
  ScanGroundFilterComponent::ScanGroundFilterComponent(const rclcpp::NodeOptions & options)
  : autoware::pointcloud_preprocessor::Filter("ScanGroundFilter", options)
  {
    // Declare parameters
    elevation_grid_mode_ = declare_parameter<bool>("elevation_grid_mode", false);
    radial_divider_angle_rad_ = declare_parameter<float>("radial_divider_angle_rad", 0.1);
    radial_dividers_num_ = static_cast<size_t>(std::ceil(2 * M_PI / radial_divider_angle_rad_));
    global_slope_max_angle_rad_ = declare_parameter<float>("global_slope_max_angle_rad", 0.35);
    local_slope_max_angle_rad_ = declare_parameter<float>("local_slope_max_angle_rad", 0.2);
    global_slope_max_ratio_ = std::tan(global_slope_max_angle_rad_);
    local_slope_max_ratio_ = std::tan(local_slope_max_angle_rad_);
    split_points_distance_tolerance_ = declare_parameter<float>("split_points_distance_tolerance", 0.3);
    vehicle_info_ = autoware::common::vehicle_info::VehicleInfo{
      declare_parameter<float>("vehicle_length", 4.5),
      declare_parameter<float>("vehicle_width", 2.0),
      declare_parameter<float>("vehicle_height", 1.5),
      declare_parameter<float>("vehicle_wheel_base", 2.7),
      declare_parameter<float>("vehicle_cg_to_rear_axle", 1.35),
      declare_parameter<float>("vehicle_front_overhang", 0.9),
      declare_parameter<float>("vehicle_rear_overhang", 0.9),
      declare_parameter<float>("vehicle_min_turn_radius", 5.0)
    };

    use_virtual_ground_point_ = declare_parameter<bool>("use_virtual_ground_point", false);
    split_height_distance_ = declare_parameter<float>("split_height_distance", 0.2);
    use_recheck_ground_cluster_ = declare_parameter<bool>("use_recheck_ground_cluster", false);
    use_lowest_point_ = declare_parameter<bool>("use_lowest_point", false);
    detection_range_z_max_ = declare_parameter<float>("detection_range_z_max", 2.0);
    low_priority_region_x_ = declare_parameter<float>("low_priority_region_x", 1.0);
    center_pcl_shift_ = declare_parameter<float>("center_pcl_shift", 0.0);
    non_ground_height_threshold_ = declare_parameter<float>("non_ground_height_threshold", 0.3);
    grid_size_m_ = declare_parameter<float>("grid_size_m", 0.5);
    grid_mode_switch_radius_ = declare_parameter<float>("grid_mode_switch_radius", 10.0);
    gnd_grid_buffer_size_ = declare_parameter<uint16_t>("gnd_grid_buffer_size", 10);
    virtual_lidar_z_ = declare_parameter<float>("virtual_lidar_z", 1.5);

    // Initialize utilities
    stop_watch_ptr_ = std::make_unique<autoware::universe_utils::StopWatch<std::chrono::milliseconds>>();
    debug_publisher_ptr_ = std::make_unique<autoware::universe_utils::DebugPublisher>(this);
    detailed_processing_time_publisher_ = create_publisher<autoware::universe_utils::ProcessingTimeDetail>(
      "detailed_processing_time", rclcpp::QoS(10));
    time_keeper_ = std::make_shared<autoware::universe_utils::TimeKeeper>();

    // Initialize ground filter
    grid_ground_filter_ptr_ = std::make_unique<GridGroundFilter>(
      elevation_grid_mode_,
      radial_dividers_num_,
      global_slope_max_ratio_,
      local_slope_max_ratio_,
      split_points_distance_tolerance_,
      vehicle_info_,
      use_virtual_ground_point_,
      split_height_distance_,
      use_recheck_ground_cluster_,
      use_lowest_point_,
      detection_range_z_max_,
      low_priority_region_x_,
      center_pcl_shift_,
      non_ground_height_threshold_,
      grid_size_m_,
      grid_mode_switch_radius_,
      gnd_grid_buffer_size_,
      virtual_lidar_z_
    );

    // Parameter callback
    set_param_res_ = add_on_set_parameters_callback(
      [this](const std::vector<rclcpp::Parameter> & parameters) {
        return grid_ground_filter_ptr_->update_parameters(parameters);
      });
  }
ground_truth.cpp: |-
  ScanGroundFilterComponent::ScanGroundFilterComponent(const rclcpp::NodeOptions & options)
  : autoware::pointcloud_preprocessor::Filter("ScanGroundFilter", options)
  {
    // set initial parameters
    {
      // modes
      elevation_grid_mode_ = declare_parameter<bool>("elevation_grid_mode");

      // common parameters
      radial_divider_angle_rad_ =
        static_cast<float>(deg2rad(declare_parameter<double>("radial_divider_angle_deg")));
      radial_dividers_num_ = std::ceil(2.0 * M_PI / radial_divider_angle_rad_);

      // common thresholds
      global_slope_max_angle_rad_ =
        static_cast<float>(deg2rad(declare_parameter<double>("global_slope_max_angle_deg")));
      local_slope_max_angle_rad_ =
        static_cast<float>(deg2rad(declare_parameter<double>("local_slope_max_angle_deg")));
      global_slope_max_ratio_ = std::tan(global_slope_max_angle_rad_);
      local_slope_max_ratio_ = std::tan(local_slope_max_angle_rad_);
      split_points_distance_tolerance_ =
        static_cast<float>(declare_parameter<double>("split_points_distance_tolerance"));

      // vehicle info
      vehicle_info_ = VehicleInfoUtils(*this).getVehicleInfo();

      // non-grid parameters
      use_virtual_ground_point_ = declare_parameter<bool>("use_virtual_ground_point");
      split_height_distance_ = static_cast<float>(declare_parameter<double>("split_height_distance"));

      // grid mode parameters
      use_recheck_ground_cluster_ = declare_parameter<bool>("use_recheck_ground_cluster");
      use_lowest_point_ = declare_parameter<bool>("use_lowest_point");
      detection_range_z_max_ = static_cast<float>(declare_parameter<double>("detection_range_z_max"));
      low_priority_region_x_ = static_cast<float>(declare_parameter<double>("low_priority_region_x"));
      center_pcl_shift_ = static_cast<float>(declare_parameter<double>("center_pcl_shift"));
      non_ground_height_threshold_ =
        static_cast<float>(declare_parameter<double>("non_ground_height_threshold"));

      // grid parameters
      grid_size_m_ = static_cast<float>(declare_parameter<double>("grid_size_m"));
      grid_mode_switch_radius_ =
        static_cast<float>(declare_parameter<double>("grid_mode_switch_radius"));
      gnd_grid_buffer_size_ = declare_parameter<int>("gnd_grid_buffer_size");
      virtual_lidar_z_ = vehicle_info_.vehicle_height_m;

      // initialize grid filter
      {
        GridGroundFilterParameter param;
        param.global_slope_max_angle_rad = global_slope_max_angle_rad_;
        param.local_slope_max_angle_rad = local_slope_max_angle_rad_;
        param.radial_divider_angle_rad = radial_divider_angle_rad_;

        param.use_recheck_ground_cluster = use_recheck_ground_cluster_;
        param.use_lowest_point = use_lowest_point_;
        param.detection_range_z_max = detection_range_z_max_;
        param.non_ground_height_threshold = non_ground_height_threshold_;

        param.grid_size_m = grid_size_m_;
        param.grid_mode_switch_radius = grid_mode_switch_radius_;
        param.gnd_grid_buffer_size = gnd_grid_buffer_size_;
        param.virtual_lidar_x = vehicle_info_.wheel_base_m / 2.0f + center_pcl_shift_;
        param.virtual_lidar_y = 0.0f;
        param.virtual_lidar_z = virtual_lidar_z_;

        grid_ground_filter_ptr_ = std::make_unique<GridGroundFilter>(param);
      }
    }

    using std::placeholders::_1;
    set_param_res_ = this->add_on_set_parameters_callback(
      std::bind(&ScanGroundFilterComponent::onParameter, this, _1));

    // initialize debug tool
    {
      using autoware::universe_utils::DebugPublisher;
      using autoware::universe_utils::StopWatch;
      stop_watch_ptr_ = std::make_unique<StopWatch<std::chrono::milliseconds>>();
      debug_publisher_ptr_ = std::make_unique<DebugPublisher>(this, "scan_ground_filter");
      stop_watch_ptr_->tic("cyclic_time");
      stop_watch_ptr_->tic("processing_time");

      bool use_time_keeper = declare_parameter<bool>("publish_processing_time_detail");
      if (use_time_keeper) {
        detailed_processing_time_publisher_ =
          this->create_publisher<autoware::universe_utils::ProcessingTimeDetail>(
            "~/debug/processing_time_detail_ms", 1);
        auto time_keeper = autoware::universe_utils::TimeKeeper(detailed_processing_time_publisher_);
        time_keeper_ = std::make_shared<autoware::universe_utils::TimeKeeper>(time_keeper);

        // set time keeper to grid
        grid_ground_filter_ptr_->setTimeKeeper(time_keeper_);
      }
    }
  }
