compilation.log: |
  Starting >>> nav2_controller
  --- stderr: nav2_controller
  /root/repos/nav_ws/src/nav2_controller/src/controller_server.cpp: In member function ‘virtual nav2_util::CallbackReturn nav2_controller::ControllerServer::on_configure(const rclcpp_lifecycle::State&)’:
  /root/repos/nav_ws/src/nav2_controller/src/controller_server.cpp:84:83: error: ‘tf_buffer_’ was not declared in this scope
     84 |   costmap_ros_ = std::make_shared<nav2_costmap_2d::Costmap2DROS>("local_costmap", tf_buffer_, get_node_base_interface(), get_node_logging_interface(), get_node_clock_interface(), get_node_parameters_interface(), get_node_topics_interface());
        |                                                                                   ^~~~~~~~~~
  /root/repos/nav_ws/src/nav2_controller/src/controller_server.cpp:102:32: error: no matching function for call to ‘nav2_core::ProgressChecker::initialize(std::shared_ptr<nav2_util::LifecycleNode>)’
    102 |   progress_checker_->initialize(shared_from_this());
        |   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
  In file included from /root/repos/nav_ws/src/nav2_controller/include/nav2_controller/controller_server.hpp:26,
                   from /root/repos/nav_ws/src/nav2_controller/src/controller_server.cpp:28:
  /root/repos/nav_ws/install/nav2_core/include/nav2_core/progress_checker.hpp:45:16: note: candidate: ‘virtual void nav2_core::ProgressChecker::initialize(const WeakPtr&, const string&)’
     45 |   virtual void initialize(
        |                ^~~~~~~~~~
  /root/repos/nav_ws/install/nav2_core/include/nav2_core/progress_checker.hpp:45:16: note:   candidate expects 2 arguments, 1 provided
  /root/repos/nav_ws/src/nav2_controller/src/controller_server.cpp:110:29: error: no matching function for call to ‘nav2_core::GoalChecker::initialize(std::shared_ptr<nav2_util::LifecycleNode>)’
    110 |     goal_checker->initialize(shared_from_this());
        |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
  In file included from /root/repos/nav_ws/install/nav2_core/include/nav2_core/controller.hpp:50,
                   from /root/repos/nav_ws/src/nav2_controller/include/nav2_controller/controller_server.hpp:25,
                   from /root/repos/nav_ws/src/nav2_controller/src/controller_server.cpp:28:
  /root/repos/nav_ws/install/nav2_core/include/nav2_core/goal_checker.hpp:72:16: note: candidate: ‘virtual void nav2_core::GoalChecker::initialize(const WeakPtr&, const string&, std::shared_ptr<nav2_costmap_2d::Costmap2DROS>)’
     72 |   virtual void initialize(
        |                ^~~~~~~~~~
  /root/repos/nav_ws/install/nav2_core/include/nav2_core/goal_checker.hpp:72:16: note:   candidate expects 3 arguments, 1 provided
  gmake[2]: *** [CMakeFiles/controller_server_core.dir/build.make:76: CMakeFiles/controller_server_core.dir/src/controller_server.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:230: CMakeFiles/controller_server_core.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< nav2_controller [6.69s, exited with code 2]

  Summary: 0 packages finished [7.00s]
    1 package failed: nav2_controller
    1 package had stderr output: nav2_controller
generate_code.cpp: |-
  nav2_util::CallbackReturn
  ControllerServer::on_configure(const rclcpp_lifecycle::State & /*state*/)
  {
    RCLCPP_INFO(get_logger(), "Configuring ControllerServer");

    // Initialize costmap
    costmap_ros_ = std::make_shared<nav2_costmap_2d::Costmap2DROS>("local_costmap", tf_buffer_, get_node_base_interface(), get_node_logging_interface(), get_node_clock_interface(), get_node_parameters_interface(), get_node_topics_interface());
    costmap_ros_->configure();
    costmap_thread_ = std::make_unique<nav2_util::NodeThread>(costmap_ros_);

    // Initialize odometry subscriber
    odom_sub_ = std::make_unique<nav_2d_utils::OdomSubscriber>(shared_from_this());

    // Initialize velocity publisher
    vel_publisher_ = create_publisher<geometry_msgs::msg::Twist>("cmd_vel", rclcpp::QoS(10));

    // Initialize speed limit subscriber
    speed_limit_sub_ = create_subscription<nav2_msgs::msg::SpeedLimit>("speed_limit", rclcpp::QoS(10), std::bind(&ControllerServer::speedLimitCallback, this, std::placeholders::_1));

    // Load progress checker plugin
    progress_checker_loader_ = pluginlib::ClassLoader<nav2_core::ProgressChecker>("nav2_core", "nav2_core::ProgressChecker");
    progress_checker_id_ = declare_parameter("progress_checker_plugin", default_progress_checker_id_);
    progress_checker_type_ = declare_parameter(progress_checker_id_ + ".plugin", default_progress_checker_type_);
    progress_checker_ = progress_checker_loader_.createUniqueInstance(progress_checker_type_);
    progress_checker_->initialize(shared_from_this());

    // Load goal checker plugins
    goal_checker_loader_ = pluginlib::ClassLoader<nav2_core::GoalChecker>("nav2_core", "nav2_core::GoalChecker");
    goal_checker_ids_ = declare_parameter("goal_checker_plugins", default_goal_checker_ids_);
    goal_checker_types_ = declare_parameter("goal_checker_plugin_types", default_goal_checker_types_);
    for (size_t i = 0; i < goal_checker_ids_.size(); ++i) {
      auto goal_checker = goal_checker_loader_.createUniqueInstance(goal_checker_types_[i]);
      goal_checker->initialize(shared_from_this());
      goal_checkers_[goal_checker_ids_[i]] = std::move(goal_checker);
    }
    current_goal_checker_ = goal_checker_ids_.front();

    // Load controller plugins
    lp_loader_ = pluginlib::ClassLoader<nav2_core::Controller>("nav2_core", "nav2_core::Controller");
    controller_ids_ = declare_parameter("controller_plugins", default_ids_);
    controller_types_ = declare_parameter("controller_plugin_types", default_types_);
    for (size_t i = 0; i < controller_ids_.size(); ++i) {
      auto controller = lp_loader_.createUniqueInstance(controller_types_[i]);
      controller->configure(shared_from_this(), controller_ids_[i], tf_buffer_, costmap_ros_);
      controllers_[controller_ids_[i]] = std::move(controller);
    }
    current_controller_ = controller_ids_.front();

    // Declare and initialize parameters
    controller_frequency_ = declare_parameter("controller_frequency", 20.0);
    min_x_velocity_threshold_ = declare_parameter("min_x_velocity_threshold", 0.1);
    min_y_velocity_threshold_ = declare_parameter("min_y_velocity_threshold", 0.1);
    min_theta_velocity_threshold_ = declare_parameter("min_theta_velocity_threshold", 0.1);
    failure_tolerance_ = declare_parameter("failure_tolerance", 0.3);
    publish_zero_velocity_ = declare_parameter("publish_zero_velocity", true);

    // Setup dynamic parameters callback
    dyn_params_handler_ = add_on_set_parameters_callback(std::bind(&ControllerServer::dynamicParametersCallback, this, std::placeholders::_1));

    RCLCPP_INFO(get_logger(), "ControllerServer configured successfully");
    return nav2_util::CallbackReturn::SUCCESS;
  }
ground_truth.cpp: |-
  nav2_util::CallbackReturn
  ControllerServer::on_configure(const rclcpp_lifecycle::State & /*state*/)
  {
    auto node = shared_from_this();

    RCLCPP_INFO(get_logger(), "Configuring controller interface");

    get_parameter("progress_checker_plugin", progress_checker_id_);
    if (progress_checker_id_ == default_progress_checker_id_) {
      nav2_util::declare_parameter_if_not_declared(
        node, default_progress_checker_id_ + ".plugin",
        rclcpp::ParameterValue(default_progress_checker_type_));
    }

    RCLCPP_INFO(get_logger(), "getting goal checker plugins..");
    get_parameter("goal_checker_plugins", goal_checker_ids_);
    if (goal_checker_ids_ == default_goal_checker_ids_) {
      for (size_t i = 0; i < default_goal_checker_ids_.size(); ++i) {
        nav2_util::declare_parameter_if_not_declared(
          node, default_goal_checker_ids_[i] + ".plugin",
          rclcpp::ParameterValue(default_goal_checker_types_[i]));
      }
    }

    get_parameter("controller_plugins", controller_ids_);
    if (controller_ids_ == default_ids_) {
      for (size_t i = 0; i < default_ids_.size(); ++i) {
        nav2_util::declare_parameter_if_not_declared(
          node, default_ids_[i] + ".plugin",
          rclcpp::ParameterValue(default_types_[i]));
      }
    }

    controller_types_.resize(controller_ids_.size());
    goal_checker_types_.resize(goal_checker_ids_.size());

    get_parameter("controller_frequency", controller_frequency_);
    get_parameter("min_x_velocity_threshold", min_x_velocity_threshold_);
    get_parameter("min_y_velocity_threshold", min_y_velocity_threshold_);
    get_parameter("min_theta_velocity_threshold", min_theta_velocity_threshold_);
    RCLCPP_INFO(get_logger(), "Controller frequency set to %.4fHz", controller_frequency_);

    std::string speed_limit_topic;
    get_parameter("speed_limit_topic", speed_limit_topic);
    get_parameter("failure_tolerance", failure_tolerance_);
    get_parameter("publish_zero_velocity", publish_zero_velocity_);

    costmap_ros_->configure();
    // Launch a thread to run the costmap node
    costmap_thread_ = std::make_unique<nav2_util::NodeThread>(costmap_ros_);

    try {
      progress_checker_type_ = nav2_util::get_plugin_type_param(node, progress_checker_id_);
      progress_checker_ = progress_checker_loader_.createUniqueInstance(progress_checker_type_);
      RCLCPP_INFO(
        get_logger(), "Created progress_checker : %s of type %s",
        progress_checker_id_.c_str(), progress_checker_type_.c_str());
      progress_checker_->initialize(node, progress_checker_id_);
    } catch (const pluginlib::PluginlibException & ex) {
      RCLCPP_FATAL(
        get_logger(),
        "Failed to create progress_checker. Exception: %s", ex.what());
      return nav2_util::CallbackReturn::FAILURE;
    }

    for (size_t i = 0; i != goal_checker_ids_.size(); i++) {
      try {
        goal_checker_types_[i] = nav2_util::get_plugin_type_param(node, goal_checker_ids_[i]);
        nav2_core::GoalChecker::Ptr goal_checker =
          goal_checker_loader_.createUniqueInstance(goal_checker_types_[i]);
        RCLCPP_INFO(
          get_logger(), "Created goal checker : %s of type %s",
          goal_checker_ids_[i].c_str(), goal_checker_types_[i].c_str());
        goal_checker->initialize(node, goal_checker_ids_[i], costmap_ros_);
        goal_checkers_.insert({goal_checker_ids_[i], goal_checker});
      } catch (const pluginlib::PluginlibException & ex) {
        RCLCPP_FATAL(
          get_logger(),
          "Failed to create goal checker. Exception: %s", ex.what());
        return nav2_util::CallbackReturn::FAILURE;
      }
    }

    for (size_t i = 0; i != goal_checker_ids_.size(); i++) {
      goal_checker_ids_concat_ += goal_checker_ids_[i] + std::string(" ");
    }

    RCLCPP_INFO(
      get_logger(),
      "Controller Server has %s goal checkers available.", goal_checker_ids_concat_.c_str());

    for (size_t i = 0; i != controller_ids_.size(); i++) {
      try {
        controller_types_[i] = nav2_util::get_plugin_type_param(node, controller_ids_[i]);
        nav2_core::Controller::Ptr controller =
          lp_loader_.createUniqueInstance(controller_types_[i]);
        RCLCPP_INFO(
          get_logger(), "Created controller : %s of type %s",
          controller_ids_[i].c_str(), controller_types_[i].c_str());
        controller->configure(
          node, controller_ids_[i],
          costmap_ros_->getTfBuffer(), costmap_ros_);
        controllers_.insert({controller_ids_[i], controller});
      } catch (const pluginlib::PluginlibException & ex) {
        RCLCPP_FATAL(
          get_logger(),
          "Failed to create controller. Exception: %s", ex.what());
        return nav2_util::CallbackReturn::FAILURE;
      }
    }

    for (size_t i = 0; i != controller_ids_.size(); i++) {
      controller_ids_concat_ += controller_ids_[i] + std::string(" ");
    }

    RCLCPP_INFO(
      get_logger(),
      "Controller Server has %s controllers available.", controller_ids_concat_.c_str());

    odom_sub_ = std::make_unique<nav_2d_utils::OdomSubscriber>(node);
    vel_publisher_ = create_publisher<geometry_msgs::msg::Twist>("cmd_vel", 1);

    // Create the action server that we implement with our followPath method
    action_server_ = std::make_unique<ActionServer>(
      shared_from_this(),
      "follow_path",
      std::bind(&ControllerServer::computeControl, this),
      nullptr,
      std::chrono::milliseconds(500),
      true);

    // Set subscribtion to the speed limiting topic
    speed_limit_sub_ = create_subscription<nav2_msgs::msg::SpeedLimit>(
      speed_limit_topic, rclcpp::QoS(10),
      std::bind(&ControllerServer::speedLimitCallback, this, std::placeholders::_1));

    return nav2_util::CallbackReturn::SUCCESS;
  }
