compilation.log: |
  Starting >>> nav2_route
  --- stderr: nav2_route
  /root/repos/nav_ws/src/nav2_route/src/plugins/graph_file_loaders/geojson_graph_file_loader.cpp:32:6: error: no declaration matches ‘void nav2_route::GeoJsonGraphFileLoader::loadEdgesFromGraph(nav2_route::Graph&, nav2_route::GraphToIDMap&, const std::vector<nlohmann::basic_json<>, std::allocator<nlohmann::basic_json<> > >&)’
     32 | void GeoJsonGraphFileLoader::loadEdgesFromGraph(
        |      ^~~~~~~~~~~~~~~~~~~~~~
  /root/repos/nav_ws/src/nav2_route/src/plugins/graph_file_loaders/geojson_graph_file_loader.cpp:32:6: note: no functions named ‘void nav2_route::GeoJsonGraphFileLoader::loadEdgesFromGraph(nav2_route::Graph&, nav2_route::GraphToIDMap&, const std::vector<nlohmann::basic_json<>, std::allocator<nlohmann::basic_json<> > >&)’
  In file included from /root/repos/nav_ws/src/nav2_route/src/plugins/graph_file_loaders/geojson_graph_file_loader.cpp:20:
  /root/repos/nav_ws/src/nav2_route/include/nav2_route/plugins/graph_file_loaders/geojson_graph_file_loader.hpp:34:7: note: ‘class nav2_route::GeoJsonGraphFileLoader’ defined here
     34 | class GeoJsonGraphFileLoader : public GraphFileLoader
        |       ^~~~~~~~~~~~~~~~~~~~~~
  gmake[2]: *** [CMakeFiles/graph_file_loaders.dir/build.make:76: CMakeFiles/graph_file_loaders.dir/src/plugins/graph_file_loaders/geojson_graph_file_loader.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:318: CMakeFiles/graph_file_loaders.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< nav2_route [3.32s, exited with code 2]

  Summary: 0 packages finished [3.61s]
    1 package failed: nav2_route
    1 package had stderr output: nav2_route
generate_code.cpp: |-
  void GeoJsonGraphFileLoader::loadEdgesFromGraph(
    Graph & graph, GraphToIDMap & graph_to_id_map, const std::vector<Json> & edges)
  {
    for (const auto & edge : edges) {
      try {
        // Extract source and target node IDs
        auto source_id = edge.at("source").get<std::string>();
        auto target_id = edge.at("target").get<std::string>();

        // Check if the source and target nodes exist in the graph_to_id_map
        if (graph_to_id_map.find(source_id) == graph_to_id_map.end() ||
            graph_to_id_map.find(target_id) == graph_to_id_map.end()) {
          throw std::runtime_error("Source or target node ID not found in graph_to_id_map");
        }

        // Get the graph indices for the source and target nodes
        auto source_idx = graph_to_id_map[source_id];
        auto target_idx = graph_to_id_map[target_id];

        // Extract edge properties (if any)
        double weight = 1.0; // Default weight
        if (edge.contains("weight")) {
          weight = edge.at("weight").get<double>();
        }

        // Add the edge to the graph
        graph.addEdge(source_idx, target_idx, weight);
      } catch (const std::exception & e) {
        ROS_ERROR_STREAM("Failed to load edge: " << e.what());
      }
    }
  }
ground_truth.cpp: |-
  bool GeoJsonGraphFileLoader::loadGraphFromFile(
    Graph & graph, GraphToIDMap & graph_to_id_map, std::string filepath)
  {
    if (!doesFileExist(filepath)) {
      RCLCPP_ERROR(logger_, "The filepath %s does not exist", filepath.c_str());
      return false;
    }

    std::ifstream graph_file(filepath);
    Json json_graph;

    try {
      json_graph = Json::parse(graph_file);
    } catch (Json::parse_error & ex) {
      RCLCPP_ERROR(logger_, "Failed to parse %s: %s", filepath.c_str(), ex.what());
      return false;
    }

    auto features = json_graph["features"];
    std::vector<Json> nodes, edges;
    getGraphElements(features, nodes, edges);

    if (nodes.empty() || edges.empty()) {
      RCLCPP_ERROR(
        logger_, "The graph is malformed. Is does not contain nodes or edges. Please check %s",
        filepath.c_str());
      return false;
    }

    graph.resize(nodes.size());
    addNodesToGraph(graph, graph_to_id_map, nodes);
    addEdgesToGraph(graph, graph_to_id_map, edges);
    return true;
  }
