compilation.log: |
  Starting >>> autoware_raw_vehicle_cmd_converter
  --- stderr: autoware_raw_vehicle_cmd_converter
  /workspace/repos/autoware/src/universe/autoware.universe/vehicle/autoware_raw_vehicle_cmd_converter/src/brake_map.cpp: In member function ‘bool autoware::raw_vehicle_cmd_converter::BrakeMap::getBrake(double, double, double&)’:
  /workspace/repos/autoware/src/universe/autoware.universe/vehicle/autoware_raw_vehicle_cmd_converter/src/brake_map.cpp:50:51: error: ‘row_index_’ was not declared in this scope; did you mean ‘vel_index_’?
     50 |   double clamped_acc = CSVLoader::clampValue(acc, row_index_);
        |                                                   ^~~~~~~~~~
        |                                                   vel_index_
  /workspace/repos/autoware/src/universe/autoware.universe/vehicle/autoware_raw_vehicle_cmd_converter/src/brake_map.cpp:51:51: error: ‘column_index_’ was not declared in this scope; did you mean ‘vel_index_’?
     51 |   double clamped_vel = CSVLoader::clampValue(vel, column_index_);
        |                                                   ^~~~~~~~~~~~~
        |                                                   vel_index_
  /workspace/repos/autoware/src/universe/autoware.universe/vehicle/autoware_raw_vehicle_cmd_converter/src/brake_map.cpp:55:20: error: ‘map_’ was not declared in this scope
     55 |     column_index_, map_[clamped_acc], clamped_vel);
        |                    ^~~~
  gmake[2]: *** [CMakeFiles/actuation_map_converter.dir/build.make:90: CMakeFiles/actuation_map_converter.dir/src/brake_map.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:163: CMakeFiles/actuation_map_converter.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_raw_vehicle_cmd_converter [2.59s, exited with code 2]

  Summary: 0 packages finished [3.97s]
    1 package failed: autoware_raw_vehicle_cmd_converter
    1 package had stderr output: autoware_raw_vehicle_cmd_converter
generate_code.cpp: |-
  bool BrakeMap::getBrake(const double acc, const double vel, double & brake)
  {
    // Clamp the acceleration and velocity values to ensure they are within the valid range
    double clamped_acc = CSVLoader::clampValue(acc, row_index_);
    double clamped_vel = CSVLoader::clampValue(vel, column_index_);

    // Perform interpolation to find the brake value
    std::vector<double> interpolated_row = autoware::interpolation::lerp(
      column_index_, map_[clamped_acc], clamped_vel);

    brake = autoware::interpolation::lerp(row_index_, interpolated_row, clamped_acc);

    return true; // Indicate successful calculation
  }
ground_truth.cpp: |-
  bool BrakeMap::getBrake(const double acc, const double vel, double & brake)
  {
    std::vector<double> interpolated_acc_vec;
    const double clamped_vel = CSVLoader::clampValue(vel, vel_index_, "brake: vel");

    // (throttle, vel, acc) map => (throttle, acc) map by fixing vel
    interpolated_acc_vec.reserve(brake_map_.size());
    for (const std::vector<double> & accelerations : brake_map_) {
      interpolated_acc_vec.push_back(
        autoware::interpolation::lerp(vel_index_, accelerations, clamped_vel));
    }

    // calculate brake
    // When the desired acceleration is smaller than the brake area, return max brake on the map
    // When the desired acceleration is greater than the brake area, return min brake on the map
    if (acc < interpolated_acc_vec.back()) {
      RCLCPP_WARN_SKIPFIRST_THROTTLE(
        logger_, clock_, 1000,
        "Exceeding the acc range. Desired acc: %f < min acc on map: %f. return max "
        "value.",
        acc, interpolated_acc_vec.back());
      brake = brake_index_.back();
      return true;
    }
    if (interpolated_acc_vec.front() < acc) {
      brake = brake_index_.front();
      return true;
    }

    std::reverse(std::begin(interpolated_acc_vec), std::end(interpolated_acc_vec));
    brake = autoware::interpolation::lerp(interpolated_acc_vec, brake_index_rev_, acc);

    return true;
  }
