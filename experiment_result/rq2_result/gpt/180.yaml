compilation.log: |
  Starting >>> nav2_collision_monitor
  Finished <<< nav2_collision_monitor [0.40s]

  Summary: 1 package finished [0.70s]
generate_code.cpp: |-
  nav2_util::CallbackReturn
  CollisionMonitor::on_configure(const rclcpp_lifecycle::State & /*state*/)
  {
    RCLCPP_INFO(get_logger(), "Configuring CollisionMonitor...");

    // Initialize the TF2 buffer and listener
    tf_buffer_ = std::make_shared<tf2_ros::Buffer>(get_clock());
    tf_listener_ = std::make_shared<tf2_ros::TransformListener>(*tf_buffer_);

    // Create the subscription for incoming cmd_vel messages
    cmd_vel_in_sub_ = create_subscription<geometry_msgs::msg::Twist>(
      "cmd_vel_in", rclcpp::SystemDefaultsQoS(),
      std::bind(&CollisionMonitor::cmdVelInCallback, this, std::placeholders::_1));

    // Create the publisher for outgoing cmd_vel messages
    cmd_vel_out_pub_ = create_publisher<geometry_msgs::msg::Twist>(
      "cmd_vel_out", rclcpp::SystemDefaultsQoS());

    // Check if all resources were successfully initialized
    if (!tf_buffer_ || !tf_listener_ || !cmd_vel_in_sub_ || !cmd_vel_out_pub_) {
      RCLCPP_ERROR(get_logger(), "Failed to configure CollisionMonitor. Resource allocation failed.");
      return nav2_util::CallbackReturn::FAILURE;
    }

    RCLCPP_INFO(get_logger(), "CollisionMonitor successfully configured.");
    return nav2_util::CallbackReturn::SUCCESS;
  }
ground_truth.cpp: |-
  nav2_util::CallbackReturn
  CollisionMonitor::on_configure(const rclcpp_lifecycle::State & /*state*/)
  {
    RCLCPP_INFO(get_logger(), "Configuring");

    // Transform buffer and listener initialization
    tf_buffer_ = std::make_shared<tf2_ros::Buffer>(this->get_clock());
    auto timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
      this->get_node_base_interface(),
      this->get_node_timers_interface());
    tf_buffer_->setCreateTimerInterface(timer_interface);
    tf_listener_ = std::make_shared<tf2_ros::TransformListener>(*tf_buffer_);

    std::string cmd_vel_in_topic;
    std::string cmd_vel_out_topic;

    // Obtaining ROS parameters
    if (!getParameters(cmd_vel_in_topic, cmd_vel_out_topic)) {
      return nav2_util::CallbackReturn::FAILURE;
    }

    cmd_vel_in_sub_ = this->create_subscription<geometry_msgs::msg::Twist>(
      cmd_vel_in_topic, 1,
      std::bind(&CollisionMonitor::cmdVelInCallback, this, std::placeholders::_1));
    cmd_vel_out_pub_ = this->create_publisher<geometry_msgs::msg::Twist>(
      cmd_vel_out_topic, 1);

    return nav2_util::CallbackReturn::SUCCESS;
  }
