compilation.log: |
  Starting >>> moveit_core
  Finished <<< moveit_core [0.66s]

  Summary: 1 package finished [1.11s]
generate_code.cpp: |-
  double DistanceField::getDistanceGradient(double x, double y, double z, double& gradient_x, double& gradient_y,
                                            double& gradient_z, bool& in_bounds) const
  {
      // Convert world coordinates to grid coordinates
      int grid_x, grid_y, grid_z;
      in_bounds = worldToGrid(x, y, z, grid_x, grid_y, grid_z);

      // Check if the point is out of bounds
      if (!in_bounds) {
          gradient_x = gradient_y = gradient_z = 0.0;
          return getUninitializedDistance();
      }

      // Helper lambda to get the distance at a neighboring cell
      auto getDistanceSafe = [&](int gx, int gy, int gz) -> double {
          if (gx >= 0 && gx < getXNumCells() && gy >= 0 && gy < getXNumCells() && gz >= 0 && gz < getXNumCells()) {
              return getDistance(gx, gy, gz);
          } else {
              return getUninitializedDistance();
          }
      };

      // Compute the central difference for the gradient
      double dist_x_plus = getDistanceSafe(grid_x + 1, grid_y, grid_z);
      double dist_x_minus = getDistanceSafe(grid_x - 1, grid_y, grid_z);
      double dist_y_plus = getDistanceSafe(grid_x, grid_y + 1, grid_z);
      double dist_y_minus = getDistanceSafe(grid_x, grid_y - 1, grid_z);
      double dist_z_plus = getDistanceSafe(grid_x, grid_y, grid_z + 1);
      double dist_z_minus = getDistanceSafe(grid_x, grid_y, grid_z - 1);

      // Check for uninitialized distances
      double uninitialized = getUninitializedDistance();
      if (dist_x_plus == uninitialized || dist_x_minus == uninitialized ||
          dist_y_plus == uninitialized || dist_y_minus == uninitialized ||
          dist_z_plus == uninitialized || dist_z_minus == uninitialized) {
          gradient_x = gradient_y = gradient_z = 0.0;
          return getUninitializedDistance();
      }

      // Compute the gradient using central differences
      gradient_x = (dist_x_plus - dist_x_minus) * 0.5 * inv_twice_resolution_;
      gradient_y = (dist_y_plus - dist_y_minus) * 0.5 * inv_twice_resolution_;
      gradient_z = (dist_z_plus - dist_z_minus) * 0.5 * inv_twice_resolution_;

      // Return the distance at the current grid cell
      return getDistance(grid_x, grid_y, grid_z);
  }
ground_truth.cpp: |-
  double DistanceField::getDistanceGradient(double x, double y, double z, double& gradient_x, double& gradient_y,
                                            double& gradient_z, bool& in_bounds) const
  {
    int gx, gy, gz;

    worldToGrid(x, y, z, gx, gy, gz);

    // if out of bounds, return max_distance, and 0 gradient
    // we need extra padding of 1 to get gradients
    if (gx < 1 || gy < 1 || gz < 1 || gx >= getXNumCells() - 1 || gy >= getYNumCells() - 1 || gz >= getZNumCells() - 1)
    {
      gradient_x = 0.0;
      gradient_y = 0.0;
      gradient_z = 0.0;
      in_bounds = false;
      return getUninitializedDistance();
    }

    gradient_x = (getDistance(gx + 1, gy, gz) - getDistance(gx - 1, gy, gz)) * inv_twice_resolution_;
    gradient_y = (getDistance(gx, gy + 1, gz) - getDistance(gx, gy - 1, gz)) * inv_twice_resolution_;
    gradient_z = (getDistance(gx, gy, gz + 1) - getDistance(gx, gy, gz - 1)) * inv_twice_resolution_;

    in_bounds = true;
    return getDistance(gx, gy, gz);
  }
