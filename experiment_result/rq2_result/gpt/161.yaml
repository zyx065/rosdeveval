compilation.log: |
  Starting >>> nav2_costmap_2d
  Finished <<< nav2_costmap_2d [0.44s]

  Summary: 1 package finished [0.75s]
generate_code.cpp: |-
  void BinaryFilter::maskCallback(
    const nav_msgs::msg::OccupancyGrid::SharedPtr msg)
  {
    // Update the internal filter mask with the new data
    filter_mask_ = msg;

    // Store the frame ID of the mask
    mask_frame_ = msg->header.frame_id;

    // Initialize binary state to the default state
    binary_state_ = default_state_;

    // Iterate through the occupancy grid data
    for (const auto &value : msg->data)
    {
      // Check if the value exceeds the flip threshold
      if (value >= flip_threshold_)
      {
        // Update binary state to non-default
        binary_state_ = !default_state_;
        break; // No need to check further, state has flipped
      }
    }

    // Publish the updated binary state
    auto binary_state_msg = std_msgs::msg::Bool();
    binary_state_msg.data = binary_state_;
    binary_state_pub_->publish(binary_state_msg);
  }
ground_truth.cpp: |-
  void BinaryFilter::maskCallback(
    const nav_msgs::msg::OccupancyGrid::SharedPtr msg)
  {
    std::lock_guard<CostmapFilter::mutex_t> guard(*getMutex());

    if (!filter_mask_) {
      RCLCPP_INFO(
        logger_,
        "BinaryFilter: Received filter mask from %s topic.", mask_topic_.c_str());
    } else {
      RCLCPP_WARN(
        logger_,
        "BinaryFilter: New filter mask arrived from %s topic. Updating old filter mask.",
        mask_topic_.c_str());
      filter_mask_.reset();
    }

    filter_mask_ = msg;
    mask_frame_ = msg->header.frame_id;
  }
