compilation.log: |
  Starting >>> autoware_detected_object_validation
  --- stderr: autoware_detected_object_validation
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_detected_object_validation/src/lanelet_filter/lanelet_filter.cpp: In member function ‘void autoware::detected_object_validation::lanelet_filter::ObjectLaneletFilterNode::objectCallback(autoware_perception_msgs::msg::DetectedObjects_<std::allocator<void> >::ConstSharedPtr)’:
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_detected_object_validation/src/lanelet_filter/lanelet_filter.cpp:148:37: error: ‘using element_type = class lanelet::LaneletMap’ {aka ‘class lanelet::LaneletMap’} has no member named ‘getMapFrame’
    148 |       *input_msg, lanelet_map_ptr_->getMapFrame(), *tf_buffer_ptr_, transformed_objects);
        |                                     ^~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_detected_object_validation/src/lanelet_filter/lanelet_filter.cpp:148:53: error: ‘tf_buffer_ptr_’ was not declared in this scope; did you mean ‘tf_buffer_’?
    148 |       *input_msg, lanelet_map_ptr_->getMapFrame(), *tf_buffer_ptr_, transformed_objects);
        |                                                     ^~~~~~~~~~~~~~
        |                                                     tf_buffer_
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_detected_object_validation/src/lanelet_filter/lanelet_filter.cpp:169:47: error: cannot convert ‘const std::vector<std::pair<boost::geometry::model::box<boost::geometry::model::point<double, 2, boost::geometry::cs::cartesian> >, autoware::detected_object_validation::lanelet_filter::PolygonAndLanelet> >’ to ‘const boost::geometry::index::rtree<std::pair<boost::geometry::model::box<boost::geometry::model::point<double, 2, boost::geometry::cs::cartesian> >, autoware::detected_object_validation::lanelet_filter::PolygonAndLanelet>, boost::geometry::index::rstar<16> >&’
    169 |             transformed_object, input_object, intersected_lanelets, output_msg)) {
        |                                               ^~~~~~~~~~~~~~~~~~~~
        |                                               |
        |                                               const std::vector<std::pair<boost::geometry::model::box<boost::geometry::model::point<double, 2, boost::geometry::cs::cartesian> >, autoware::detected_object_validation::lanelet_filter::PolygonAndLanelet> >
  In file included from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_detected_object_validation/src/lanelet_filter/lanelet_filter.cpp:15:
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_detected_object_validation/src/lanelet_filter/lanelet_filter.hpp:109:56: note:   initializing argument 3 of ‘bool autoware::detected_object_validation::lanelet_filter::ObjectLaneletFilterNode::filterObject(const DetectedObject&, const DetectedObject&, const boost::geometry::index::rtree<std::pair<boost::geometry::model::box<boost::geometry::model::point<double, 2, boost::geometry::cs::cartesian> >, autoware::detected_object_validation::lanelet_filter::PolygonAndLanelet>, boost::geometry::index::rstar<16> >&, autoware_perception_msgs::msg::DetectedObjects&)’
    109 |     const bg::index::rtree<BoxAndLanelet, RtreeAlgo> & local_rtree,
        |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_detected_object_validation/src/lanelet_filter/lanelet_filter.cpp:179:30: error: ‘class autoware::universe_utils::PublishedTimePublisher’ has no member named ‘publish’; did you mean ‘std::map<rmw_gid_s, std::shared_ptr<rclcpp::Publisher<autoware_internal_msgs::msg::PublishedTime_<std::allocator<void> > > >, autoware::universe_utils::PublishedTimePublisher::GidCompare> autoware::universe_utils::PublishedTimePublisher::publishers_’? (not accessible from this context)
    179 |   published_time_publisher_->publish(input_msg->header.stamp, stop_watch_ptr_->toc());
        |                              ^~~~~~~
  In file included from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_detected_object_validation/src/lanelet_filter/lanelet_filter.hpp:21,
                   from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_detected_object_validation/src/lanelet_filter/lanelet_filter.cpp:15:
  /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/ros/published_time_publisher.hpp:110:80: note: declared private here
    110 |   std::map<rmw_gid_t, rclcpp::Publisher<PublishedTime>::SharedPtr, GidCompare> publishers_;
        |                                                                                ^~~~~~~~~~~
  gmake[2]: *** [CMakeFiles/object_lanelet_filter.dir/build.make:90: CMakeFiles/object_lanelet_filter.dir/src/lanelet_filter/lanelet_filter.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:226: CMakeFiles/object_lanelet_filter.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_detected_object_validation [16.2s, exited with code 2]

  Summary: 0 packages finished [17.6s]
    1 package failed: autoware_detected_object_validation
    1 package had stderr output: autoware_detected_object_validation
generate_code.cpp: |-
  void ObjectLaneletFilterNode::objectCallback(
    const autoware_perception_msgs::msg::DetectedObjects::ConstSharedPtr input_msg)
  {
    // Start stopwatch for performance measurement
    stop_watch_ptr_->tic();

    // Initialize output message
    autoware_perception_msgs::msg::DetectedObjects output_msg;
    output_msg.header = input_msg->header;

    // Transform objects to the lanelet frame
    autoware_perception_msgs::msg::DetectedObjects transformed_objects;
    try {
      autoware::object_recognition_utils::transformObjects(
        *input_msg, lanelet_map_ptr_->getMapFrame(), *tf_buffer_ptr_, transformed_objects);
    } catch (const std::exception & e) {
      RCLCPP_WARN(get_logger(), "Failed to transform objects: %s", e.what());
      return;
    }

    // Get convex hull of transformed objects
    const auto convex_hull = getConvexHull(transformed_objects);

    // Get intersected lanelets
    const auto intersected_lanelets = getIntersectedLanelets(convex_hull);

    // Debug marker publishing
    if (filter_settings_.debug) {
      publishDebugMarkers(input_msg->header.stamp, convex_hull, intersected_lanelets);
    }

    // Filter objects based on lanelet intersection criteria
    for (const auto & transformed_object : transformed_objects.objects) {
      for (const auto & input_object : input_msg->objects) {
        if (filterObject(
              transformed_object, input_object, intersected_lanelets, output_msg)) {
          break; // Stop checking further lanelets once the object is filtered
        }
      }
    }

    // Publish filtered objects
    object_pub_->publish(output_msg);

    // Publish debug timing information
    published_time_publisher_->publish(input_msg->header.stamp, stop_watch_ptr_->toc());
  }
ground_truth.cpp: |-
  void ObjectLaneletFilterNode::objectCallback(
    const autoware_perception_msgs::msg::DetectedObjects::ConstSharedPtr input_msg)
  {
    stop_watch_ptr_->tic("processing_time");

    // Guard
    if (object_pub_->get_subscription_count() < 1) return;

    autoware_perception_msgs::msg::DetectedObjects output_object_msg;
    output_object_msg.header = input_msg->header;

    if (!lanelet_map_ptr_) {
      RCLCPP_ERROR(get_logger(), "No vector map received.");
      return;
    }
    autoware_perception_msgs::msg::DetectedObjects transformed_objects;
    if (!autoware::object_recognition_utils::transformObjects(
          *input_msg, lanelet_frame_id_, tf_buffer_, transformed_objects)) {
      RCLCPP_ERROR(get_logger(), "Failed transform to %s.", lanelet_frame_id_.c_str());
      return;
    }
    // vehicle base pose :map -> base_link
    if (filter_settings_.use_height_threshold) {
      try {
        ego_base_height_ = tf_buffer_
                             .lookupTransform(
                               lanelet_frame_id_, "base_link", transformed_objects.header.stamp,
                               rclcpp::Duration::from_seconds(0.5))
                             .transform.translation.z;
      } catch (const tf2::TransformException & ex) {
        RCLCPP_ERROR_STREAM(get_logger(), "Failed to get transform: " << ex.what());
        return;
      }
    }

    if (!transformed_objects.objects.empty()) {
      // calculate convex hull
      const auto convex_hull = getConvexHull(transformed_objects);

      // get intersected lanelets
      std::vector<BoxAndLanelet> intersected_lanelets_with_bbox = getIntersectedLanelets(convex_hull);

      // create R-Tree with intersected_lanelets for fast search
      bgi::rtree<BoxAndLanelet, RtreeAlgo> local_rtree;
      for (const auto & bbox_and_lanelet : intersected_lanelets_with_bbox) {
        local_rtree.insert(bbox_and_lanelet);
      }

      if (filter_settings_.debug) {
        publishDebugMarkers(input_msg->header.stamp, convex_hull, intersected_lanelets_with_bbox);
      }
      // filtering process
      for (size_t index = 0; index < transformed_objects.objects.size(); ++index) {
        const auto & transformed_object = transformed_objects.objects.at(index);
        const auto & input_object = input_msg->objects.at(index);
        filterObject(transformed_object, input_object, local_rtree, output_object_msg);
      }
    }

    object_pub_->publish(output_object_msg);
    published_time_publisher_->publish_if_subscribed(object_pub_, output_object_msg.header.stamp);

    // Publish debug info
    const double pipeline_latency =
      std::chrono::duration<double, std::milli>(
        std::chrono::nanoseconds(
          (this->get_clock()->now() - output_object_msg.header.stamp).nanoseconds()))
        .count();
    debug_publisher_->publish<autoware_internal_debug_msgs::msg::Float64Stamped>(
      "debug/pipeline_latency_ms", pipeline_latency);
    debug_publisher_->publish<autoware_internal_debug_msgs::msg::Float64Stamped>(
      "debug/processing_time_ms", stop_watch_ptr_->toc("processing_time", true));
  }
