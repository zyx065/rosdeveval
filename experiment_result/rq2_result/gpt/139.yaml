compilation.log: |
  Starting >>> moveit_core
  Finished <<< moveit_core [0.81s]

  Summary: 1 package finished [1.25s]
generate_code.cpp: |-
  void moveit::core::AABB::extendWithTransformedBox(const Eigen::Isometry3d& transform, const Eigen::Vector3d& box)
  {
      // Define the 8 corner points of the box in its local frame
      Eigen::Vector3d corners[8] = {
          Eigen::Vector3d(-box.x(), -box.y(), -box.z()),
          Eigen::Vector3d(-box.x(), -box.y(),  box.z()),
          Eigen::Vector3d(-box.x(),  box.y(), -box.z()),
          Eigen::Vector3d(-box.x(),  box.y(),  box.z()),
          Eigen::Vector3d( box.x(), -box.y(), -box.z()),
          Eigen::Vector3d( box.x(), -box.y(),  box.z()),
          Eigen::Vector3d( box.x(),  box.y(), -box.z()),
          Eigen::Vector3d( box.x(),  box.y(),  box.z())
      };

      // Transform each corner point and update the AABB
      for (const auto& corner : corners)
      {
          Eigen::Vector3d transformed_corner = transform * corner;
          extend(transformed_corner);
      }
  }
ground_truth.cpp: |-
  void moveit::core::AABB::extendWithTransformedBox(const Eigen::Isometry3d& transform, const Eigen::Vector3d& box)
  {
    // Method adapted from FCL src/shape/geometric_shapes_utility.cpp#computeBV<AABB, Box>(...) (BSD-licensed code):
    // https://github.com/flexible-collision-library/fcl/blob/fcl-0.4/src/shape/geometric_shapes_utility.cpp#L292
    // We don't call their code because it would need creating temporary objects, and their method is in floats.
    //
    // Here's a nice explanation why it works: https://zeuxcg.org/2010/10/17/aabb-from-obb-with-component-wise-abs/

    ASSERT_ISOMETRY(transform)  // unsanitized input, could contain non-isometry
    const Eigen::Matrix3d& r = transform.linear();
    const Eigen::Vector3d& t = transform.translation();

    double x_range = 0.5 * (fabs(r(0, 0) * box[0]) + fabs(r(0, 1) * box[1]) + fabs(r(0, 2) * box[2]));
    double y_range = 0.5 * (fabs(r(1, 0) * box[0]) + fabs(r(1, 1) * box[1]) + fabs(r(1, 2) * box[2]));
    double z_range = 0.5 * (fabs(r(2, 0) * box[0]) + fabs(r(2, 1) * box[1]) + fabs(r(2, 2) * box[2]));

    const Eigen::Vector3d v_delta(x_range, y_range, z_range);
    extend(t + v_delta);
    extend(t - v_delta);
  }
