compilation.log: |
  Starting >>> nav2_util
  Finished <<< nav2_util [0.34s]

  Summary: 1 package finished [0.64s]
generate_code.cpp: "void OdomSmoother::odomCallback(const nav_msgs::msg::Odometry::SharedPtr\
  \ msg)\n{\n    // Lock the mutex to ensure thread safety\n    std::lock_guard<std::mutex>\
  \ lock(odom_mutex_);\n\n    // Add the new odometry message to the history deque\n\
  \    odom_history_.push_back(*msg);\n\n    // Remove old odometry messages that\
  \ are outside the smoothing time window\n    rclcpp::Time current_time = msg->header.stamp;\n\
  \    while (!odom_history_.empty() && \n           (current_time - odom_history_.front().header.stamp)\
  \ > odom_history_duration_)\n    {\n        odom_history_.pop_front();\n    }\n\n\
  \    // Reset the cumulative odometry and velocity\n    odom_cumulate_ = nav_msgs::msg::Odometry();\n\
  \    vel_smooth_ = geometry_msgs::msg::TwistStamped();\n\n    // Initialize variables\
  \ for averaging\n    size_t count = odom_history_.size();\n    if (count == 0) {\n\
  \        return; // No data to process\n    }\n\n    // Accumulate odometry and\
  \ velocity data\n    for (const auto& odom : odom_history_) {\n        odom_cumulate_.pose.pose.position.x\
  \ += odom.pose.pose.position.x;\n        odom_cumulate_.pose.pose.position.y +=\
  \ odom.pose.pose.position.y;\n        odom_cumulate_.pose.pose.position.z += odom.pose.pose.position.z;\n\
  \n        odom_cumulate_.pose.pose.orientation.x += odom.pose.pose.orientation.x;\n\
  \        odom_cumulate_.pose.pose.orientation.y += odom.pose.pose.orientation.y;\n\
  \        odom_cumulate_.pose.pose.orientation.z += odom.pose.pose.orientation.z;\n\
  \        odom_cumulate_.pose.pose.orientation.w += odom.pose.pose.orientation.w;\n\
  \n        odom_cumulate_.twist.twist.linear.x += odom.twist.twist.linear.x;\n  \
  \      odom_cumulate_.twist.twist.linear.y += odom.twist.twist.linear.y;\n     \
  \   odom_cumulate_.twist.twist.linear.z += odom.twist.twist.linear.z;\n\n      \
  \  odom_cumulate_.twist.twist.angular.x += odom.twist.twist.angular.x;\n       \
  \ odom_cumulate_.twist.twist.angular.y += odom.twist.twist.angular.y;\n        odom_cumulate_.twist.twist.angular.z\
  \ += odom.twist.twist.angular.z;\n    }\n\n    // Average the accumulated data\n\
  \    odom_cumulate_.pose.pose.position.x /= count;\n    odom_cumulate_.pose.pose.position.y\
  \ /= count;\n    odom_cumulate_.pose.pose.position.z /= count;\n\n    odom_cumulate_.pose.pose.orientation.x\
  \ /= count;\n    odom_cumulate_.pose.pose.orientation.y /= count;\n    odom_cumulate_.pose.pose.orientation.z\
  \ /= count;\n    odom_cumulate_.pose.pose.orientation.w /= count;\n\n    odom_cumulate_.twist.twist.linear.x\
  \ /= count;\n    odom_cumulate_.twist.twist.linear.y /= count;\n    odom_cumulate_.twist.twist.linear.z\
  \ /= count;\n\n    odom_cumulate_.twist.twist.angular.x /= count;\n    odom_cumulate_.twist.twist.angular.y\
  \ /= count;\n    odom_cumulate_.twist.twist.angular.z /= count;\n\n    // Normalize\
  \ the orientation quaternion\n    double norm = std::sqrt(\n        odom_cumulate_.pose.pose.orientation.x\
  \ * odom_cumulate_.pose.pose.orientation.x +\n        odom_cumulate_.pose.pose.orientation.y\
  \ * odom_cumulate_.pose.pose.orientation.y +\n        odom_cumulate_.pose.pose.orientation.z\
  \ * odom_cumulate_.pose.pose.orientation.z +\n        odom_cumulate_.pose.pose.orientation.w\
  \ * odom_cumulate_.pose.pose.orientation.w\n    );\n\n    if (norm > 0.0) {\n  \
  \      odom_cumulate_.pose.pose.orientation.x /= norm;\n        odom_cumulate_.pose.pose.orientation.y\
  \ /= norm;\n        odom_cumulate_.pose.pose.orientation.z /= norm;\n        odom_cumulate_.pose.pose.orientation.w\
  \ /= norm;\n    }\n\n    // Update the smoothed velocity message\n    vel_smooth_.header.stamp\
  \ = current_time;\n    vel_smooth_.twist = odom_cumulate_.twist.twist;\n\n    //\
  \ Call the updateState function to handle the updated state\n    updateState();\n\
  }"
ground_truth.cpp: |-
  void OdomSmoother::odomCallback(const nav_msgs::msg::Odometry::SharedPtr msg)
  {
    std::lock_guard<std::mutex> lock(odom_mutex_);

    // update cumulated odom only if history is not empty
    if (!odom_history_.empty()) {
      // to store current time
      auto current_time = rclcpp::Time(msg->header.stamp);

      // to store time of the first odom in history
      auto front_time = rclcpp::Time(odom_history_.front().header.stamp);

      // update cumulated odom when duration has exceeded and pop earliest msg
      while (current_time - front_time > odom_history_duration_) {
        const auto & odom = odom_history_.front();
        odom_cumulate_.twist.twist.linear.x -= odom.twist.twist.linear.x;
        odom_cumulate_.twist.twist.linear.y -= odom.twist.twist.linear.y;
        odom_cumulate_.twist.twist.linear.z -= odom.twist.twist.linear.z;
        odom_cumulate_.twist.twist.angular.x -= odom.twist.twist.angular.x;
        odom_cumulate_.twist.twist.angular.y -= odom.twist.twist.angular.y;
        odom_cumulate_.twist.twist.angular.z -= odom.twist.twist.angular.z;
        odom_history_.pop_front();

        if (odom_history_.empty()) {
          break;
        }

        // update with the timestamp of earliest odom message in history
        front_time = rclcpp::Time(odom_history_.front().header.stamp);
      }
    }

    odom_history_.push_back(*msg);
    updateState();
  }
