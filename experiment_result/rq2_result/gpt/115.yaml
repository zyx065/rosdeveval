compilation.log: |
  Starting >>> autoware_motion_velocity_dynamic_obstacle_stop_module
  --- stderr: autoware_motion_velocity_dynamic_obstacle_stop_module
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp: In function ‘bool autoware::motion_velocity_planner::dynamic_obstacle_stop::is_unavoidable(const PredictedObject&, const Pose&, const std::optional<geometry_msgs::msg::Pose_<std::allocator<void> > >&, const autoware::motion_velocity_planner::dynamic_obstacle_stop::PlannerParam&)’:
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp:94:47: error: ‘const struct autoware::motion_velocity_planner::dynamic_obstacle_stop::PlannerParam’ has no member named ‘unavoidable_collision’; did you mean ‘ignore_unavoidable_collisions’?
     94 |       if (std::abs(lateral_distance) < params.unavoidable_collision.lateral_threshold &&
        |                                               ^~~~~~~~~~~~~~~~~~~~~
        |                                               ignore_unavoidable_collisions
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp:96:42: error: ‘const struct autoware::motion_velocity_planner::dynamic_obstacle_stop::PlannerParam’ has no member named ‘unavoidable_collision’; did you mean ‘ignore_unavoidable_collisions’?
     96 |           longitudinal_distance < params.unavoidable_collision.longitudinal_threshold) {
        |                                          ^~~~~~~~~~~~~~~~~~~~~
        |                                          ignore_unavoidable_collisions
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp:83:20: error: unused variable ‘predicted_point’ [-Werror=unused-variable]
     83 |       const auto & predicted_point = predicted_path.path[i];
        |                    ^~~~~~~~~~~~~~~
  cc1plus: all warnings being treated as errors
  gmake[2]: *** [CMakeFiles/autoware_motion_velocity_dynamic_obstacle_stop_module.dir/build.make:132: CMakeFiles/autoware_motion_velocity_dynamic_obstacle_stop_module.dir/src/object_filtering.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:157: CMakeFiles/autoware_motion_velocity_dynamic_obstacle_stop_module.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_motion_velocity_dynamic_obstacle_stop_module [10.2s, exited with code 2]

  Summary: 0 packages finished [11.7s]
    1 package failed: autoware_motion_velocity_dynamic_obstacle_stop_module
    1 package had stderr output: autoware_motion_velocity_dynamic_obstacle_stop_module
generate_code.cpp: |-
  bool is_unavoidable(
    const autoware_perception_msgs::msg::PredictedObject & object,
    const geometry_msgs::msg::Pose & ego_pose,
    const std::optional<geometry_msgs::msg::Pose> & ego_earliest_stop_pose,
    const PlannerParam & params)
  {
    // Check if the object has a valid predicted path
    if (object.kinematics.predicted_paths.empty()) {
      return false;
    }

    // Extract the ego vehicle's earliest stop pose
    geometry_msgs::msg::Pose stop_pose = ego_earliest_stop_pose.value_or(ego_pose);

    // Iterate through each predicted path of the object
    for (const auto & predicted_path : object.kinematics.predicted_paths) {
      // Iterate through the points in the predicted path
      for (size_t i = 0; i < predicted_path.path.size(); ++i) {
        const auto & predicted_point = predicted_path.path[i];

        // Calculate the lateral distance between the predicted point and the ego vehicle's stop pose
        const double lateral_distance = motion_utils::calcLateralOffset(
          predicted_path.path, stop_pose.position);

        // Calculate the longitudinal distance between the predicted point and the ego vehicle's stop pose
        const double longitudinal_distance = motion_utils::calcSignedArcLength(
          predicted_path.path, 0, i);

        // Check if the object is within the collision thresholds
        if (std::abs(lateral_distance) < params.unavoidable_collision.lateral_threshold &&
            longitudinal_distance > 0.0 &&
            longitudinal_distance < params.unavoidable_collision.longitudinal_threshold) {
          return true;
        }
      }
    }

    return false;
  }
ground_truth.cpp: |-
  bool is_unavoidable(
    const autoware_perception_msgs::msg::PredictedObject & object,
    const geometry_msgs::msg::Pose & ego_pose,
    const std::optional<geometry_msgs::msg::Pose> & ego_earliest_stop_pose,
    const PlannerParam & params)
  {
    constexpr auto same_direction_diff_threshold = M_PI_2 + M_PI_4;
    const auto & o_pose = object.kinematics.initial_pose_with_covariance.pose;
    const auto o_yaw = tf2::getYaw(o_pose.orientation);
    const auto ego_yaw = tf2::getYaw(ego_pose.orientation);
    const auto yaw_diff = std::abs(universe_utils::normalizeRadian(o_yaw - ego_yaw));
    const auto opposite_heading = yaw_diff > same_direction_diff_threshold;
    const auto collision_distance_threshold =
      params.ego_lateral_offset + object.shape.dimensions.y / 2.0 + params.hysteresis;
    const auto lat_distance =
      std::abs(universe_utils::calcLateralDeviation(o_pose, ego_pose.position));
    auto has_collision = opposite_heading && lat_distance <= collision_distance_threshold;
    if (ego_earliest_stop_pose) {
      const auto direction_yaw = std::atan2(
        o_pose.position.y - ego_earliest_stop_pose->position.y,
        o_pose.position.x - ego_earliest_stop_pose->position.x);
      const auto yaw_diff_at_earliest_stop_pose =
        std::abs(universe_utils::normalizeRadian(o_yaw - direction_yaw));
      const auto lat_distance_at_earliest_stop_pose =
        std::abs(universe_utils::calcLateralDeviation(o_pose, ego_earliest_stop_pose->position));
      const auto collision_at_earliest_stop_pose =
        yaw_diff_at_earliest_stop_pose > same_direction_diff_threshold &&
        lat_distance_at_earliest_stop_pose <= collision_distance_threshold;
      has_collision |= collision_at_earliest_stop_pose;
    }
    return has_collision;
  }
