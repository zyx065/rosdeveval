compilation.log: |
  Starting >>> dwb_critics
  Finished <<< dwb_critics [0.67s]

  Summary: 1 package finished [0.91s]
generate_code.cpp: |-
  Footprint getOrientedFootprint(
    const geometry_msgs::msg::Pose2D & pose,
    const Footprint & footprint_spec)
  {
    Footprint oriented_footprint;

    // Iterate through each point in the local footprint specification
    for (const auto & point : footprint_spec) {
      geometry_msgs::msg::Point transformed_point;

      // Apply rotation and translation to transform the point
      transformed_point.x = pose.x + (point.x * cos(pose.theta) - point.y * sin(pose.theta));
      transformed_point.y = pose.y + (point.x * sin(pose.theta) + point.y * cos(pose.theta));
      transformed_point.z = point.z; // Assuming z remains unchanged

      // Add the transformed point to the oriented footprint
      oriented_footprint.push_back(transformed_point);
    }

    return oriented_footprint;
  }
ground_truth.cpp: |-
  Footprint getOrientedFootprint(
    const geometry_msgs::msg::Pose2D & pose,
    const Footprint & footprint_spec)
  {
    std::vector<geometry_msgs::msg::Point> oriented_footprint;
    oriented_footprint.resize(footprint_spec.size());
    double cos_th = cos(pose.theta);
    double sin_th = sin(pose.theta);
    for (unsigned int i = 0; i < footprint_spec.size(); ++i) {
      geometry_msgs::msg::Point & new_pt = oriented_footprint[i];
      new_pt.x = pose.x + footprint_spec[i].x * cos_th - footprint_spec[i].y * sin_th;
      new_pt.y = pose.y + footprint_spec[i].x * sin_th + footprint_spec[i].y * cos_th;
    }
    return oriented_footprint;
  }
