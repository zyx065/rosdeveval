compilation.log: |
  Starting >>> autoware_planning_validator
  --- stderr: autoware_planning_validator
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_planning_validator/src/planning_validator.cpp: In member function ‘bool autoware::planning_validator::PlanningValidator::checkValidInterval(const Trajectory&)’:
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_planning_validator/src/planning_validator.cpp:354:24: error: ‘using PlanningValidatorStatus = struct autoware_planning_validator::msg::PlanningValidatorStatus_<std::allocator<void> >’ {aka ‘struct autoware_planning_validator::msg::PlanningValidatorStatus_<std::allocator<void> >’} has no member named ‘is_valid’; did you mean ‘is_valid_size’?
    354 |     validation_status_.is_valid = false;
        |                        ^~~~~~~~
        |                        is_valid_size
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_planning_validator/src/planning_validator.cpp:355:24: error: ‘using PlanningValidatorStatus = struct autoware_planning_validator::msg::PlanningValidatorStatus_<std::allocator<void> >’ {aka ‘struct autoware_planning_validator::msg::PlanningValidatorStatus_<std::allocator<void> >’} has no member named ‘error_message’
    355 |     validation_status_.error_message = "Interval distance exceeds threshold.";
        |                        ^~~~~~~~~~~~~
  gmake[2]: *** [CMakeFiles/autoware_planning_validator_component.dir/build.make:76: CMakeFiles/autoware_planning_validator_component.dir/src/planning_validator.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:239: CMakeFiles/autoware_planning_validator_component.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_planning_validator [8.40s, exited with code 2]

  Summary: 0 packages finished [9.78s]
    1 package failed: autoware_planning_validator
    1 package had stderr output: autoware_planning_validator
generate_code.cpp: |-
  bool PlanningValidator::checkValidInterval(const Trajectory & trajectory)
  {
    // Check if the trajectory is empty or has only one point
    if (trajectory.points.empty() || trajectory.points.size() == 1) {
      return true; // A single point or empty trajectory is considered valid
    }

    // Calculate the maximum interval distance and its index
    auto [max_interval_distance, max_interval_index] = calcMaxIntervalDistance(trajectory);

    // Check if the maximum interval distance exceeds the threshold
    if (max_interval_distance > validation_params_.interval_threshold) {
      // Update validation status
      validation_status_.is_valid = false;
      validation_status_.error_message = "Interval distance exceeds threshold.";

      // Publish debug marker for the problematic point
      if (debug_pose_publisher_) {
        debug_pose_publisher_->pushPoseMarker(
          trajectory.points[max_interval_index].pose, "InvalidInterval", max_interval_index);
        debug_pose_publisher_->pushWarningMsg(
          trajectory.points[max_interval_index].pose,
          "Interval distance exceeds threshold.");
        debug_pose_publisher_->publish();
      }

      return false; // Trajectory is invalid
    }

    // If all intervals are valid, return true
    return true;
  }
ground_truth.cpp: |-
  bool PlanningValidator::checkValidInterval(const Trajectory & trajectory)
  {
    const auto [max_interval_distance, i] = calcMaxIntervalDistance(trajectory);
    validation_status_.max_interval_distance = max_interval_distance;

    if (max_interval_distance > validation_params_.interval_threshold) {
      if (i > 0) {
        const auto & p = trajectory.points;
        debug_pose_publisher_->pushPoseMarker(p.at(i - 1), "trajectory_interval");
        debug_pose_publisher_->pushPoseMarker(p.at(i), "trajectory_interval");
      }
      return false;
    }

    return true;
  }
