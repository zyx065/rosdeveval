compilation.log: |
  Starting >>> moveit_core
  --- stderr: moveit_core
  /root/repos/moveit_ws/src/moveit2/moveit_core/constraint_samplers/src/default_constraint_samplers.cpp: In member function ‘bool constraint_samplers::IKConstraintSampler::callIK(const Pose&, const IKCallbackFn&, double, moveit::core::RobotState&, bool)’:
  /root/repos/moveit_ws/src/moveit2/moveit_core/constraint_samplers/src/default_constraint_samplers.cpp:689:38: error: no match for call to ‘(const IKCallbackFn {aka const std::function<void(const geometry_msgs::msg::Pose_<std::allocator<void> >&, const std::vector<double>&, moveit_msgs::msg::MoveItErrorCodes_<std::allocator<void> >&)>}) (std::vector<double>&, moveit_msgs::msg::MoveItErrorCodes&)’
    689 |     if (!adapted_ik_validity_callback(solution, error_code))
        |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~
  In file included from /usr/include/c++/11/functional:59,
                   from /usr/include/c++/11/pstl/glue_algorithm_defs.h:13,
                   from /usr/include/c++/11/algorithm:74,
                   from /root/repos/moveit_ws/install/moveit_msgs/include/moveit_msgs/moveit_msgs/msg/detail/joint_limits__struct.hpp:8,
                   from /root/repos/moveit_ws/install/moveit_msgs/include/moveit_msgs/moveit_msgs/msg/joint_limits.hpp:7,
                   from /root/repos/moveit_ws/src/moveit2/moveit_core/robot_model/include/moveit/robot_model/joint_model.h:44,
                   from /root/repos/moveit_ws/src/moveit2/moveit_core/robot_model/include/moveit/robot_model/joint_model_group.h:40,
                   from /root/repos/moveit_ws/src/moveit2/moveit_core/robot_model/include/moveit/robot_model/robot_model.h:45,
                   from /root/repos/moveit_ws/src/moveit2/moveit_core/planning_scene/include/moveit/planning_scene/planning_scene.h:39,
                   from /root/repos/moveit_ws/src/moveit2/moveit_core/constraint_samplers/include/moveit/constraint_samplers/constraint_sampler.h:39,
                   from /root/repos/moveit_ws/src/moveit2/moveit_core/constraint_samplers/include/moveit/constraint_samplers/default_constraint_samplers.h:39,
                   from /root/repos/moveit_ws/src/moveit2/moveit_core/constraint_samplers/src/default_constraint_samplers.cpp:37:
  /usr/include/c++/11/bits/std_function.h:586:7: note: candidate: ‘_Res std::function<_Res(_ArgTypes ...)>::operator()(_ArgTypes ...) const [with _Res = void; _ArgTypes = {const geometry_msgs::msg::Pose_<std::allocator<void> >&, const std::vector<double, std::allocator<double> >&, moveit_msgs::msg::MoveItErrorCodes_<std::allocator<void> >&}]’
    586 |       operator()(_ArgTypes... __args) const
        |       ^~~~~~~~
  /usr/include/c++/11/bits/std_function.h:586:7: note:   candidate expects 3 arguments, 2 provided
  gmake[2]: *** [constraint_samplers/CMakeFiles/moveit_constraint_samplers.dir/build.make:121: constraint_samplers/CMakeFiles/moveit_constraint_samplers.dir/src/default_constraint_samplers.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:836: constraint_samplers/CMakeFiles/moveit_constraint_samplers.dir/all] Error 2
  gmake: *** [Makefile:149: all] Error 2
  ---
  Failed   <<< moveit_core [7.21s, exited with code 2]

  Summary: 0 packages finished [7.80s]
    1 package failed: moveit_core
    1 package had stderr output: moveit_core
generate_code.cpp: |-
  bool IKConstraintSampler::callIK(const geometry_msgs::msg::Pose& ik_query,
                                   const kinematics::KinematicsBase::IKCallbackFn& adapted_ik_validity_callback,
                                   double timeout, moveit::core::RobotState& state, bool use_as_seed)
  {
    // Ensure the kinematics solver is available
    if (!kb_)
    {
      RCLCPP_ERROR(LOGGER, "No kinematics solver available for group '%s'", jmg_->getName().c_str());
      return false;
    }

    // Get the bijection mapping between the kinematics solver and the joint model group
    const std::vector<size_t>& bijection = jmg_->getKinematicsSolverJointBijection();

    // Prepare the seed state
    std::vector<double> seed_state(kb_->getJointNames().size(), 0.0);
    if (use_as_seed)
    {
      // Use the current state as the seed
      state.copyJointGroupPositions(jmg_, seed_state.data());
    }
    else
    {
      // Generate a random seed state
      for (size_t i = 0; i < seed_state.size(); ++i)
      {
        const moveit::core::JointModel* jm = jmg_->getJointModels()[bijection[i]];
        jm->getVariableRandomPositions(random_number_generator_, &seed_state[i], jm->getVariableBounds());
      }
    }

    // Prepare the solution container
    std::vector<double> solution;
    moveit_msgs::msg::MoveItErrorCodes error_code;

    // Call the IK solver
    bool ik_success = kb_->searchPositionIK(ik_query, seed_state, timeout, solution, error_code);

    if (!ik_success)
    {
      RCLCPP_DEBUG(LOGGER, "IK solver failed to find a solution");
      return false;
    }

    // Set the solution to the robot state
    std::vector<double> full_solution(state.getVariableCount(), 0.0);
    for (size_t i = 0; i < solution.size(); ++i)
    {
      full_solution[bijection[i]] = solution[i];
    }
    state.setJointGroupPositions(jmg_->getName(), full_solution);

    // Validate the solution
    if (adapted_ik_validity_callback)
    {
      if (!adapted_ik_validity_callback(solution, error_code))
      {
        RCLCPP_DEBUG(LOGGER, "IK solution failed the validity callback");
        return false;
      }
    }

    if (!validate(state))
    {
      RCLCPP_DEBUG(LOGGER, "IK solution failed the sampler's validation");
      return false;
    }

    return true;
  }
ground_truth.cpp: |-
  bool IKConstraintSampler::callIK(const geometry_msgs::msg::Pose& ik_query,
                                   const kinematics::KinematicsBase::IKCallbackFn& adapted_ik_validity_callback,
                                   double timeout, moveit::core::RobotState& state, bool use_as_seed)
  {
    const std::vector<size_t>& ik_joint_bijection = jmg_->getKinematicsSolverJointBijection();
    std::vector<double> seed(ik_joint_bijection.size(), 0.0);
    std::vector<double> vals;

    if (use_as_seed)
      state.copyJointGroupPositions(jmg_, vals);
    else
      // sample a seed value
      jmg_->getVariableRandomPositions(random_number_generator_, vals);

    assert(vals.size() == ik_joint_bijection.size());
    for (std::size_t i = 0; i < ik_joint_bijection.size(); ++i)
      seed[i] = vals[ik_joint_bijection[i]];

    std::vector<double> ik_sol;
    moveit_msgs::msg::MoveItErrorCodes error;

    if (adapted_ik_validity_callback ?
            kb_->searchPositionIK(ik_query, seed, timeout, ik_sol, adapted_ik_validity_callback, error) :
            kb_->searchPositionIK(ik_query, seed, timeout, ik_sol, error))
    {
      assert(ik_sol.size() == ik_joint_bijection.size());
      std::vector<double> solution(ik_joint_bijection.size());
      for (std::size_t i = 0; i < ik_joint_bijection.size(); ++i)
        solution[ik_joint_bijection[i]] = ik_sol[i];
      state.setJointGroupPositions(jmg_, solution);

      return validate(state);
    }
    else
    {
      if (error.val != moveit_msgs::msg::MoveItErrorCodes::NO_IK_SOLUTION &&
          error.val != moveit_msgs::msg::MoveItErrorCodes::INVALID_ROBOT_STATE &&
          error.val != moveit_msgs::msg::MoveItErrorCodes::TIMED_OUT)
      {
        RCLCPP_ERROR(LOGGER, "IK solver failed with error %d", error.val);
      }
      else if (verbose_)
      {
        RCLCPP_INFO(LOGGER, "IK failed");
      }
    }
    return false;
  }
