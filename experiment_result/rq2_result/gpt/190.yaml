compilation.log: |
  Starting >>> nav2_collision_monitor
  --- stderr: nav2_collision_monitor
  /root/repos/nav_ws/src/nav2_collision_monitor/src/pointcloud.cpp: In member function ‘virtual void nav2_collision_monitor::PointCloud::getData(const rclcpp::Time&, std::vector<nav2_collision_monitor::Point>&) const’:
  /root/repos/nav_ws/src/nav2_collision_monitor/src/pointcloud.cpp:91:50: error: binding reference of type ‘sensor_msgs::msg::PointCloud2&’ {aka ‘sensor_msgs::msg::PointCloud2_<std::allocator<void> >&’} to ‘std::__shared_ptr_access<const sensor_msgs::msg::PointCloud2_<std::allocator<void> >, __gnu_cxx::_S_atomic, false, false>::element_type’ {aka ‘const sensor_msgs::msg::PointCloud2_<std::allocator<void> >’} discards qualifiers
     91 |   sensor_msgs::PointCloud2Iterator<float> iter_x(*cloud_msg, "x");
        |                                                  ^~~~~~~~~~
  In file included from /root/repos/nav_ws/src/nav2_collision_monitor/src/pointcloud.cpp:19:
  /opt/ros/humble/include/sensor_msgs/sensor_msgs/point_cloud2_iterator.hpp:293:37: note:   initializing argument 1 of ‘sensor_msgs::PointCloud2Iterator<T>::PointCloud2Iterator(sensor_msgs::msg::PointCloud2&, const string&) [with T = float; sensor_msgs::msg::PointCloud2 = sensor_msgs::msg::PointCloud2_<std::allocator<void> >; std::string = std::__cxx11::basic_string<char>]’
    293 |     sensor_msgs::msg::PointCloud2 & cloud_msg,
        |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~
  /root/repos/nav_ws/src/nav2_collision_monitor/src/pointcloud.cpp:92:50: error: binding reference of type ‘sensor_msgs::msg::PointCloud2&’ {aka ‘sensor_msgs::msg::PointCloud2_<std::allocator<void> >&’} to ‘std::__shared_ptr_access<const sensor_msgs::msg::PointCloud2_<std::allocator<void> >, __gnu_cxx::_S_atomic, false, false>::element_type’ {aka ‘const sensor_msgs::msg::PointCloud2_<std::allocator<void> >’} discards qualifiers
     92 |   sensor_msgs::PointCloud2Iterator<float> iter_y(*cloud_msg, "y");
        |                                                  ^~~~~~~~~~
  In file included from /root/repos/nav_ws/src/nav2_collision_monitor/src/pointcloud.cpp:19:
  /opt/ros/humble/include/sensor_msgs/sensor_msgs/point_cloud2_iterator.hpp:293:37: note:   initializing argument 1 of ‘sensor_msgs::PointCloud2Iterator<T>::PointCloud2Iterator(sensor_msgs::msg::PointCloud2&, const string&) [with T = float; sensor_msgs::msg::PointCloud2 = sensor_msgs::msg::PointCloud2_<std::allocator<void> >; std::string = std::__cxx11::basic_string<char>]’
    293 |     sensor_msgs::msg::PointCloud2 & cloud_msg,
        |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~
  /root/repos/nav_ws/src/nav2_collision_monitor/src/pointcloud.cpp:93:50: error: binding reference of type ‘sensor_msgs::msg::PointCloud2&’ {aka ‘sensor_msgs::msg::PointCloud2_<std::allocator<void> >&’} to ‘std::__shared_ptr_access<const sensor_msgs::msg::PointCloud2_<std::allocator<void> >, __gnu_cxx::_S_atomic, false, false>::element_type’ {aka ‘const sensor_msgs::msg::PointCloud2_<std::allocator<void> >’} discards qualifiers
     93 |   sensor_msgs::PointCloud2Iterator<float> iter_z(*cloud_msg, "z");
        |                                                  ^~~~~~~~~~
  In file included from /root/repos/nav_ws/src/nav2_collision_monitor/src/pointcloud.cpp:19:
  /opt/ros/humble/include/sensor_msgs/sensor_msgs/point_cloud2_iterator.hpp:293:37: note:   initializing argument 1 of ‘sensor_msgs::PointCloud2Iterator<T>::PointCloud2Iterator(sensor_msgs::msg::PointCloud2&, const string&) [with T = float; sensor_msgs::msg::PointCloud2 = sensor_msgs::msg::PointCloud2_<std::allocator<void> >; std::string = std::__cxx11::basic_string<char>]’
    293 |     sensor_msgs::msg::PointCloud2 & cloud_msg,
        |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~
  /root/repos/nav_ws/src/nav2_collision_monitor/src/pointcloud.cpp:109:11: error: ‘struct nav2_collision_monitor::Point’ has no member named ‘z’
    109 |     point.z = point_in_base_frame.z();
        |           ^
  gmake[2]: *** [CMakeFiles/collision_monitor_core.dir/build.make:146: CMakeFiles/collision_monitor_core.dir/src/pointcloud.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:180: CMakeFiles/collision_monitor_core.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< nav2_collision_monitor [3.97s, exited with code 2]

  Summary: 0 packages finished [4.22s]
    1 package failed: nav2_collision_monitor
    1 package had stderr output: nav2_collision_monitor
generate_code.cpp: |-
  void PointCloud::getData(
    const rclcpp::Time & curr_time,
    std::vector<Point> & data) const
  {
    // Clear the output data vector
    data.clear();

    // Check if the latest data is valid
    if (!data_ || !sourceValid(data_->header.stamp, curr_time)) {
      return;
    }

    // Obtain the transform from the sensor frame to the base frame
    tf2::Transform tf2_transform;
    if (!nav2_util::getTransform(
          data_->header.frame_id, data_->header.stamp,
          "base_frame", curr_time,
          "odom", tf2::Duration(std::chrono::milliseconds(100)),
          tf_buffer_, tf2_transform)) {
      return;
    }

    // Convert the PointCloud2 data into a PointCloud object
    sensor_msgs::msg::PointCloud2::ConstSharedPtr cloud_msg = data_;
    sensor_msgs::PointCloud2Iterator<float> iter_x(*cloud_msg, "x");
    sensor_msgs::PointCloud2Iterator<float> iter_y(*cloud_msg, "y");
    sensor_msgs::PointCloud2Iterator<float> iter_z(*cloud_msg, "z");

    for (; iter_x != iter_x.end(); ++iter_x, ++iter_y, ++iter_z) {
      // Filter points based on height
      if (*iter_z < min_height_ || *iter_z > max_height_) {
        continue;
      }

      // Transform the point to the base frame
      tf2::Vector3 point_in_sensor_frame(*iter_x, *iter_y, *iter_z);
      tf2::Vector3 point_in_base_frame = tf2_transform * point_in_sensor_frame;

      // Add the transformed point to the output vector
      Point point;
      point.x = point_in_base_frame.x();
      point.y = point_in_base_frame.y();
      point.z = point_in_base_frame.z();
      data.push_back(point);
    }
  }
ground_truth.cpp: |-
  void PointCloud::getData(
    const rclcpp::Time & curr_time,
    std::vector<Point> & data) const
  {
    // Ignore data from the source if it is not being published yet or
    // not published for a long time
    if (data_ == nullptr) {
      return;
    }
    if (!sourceValid(data_->header.stamp, curr_time)) {
      return;
    }

    tf2::Transform tf_transform;
    if (base_shift_correction_) {
      // Obtaining the transform to get data from source frame and time where it was received
      // to the base frame and current time
      if (
        !nav2_util::getTransform(
          data_->header.frame_id, data_->header.stamp,
          base_frame_id_, curr_time, global_frame_id_,
          transform_tolerance_, tf_buffer_, tf_transform))
      {
        return;
      }
    } else {
      // Obtaining the transform to get data from source frame to base frame without time shift
      // considered. Less accurate but much more faster option not dependent on state estimation
      // frames.
      if (
        !nav2_util::getTransform(
          data_->header.frame_id, base_frame_id_,
          transform_tolerance_, tf_buffer_, tf_transform))
      {
        return;
      }
    }

    sensor_msgs::PointCloud2ConstIterator<float> iter_x(*data_, "x");
    sensor_msgs::PointCloud2ConstIterator<float> iter_y(*data_, "y");
    sensor_msgs::PointCloud2ConstIterator<float> iter_z(*data_, "z");

    // Refill data array with PointCloud points in base frame
    for (; iter_x != iter_x.end(); ++iter_x, ++iter_y, ++iter_z) {
      // Transform point coordinates from source frame -> to base frame
      tf2::Vector3 p_v3_s(*iter_x, *iter_y, *iter_z);
      tf2::Vector3 p_v3_b = tf_transform * p_v3_s;

      // Refill data array
      if (p_v3_b.z() >= min_height_ && p_v3_b.z() <= max_height_) {
        data.push_back({p_v3_b.x(), p_v3_b.y()});
      }
    }
  }
