compilation.log: |
  Starting >>> autoware_motion_velocity_dynamic_obstacle_stop_module
  --- stderr: autoware_motion_velocity_dynamic_obstacle_stop_module
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp: In function ‘std::vector<autoware_perception_msgs::msg::PredictedObject_<std::allocator<void> >, std::allocator<autoware_perception_msgs::msg::PredictedObject_<std::allocator<void> > > > autoware::motion_velocity_planner::dynamic_obstacle_stop::filter_predicted_objects(const std::vector<autoware::motion_velocity_planner::PlannerData::Object>&, const autoware::motion_velocity_planner::dynamic_obstacle_stop::EgoData&, const autoware::motion_velocity_planner::dynamic_obstacle_stop::PlannerParam&, double)’:
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp:118:64: error: ‘const struct autoware::motion_velocity_planner::dynamic_obstacle_stop::EgoData’ has no member named ‘longitudinal_offset’
    118 |     if (!is_not_too_close(predicted_object, ego_data, ego_data.longitudinal_offset)) {
        |                                                                ^~~~~~~~~~~~~~~~~~~
  gmake[2]: *** [CMakeFiles/autoware_motion_velocity_dynamic_obstacle_stop_module.dir/build.make:132: CMakeFiles/autoware_motion_velocity_dynamic_obstacle_stop_module.dir/src/object_filtering.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:157: CMakeFiles/autoware_motion_velocity_dynamic_obstacle_stop_module.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_motion_velocity_dynamic_obstacle_stop_module [9.87s, exited with code 2]

  Summary: 0 packages finished [11.3s]
    1 package failed: autoware_motion_velocity_dynamic_obstacle_stop_module
    1 package had stderr output: autoware_motion_velocity_dynamic_obstacle_stop_module
generate_code.cpp: |-
  std::vector<autoware_perception_msgs::msg::PredictedObject> filter_predicted_objects(
    const std::vector<PlannerData::Object> & objects, const EgoData & ego_data,
    const PlannerParam & params, const double hysteresis)
  {
    std::vector<autoware_perception_msgs::msg::PredictedObject> filtered_objects;

    for (const auto & object : objects) {
      const auto & predicted_object = object.predicted_object;

      // Check if the object is a vehicle
      if (!is_vehicle(predicted_object)) {
        continue;
      }

      // Check if the object is within range
      if (!is_in_range(predicted_object, ego_data.trajectory, params, hysteresis)) {
        continue;
      }

      // Check if the object is not too close to the ego vehicle
      if (!is_not_too_close(predicted_object, ego_data, ego_data.longitudinal_offset)) {
        continue;
      }

      // Check if the object poses an unavoidable collision risk
      if (!is_unavoidable(predicted_object, ego_data.pose, ego_data.earliest_stop_pose, params)) {
        continue;
      }

      // If all checks pass, add the object to the filtered list
      filtered_objects.push_back(predicted_object);
    }

    return filtered_objects;
  }
ground_truth.cpp: |-
  std::vector<autoware_perception_msgs::msg::PredictedObject> filter_predicted_objects(
    const std::vector<PlannerData::Object> & objects, const EgoData & ego_data,
    const PlannerParam & params, const double hysteresis)
  {
    std::vector<autoware_perception_msgs::msg::PredictedObject> filtered_objects;
    for (const auto & object : objects) {
      const auto & predicted_object = object.predicted_object;
      const auto is_not_too_slow =
        predicted_object.kinematics.initial_twist_with_covariance.twist.linear.x >=
        params.minimum_object_velocity;
      if (
        is_vehicle(predicted_object) && is_not_too_slow &&
        is_in_range(predicted_object, ego_data.trajectory, params, hysteresis) &&
        is_not_too_close(predicted_object, ego_data, params.ego_longitudinal_offset) &&
        (!params.ignore_unavoidable_collisions ||
         !is_unavoidable(predicted_object, ego_data.pose, ego_data.earliest_stop_pose, params)))
        filtered_objects.push_back(predicted_object);
    }
    return filtered_objects;
  }
