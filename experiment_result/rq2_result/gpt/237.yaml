compilation.log: |
  Starting >>> autoware_vehicle_cmd_gate
  --- stderr: autoware_vehicle_cmd_gate
  In file included from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:15:
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.hpp: In constructor ‘autoware::vehicle_cmd_gate::VehicleCmdGate::VehicleCmdGate(const rclcpp::NodeOptions&)’:
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.hpp:240:31: error: ‘autoware::vehicle_cmd_gate::VehicleCmdGate::updater_’ will be initialized after [-Werror=reorder]
    240 |   diagnostic_updater::Updater updater_;
        |                               ^~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.hpp:142:12: error:   ‘tier4_control_msgs::msg::GateMode autoware::vehicle_cmd_gate::VehicleCmdGate::current_gate_mode_’ [-Werror=reorder]
    142 |   GateMode current_gate_mode_;
        |            ^~~~~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:49:1: error:   when initialized here [-Werror=reorder]
     49 | VehicleCmdGate::VehicleCmdGate(const rclcpp::NodeOptions & node_options)
        | ^~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:50:79: error: no matching function for call to ‘tier4_control_msgs::msg::GateMode_<std::allocator<void> >::GateMode_(const uint8_t&)’
     50 | : Node("vehicle_cmd_gate", node_options), is_engaged_(false), updater_(this), current_gate_mode_(GateMode::AUTO)
        |                                                                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  In file included from /workspace/repos/autoware/install/tier4_control_msgs/include/tier4_control_msgs/tier4_control_msgs/msg/gate_mode.hpp:7,
                   from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.hpp:45,
                   from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:15:
  /workspace/repos/autoware/install/tier4_control_msgs/include/tier4_control_msgs/tier4_control_msgs/msg/detail/gate_mode__struct.hpp:45:12: note: candidate: ‘tier4_control_msgs::msg::GateMode_<ContainerAllocator>::GateMode_(const ContainerAllocator&, rosidl_runtime_cpp::MessageInitialization) [with ContainerAllocator = std::allocator<void>]’
     45 |   explicit GateMode_(const ContainerAllocator & _alloc, rosidl_runtime_cpp::MessageInitialization _init = rosidl_runtime_cpp::MessageInitialization::ALL)
        |            ^~~~~~~~~
  /workspace/repos/autoware/install/tier4_control_msgs/include/tier4_control_msgs/tier4_control_msgs/msg/detail/gate_mode__struct.hpp:45:49: note:   no known conversion for argument 1 from ‘const uint8_t’ {aka ‘const unsigned char’} to ‘const std::allocator<void>&’
     45 |   explicit GateMode_(const ContainerAllocator & _alloc, rosidl_runtime_cpp::MessageInitialization _init = rosidl_runtime_cpp::MessageInitialization::ALL)
        |                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~
  /workspace/repos/autoware/install/tier4_control_msgs/include/tier4_control_msgs/tier4_control_msgs/msg/detail/gate_mode__struct.hpp:36:12: note: candidate: ‘tier4_control_msgs::msg::GateMode_<ContainerAllocator>::GateMode_(rosidl_runtime_cpp::MessageInitialization) [with ContainerAllocator = std::allocator<void>]’
     36 |   explicit GateMode_(rosidl_runtime_cpp::MessageInitialization _init = rosidl_runtime_cpp::MessageInitialization::ALL)
        |            ^~~~~~~~~
  /workspace/repos/autoware/install/tier4_control_msgs/include/tier4_control_msgs/tier4_control_msgs/msg/detail/gate_mode__struct.hpp:36:64: note:   no known conversion for argument 1 from ‘const uint8_t’ {aka ‘const unsigned char’} to ‘rosidl_runtime_cpp::MessageInitialization’
     36 |   explicit GateMode_(rosidl_runtime_cpp::MessageInitialization _init = rosidl_runtime_cpp::MessageInitialization::ALL)
        |                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  /workspace/repos/autoware/install/tier4_control_msgs/include/tier4_control_msgs/tier4_control_msgs/msg/detail/gate_mode__struct.hpp:32:8: note: candidate: ‘constexpr tier4_control_msgs::msg::GateMode_<std::allocator<void> >::GateMode_(const tier4_control_msgs::msg::GateMode_<std::allocator<void> >&)’
     32 | struct GateMode_
        |        ^~~~~~~~~
  /workspace/repos/autoware/install/tier4_control_msgs/include/tier4_control_msgs/tier4_control_msgs/msg/detail/gate_mode__struct.hpp:32:8: note:   no known conversion for argument 1 from ‘const uint8_t’ {aka ‘const unsigned char’} to ‘const tier4_control_msgs::msg::GateMode_<std::allocator<void> >&’
  /workspace/repos/autoware/install/tier4_control_msgs/include/tier4_control_msgs/tier4_control_msgs/msg/detail/gate_mode__struct.hpp:32:8: note: candidate: ‘constexpr tier4_control_msgs::msg::GateMode_<std::allocator<void> >::GateMode_(tier4_control_msgs::msg::GateMode_<std::allocator<void> >&&)’
  /workspace/repos/autoware/install/tier4_control_msgs/include/tier4_control_msgs/tier4_control_msgs/msg/detail/gate_mode__struct.hpp:32:8: note:   no known conversion for argument 1 from ‘const uint8_t’ {aka ‘const unsigned char’} to ‘tier4_control_msgs::msg::GateMode_<std::allocator<void> >&&’
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:60:36: error: no match for ‘operator=’ (operand types are ‘tier4_control_msgs::msg::GateMode’ {aka ‘tier4_control_msgs::msg::GateMode_<std::allocator<void> >’} and ‘const uint8_t’ {aka ‘const unsigned char’})
     60 |     current_gate_mode_ = GateMode::AUTO;
        |                                    ^~~~
  In file included from /workspace/repos/autoware/install/tier4_control_msgs/include/tier4_control_msgs/tier4_control_msgs/msg/gate_mode.hpp:7,
                   from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.hpp:45,
                   from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:15:
  /workspace/repos/autoware/install/tier4_control_msgs/include/tier4_control_msgs/tier4_control_msgs/msg/detail/gate_mode__struct.hpp:32:8: note: candidate: ‘constexpr tier4_control_msgs::msg::GateMode_<std::allocator<void> >& tier4_control_msgs::msg::GateMode_<std::allocator<void> >::operator=(const tier4_control_msgs::msg::GateMode_<std::allocator<void> >&)’
     32 | struct GateMode_
        |        ^~~~~~~~~
  /workspace/repos/autoware/install/tier4_control_msgs/include/tier4_control_msgs/tier4_control_msgs/msg/detail/gate_mode__struct.hpp:32:8: note:   no known conversion for argument 1 from ‘const uint8_t’ {aka ‘const unsigned char’} to ‘const tier4_control_msgs::msg::GateMode_<std::allocator<void> >&’
  /workspace/repos/autoware/install/tier4_control_msgs/include/tier4_control_msgs/tier4_control_msgs/msg/detail/gate_mode__struct.hpp:32:8: note: candidate: ‘constexpr tier4_control_msgs::msg::GateMode_<std::allocator<void> >& tier4_control_msgs::msg::GateMode_<std::allocator<void> >::operator=(tier4_control_msgs::msg::GateMode_<std::allocator<void> >&&)’
  /workspace/repos/autoware/install/tier4_control_msgs/include/tier4_control_msgs/tier4_control_msgs/msg/detail/gate_mode__struct.hpp:32:8: note:   no known conversion for argument 1 from ‘const uint8_t’ {aka ‘const unsigned char’} to ‘tier4_control_msgs::msg::GateMode_<std::allocator<void> >&&’
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:62:36: error: ‘MANUAL’ is not a member of ‘tier4_control_msgs::msg::GateMode’ {aka ‘tier4_control_msgs::msg::GateMode_<std::allocator<void> >’}
     62 |     current_gate_mode_ = GateMode::MANUAL;
        |                                    ^~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:65:36: error: no match for ‘operator=’ (operand types are ‘tier4_control_msgs::msg::GateMode’ {aka ‘tier4_control_msgs::msg::GateMode_<std::allocator<void> >’} and ‘const uint8_t’ {aka ‘const unsigned char’})
     65 |     current_gate_mode_ = GateMode::AUTO;
        |                                    ^~~~
  In file included from /workspace/repos/autoware/install/tier4_control_msgs/include/tier4_control_msgs/tier4_control_msgs/msg/gate_mode.hpp:7,
                   from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.hpp:45,
                   from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:15:
  /workspace/repos/autoware/install/tier4_control_msgs/include/tier4_control_msgs/tier4_control_msgs/msg/detail/gate_mode__struct.hpp:32:8: note: candidate: ‘constexpr tier4_control_msgs::msg::GateMode_<std::allocator<void> >& tier4_control_msgs::msg::GateMode_<std::allocator<void> >::operator=(const tier4_control_msgs::msg::GateMode_<std::allocator<void> >&)’
     32 | struct GateMode_
        |        ^~~~~~~~~
  /workspace/repos/autoware/install/tier4_control_msgs/include/tier4_control_msgs/tier4_control_msgs/msg/detail/gate_mode__struct.hpp:32:8: note:   no known conversion for argument 1 from ‘const uint8_t’ {aka ‘const unsigned char’} to ‘const tier4_control_msgs::msg::GateMode_<std::allocator<void> >&’
  /workspace/repos/autoware/install/tier4_control_msgs/include/tier4_control_msgs/tier4_control_msgs/msg/detail/gate_mode__struct.hpp:32:8: note: candidate: ‘constexpr tier4_control_msgs::msg::GateMode_<std::allocator<void> >& tier4_control_msgs::msg::GateMode_<std::allocator<void> >::operator=(tier4_control_msgs::msg::GateMode_<std::allocator<void> >&&)’
  /workspace/repos/autoware/install/tier4_control_msgs/include/tier4_control_msgs/tier4_control_msgs/msg/detail/gate_mode__struct.hpp:32:8: note:   no known conversion for argument 1 from ‘const uint8_t’ {aka ‘const unsigned char’} to ‘tier4_control_msgs::msg::GateMode_<std::allocator<void> >&&’
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:69:3: error: ‘vehicle_cmd_publisher_’ was not declared in this scope
     69 |   vehicle_cmd_publisher_ = create_publisher<tier4_control_msgs::msg::VehicleCommand>("output/vehicle_cmd", 10);
        |   ^~~~~~~~~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:69:70: error: ‘VehicleCommand’ is not a member of ‘tier4_control_msgs::msg’
     69 |   vehicle_cmd_publisher_ = create_publisher<tier4_control_msgs::msg::VehicleCommand>("output/vehicle_cmd", 10);
        |                                                                      ^~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:69:85: error: no matching function for call to ‘autoware::vehicle_cmd_gate::VehicleCmdGate::create_publisher<<expression error> >(const char [19], int)’
     69 |   vehicle_cmd_publisher_ = create_publisher<tier4_control_msgs::msg::VehicleCommand>("output/vehicle_cmd", 10);
        |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~
  In file included from /opt/ros/humble/include/rclcpp/rclcpp/node.hpp:1321,
                   from /opt/ros/humble/include/rclcpp/rclcpp/executors/single_threaded_executor.hpp:28,
                   from /opt/ros/humble/include/rclcpp/rclcpp/executors.hpp:22,
                   from /opt/ros/humble/include/rclcpp/rclcpp/rclcpp.hpp:155,
                   from /workspace/repos/autoware/install/autoware_component_interface_utils/include/autoware/component_interface_utils/rclcpp/interface.hpp:18,
                   from /workspace/repos/autoware/install/autoware_component_interface_utils/include/autoware/component_interface_utils/rclcpp/create_interface.hpp:18,
                   from /workspace/repos/autoware/install/autoware_component_interface_utils/include/autoware/component_interface_utils/rclcpp.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/adapi_pause_interface.hpp:19,
                   from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:15:
  /opt/ros/humble/include/rclcpp/rclcpp/node_impl.hpp:73:1: note: candidate: ‘template<class MessageT, class AllocatorT, class PublisherT> std::shared_ptr<PublisherT> rclcpp::Node::create_publisher(const string&, const rclcpp::QoS&, const rclcpp::PublisherOptionsWithAllocator<AllocatorT>&)’
     73 | Node::create_publisher(
        | ^~~~
  /opt/ros/humble/include/rclcpp/rclcpp/node_impl.hpp:73:1: note:   template argument deduction/substitution failed:
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:69:85: error: template argument 1 is invalid
     69 |   vehicle_cmd_publisher_ = create_publisher<tier4_control_msgs::msg::VehicleCommand>("output/vehicle_cmd", 10);
        |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:70:3: error: ‘gate_mode_publisher_’ was not declared in this scope; did you mean ‘gate_mode_pub_’?
     70 |   gate_mode_publisher_ = create_publisher<tier4_control_msgs::msg::GateMode>("output/gate_mode", 10);
        |   ^~~~~~~~~~~~~~~~~~~~
        |   gate_mode_pub_
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:73:3: error: ‘auto_control_cmd_subscriber_’ was not declared in this scope; did you mean ‘auto_control_cmd_sub_’?
     73 |   auto_control_cmd_subscriber_ = create_subscription<tier4_control_msgs::msg::VehicleCommand>(
        |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
        |   auto_control_cmd_sub_
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:73:79: error: ‘VehicleCommand’ is not a member of ‘tier4_control_msgs::msg’
     73 |   auto_control_cmd_subscriber_ = create_subscription<tier4_control_msgs::msg::VehicleCommand>(
        |                                                                               ^~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:74:62: error: ‘onAutoControlCmd’ is not a member of ‘autoware::vehicle_cmd_gate::VehicleCmdGate’
     74 |     "input/auto_control_cmd", 10, std::bind(&VehicleCmdGate::onAutoControlCmd, this, std::placeholders::_1));
        |                                                              ^~~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:75:3: error: ‘manual_control_cmd_subscriber_’ was not declared in this scope
     75 |   manual_control_cmd_subscriber_ = create_subscription<tier4_control_msgs::msg::VehicleCommand>(
        |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:75:81: error: ‘VehicleCommand’ is not a member of ‘tier4_control_msgs::msg’
     75 |   manual_control_cmd_subscriber_ = create_subscription<tier4_control_msgs::msg::VehicleCommand>(
        |                                                                                 ^~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:76:64: error: ‘onManualControlCmd’ is not a member of ‘autoware::vehicle_cmd_gate::VehicleCmdGate’
     76 |     "input/manual_control_cmd", 10, std::bind(&VehicleCmdGate::onManualControlCmd, this, std::placeholders::_1));
        |                                                                ^~~~~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:77:3: error: ‘gate_mode_subscriber_’ was not declared in this scope; did you mean ‘gate_mode_sub_’?
     77 |   gate_mode_subscriber_ = create_subscription<tier4_control_msgs::msg::GateMode>(
        |   ^~~~~~~~~~~~~~~~~~~~~
        |   gate_mode_sub_
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:81:3: error: ‘engage_service_’ was not declared in this scope; did you mean ‘onEngageService’?
     81 |   engage_service_ = create_service<std_srvs::srv::SetBool>(
        |   ^~~~~~~~~~~~~~~
        |   onEngageService
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:81:51: error: ‘SetBool’ is not a member of ‘std_srvs::srv’
     81 |   engage_service_ = create_service<std_srvs::srv::SetBool>(
        |                                                   ^~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:81:59: error: no matching function for call to ‘autoware::vehicle_cmd_gate::VehicleCmdGate::create_service<<expression error> >(const char [15], std::_Bind_helper<false, void (autoware::vehicle_cmd_gate::VehicleCmdGate::*)(std::shared_ptr<tier4_external_api_msgs::srv::Engage_Request_<std::allocator<void> > >, std::shared_ptr<tier4_external_api_msgs::srv::Engage_Response_<std::allocator<void> > >), autoware::vehicle_cmd_gate::VehicleCmdGate*, const std::_Placeholder<1>&, const std::_Placeholder<2>&>::type)’
     81 |   engage_service_ = create_service<std_srvs::srv::SetBool>(
        |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
     82 |     "service/engage", std::bind(&VehicleCmdGate::onEngageService, this, std::placeholders::_1, std::placeholders::_2));
        |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  In file included from /opt/ros/humble/include/rclcpp/rclcpp/executors/single_threaded_executor.hpp:28,
                   from /opt/ros/humble/include/rclcpp/rclcpp/executors.hpp:22,
                   from /opt/ros/humble/include/rclcpp/rclcpp/rclcpp.hpp:155,
                   from /workspace/repos/autoware/install/autoware_component_interface_utils/include/autoware/component_interface_utils/rclcpp/interface.hpp:18,
                   from /workspace/repos/autoware/install/autoware_component_interface_utils/include/autoware/component_interface_utils/rclcpp/create_interface.hpp:18,
                   from /workspace/repos/autoware/install/autoware_component_interface_utils/include/autoware/component_interface_utils/rclcpp.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/adapi_pause_interface.hpp:19,
                   from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:15:
  /opt/ros/humble/include/rclcpp/rclcpp/node.hpp:267:3: note: candidate: ‘template<class ServiceT, class CallbackT> typename rclcpp::Service<ServiceT>::SharedPtr rclcpp::Node::create_service(const string&, CallbackT&&, const rmw_qos_profile_t&, rclcpp::CallbackGroup::SharedPtr)’
    267 |   create_service(
        |   ^~~~~~~~~~~~~~
  /opt/ros/humble/include/rclcpp/rclcpp/node.hpp:267:3: note:   template argument deduction/substitution failed:
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:81:59: error: template argument 1 is invalid
     81 |   engage_service_ = create_service<std_srvs::srv::SetBool>(
        |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
     82 |     "service/engage", std::bind(&VehicleCmdGate::onEngageService, this, std::placeholders::_1, std::placeholders::_2));
        |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:85:3: error: ‘emergency_timer_’ was not declared in this scope; did you mean ‘emergency_commands_’?
     85 |   emergency_timer_ = create_wall_timer(
        |   ^~~~~~~~~~~~~~~~
        |   emergency_commands_
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:87:32: error: ‘onEmergencyTimer’ is not a member of ‘autoware::vehicle_cmd_gate::VehicleCmdGate’
     87 |     std::bind(&VehicleCmdGate::onEmergencyTimer, this));
        |                                ^~~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:91:52: error: ‘checkGateModeDiagnostics’ is not a member of ‘autoware::vehicle_cmd_gate::VehicleCmdGate’
     91 |   updater_.add("Gate Mode", this, &VehicleCmdGate::checkGateModeDiagnostics);
        |                                                    ^~~~~~~~~~~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp: In member function ‘void autoware::vehicle_cmd_gate::VehicleCmdGate::onTimer()’:
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:390:3: error: ‘tier4_debug_msgs’ has not been declared
    390 |   tier4_debug_msgs::msg::Float64Stamped processing_time_msg;
        |   ^~~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp:391:3: error: ‘processing_time_msg’ was not declared in this scope; did you mean ‘processing_time_pub_’?
    391 |   processing_time_msg.stamp = get_clock()->now();
        |   ^~~~~~~~~~~~~~~~~~~
        |   processing_time_pub_
  cc1plus: all warnings being treated as errors
  gmake[2]: *** [CMakeFiles/vehicle_cmd_gate_node.dir/build.make:76: CMakeFiles/vehicle_cmd_gate_node.dir/src/vehicle_cmd_gate.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:206: CMakeFiles/vehicle_cmd_gate_node.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_vehicle_cmd_gate [11.5s, exited with code 2]

  Summary: 0 packages finished [12.9s]
    1 package failed: autoware_vehicle_cmd_gate
    1 package had stderr output: autoware_vehicle_cmd_gate
generate_code.cpp: |-
  VehicleCmdGate::VehicleCmdGate(const rclcpp::NodeOptions & node_options)
  : Node("vehicle_cmd_gate", node_options), is_engaged_(false), updater_(this), current_gate_mode_(GateMode::AUTO)
  {
    // Declare and initialize parameters
    declare_parameter<bool>("use_emergency_handling", true);
    declare_parameter<double>("emergency_stop_timeout", 1.0);
    declare_parameter<std::string>("default_gate_mode", "AUTO");

    // Initialize gate mode
    std::string default_gate_mode = get_parameter("default_gate_mode").as_string();
    if (default_gate_mode == "AUTO") {
      current_gate_mode_ = GateMode::AUTO;
    } else if (default_gate_mode == "MANUAL") {
      current_gate_mode_ = GateMode::MANUAL;
    } else {
      RCLCPP_WARN(get_logger(), "Invalid default_gate_mode parameter. Falling back to AUTO.");
      current_gate_mode_ = GateMode::AUTO;
    }

    // Publishers
    vehicle_cmd_publisher_ = create_publisher<tier4_control_msgs::msg::VehicleCommand>("output/vehicle_cmd", 10);
    gate_mode_publisher_ = create_publisher<tier4_control_msgs::msg::GateMode>("output/gate_mode", 10);

    // Subscribers
    auto_control_cmd_subscriber_ = create_subscription<tier4_control_msgs::msg::VehicleCommand>(
      "input/auto_control_cmd", 10, std::bind(&VehicleCmdGate::onAutoControlCmd, this, std::placeholders::_1));
    manual_control_cmd_subscriber_ = create_subscription<tier4_control_msgs::msg::VehicleCommand>(
      "input/manual_control_cmd", 10, std::bind(&VehicleCmdGate::onManualControlCmd, this, std::placeholders::_1));
    gate_mode_subscriber_ = create_subscription<tier4_control_msgs::msg::GateMode>(
      "input/gate_mode", 10, std::bind(&VehicleCmdGate::onGateMode, this, std::placeholders::_1));

    // Services
    engage_service_ = create_service<std_srvs::srv::SetBool>(
      "service/engage", std::bind(&VehicleCmdGate::onEngageService, this, std::placeholders::_1, std::placeholders::_2));

    // Timers
    emergency_timer_ = create_wall_timer(
      std::chrono::milliseconds(static_cast<int>(get_parameter("emergency_stop_timeout").as_double() * 1000)),
      std::bind(&VehicleCmdGate::onEmergencyTimer, this));

    // Diagnostics
    updater_.setHardwareID("vehicle_cmd_gate");
    updater_.add("Gate Mode", this, &VehicleCmdGate::checkGateModeDiagnostics);

    RCLCPP_INFO(get_logger(), "VehicleCmdGate node initialized.");
  }
ground_truth.cpp: |-
  VehicleCmdGate::VehicleCmdGate(const rclcpp::NodeOptions & node_options)
  : Node("vehicle_cmd_gate", node_options), is_engaged_(false), updater_(this)
  {
    using std::placeholders::_1;
    using std::placeholders::_2;
    using std::placeholders::_3;

    prev_turn_indicator_ = nullptr;
    prev_hazard_light_ = nullptr;
    prev_gear_ = nullptr;

    rclcpp::QoS durable_qos{1};
    durable_qos.transient_local();

    // Stop Checker
    vehicle_stop_checker_ = std::make_unique<VehicleStopChecker>(this);

    // Publisher
    vehicle_cmd_emergency_pub_ =
      create_publisher<VehicleEmergencyStamped>("output/vehicle_cmd_emergency", durable_qos);
    control_cmd_pub_ = create_publisher<Control>("output/control_cmd", durable_qos);
    gear_cmd_pub_ = create_publisher<GearCommand>("output/gear_cmd", durable_qos);
    turn_indicator_cmd_pub_ =
      create_publisher<TurnIndicatorsCommand>("output/turn_indicators_cmd", durable_qos);
    hazard_light_cmd_pub_ =
      create_publisher<HazardLightsCommand>("output/hazard_lights_cmd", durable_qos);

    gate_mode_pub_ = create_publisher<GateMode>("output/gate_mode", durable_qos);
    engage_pub_ = create_publisher<EngageMsg>("output/engage", durable_qos);
    pub_external_emergency_ = create_publisher<Emergency>("output/external_emergency", durable_qos);
    operation_mode_pub_ = create_publisher<OperationModeState>("output/operation_mode", durable_qos);
    processing_time_pub_ =
      this->create_publisher<tier4_debug_msgs::msg::Float64Stamped>("~/debug/processing_time_ms", 1);

    is_filter_activated_pub_ =
      create_publisher<IsFilterActivated>("~/is_filter_activated", durable_qos);
    filter_activated_marker_pub_ =
      create_publisher<MarkerArray>("~/is_filter_activated/marker", durable_qos);
    filter_activated_marker_raw_pub_ =
      create_publisher<MarkerArray>("~/is_filter_activated/marker_raw", durable_qos);
    filter_activated_flag_pub_ =
      create_publisher<BoolStamped>("~/is_filter_activated/flag", durable_qos);

    // Subscriber
    external_emergency_stop_heartbeat_sub_ = create_subscription<Heartbeat>(
      "input/external_emergency_stop_heartbeat", 1,
      std::bind(&VehicleCmdGate::onExternalEmergencyStopHeartbeat, this, _1));
    gate_mode_sub_ = create_subscription<GateMode>(
      "input/gate_mode", 1, std::bind(&VehicleCmdGate::onGateMode, this, _1));
    engage_sub_ = create_subscription<EngageMsg>(
      "input/engage", 1, std::bind(&VehicleCmdGate::onEngage, this, _1));
    kinematics_sub_ = create_subscription<Odometry>(
      "/localization/kinematic_state", 1,
      [this](Odometry::SharedPtr msg) { current_kinematics_ = *msg; });
    acc_sub_ = create_subscription<AccelWithCovarianceStamped>(
      "input/acceleration", 1, [this](AccelWithCovarianceStamped::SharedPtr msg) {
        current_acceleration_ = msg->accel.accel.linear.x;
      });
    steer_sub_ = create_subscription<SteeringReport>(
      "input/steering", 1,
      [this](SteeringReport::SharedPtr msg) { current_steer_ = msg->steering_tire_angle; });
    operation_mode_sub_ = create_subscription<OperationModeState>(
      "input/operation_mode", rclcpp::QoS(1).transient_local(),
      [this](const OperationModeState::SharedPtr msg) { current_operation_mode_ = *msg; });
    mrm_state_sub_ = create_subscription<MrmState>(
      "input/mrm_state", 1, std::bind(&VehicleCmdGate::onMrmState, this, _1));

    // Subscriber for auto
    auto_control_cmd_sub_ = create_subscription<Control>(
      "input/auto/control_cmd", 1, std::bind(&VehicleCmdGate::onAutoCtrlCmd, this, _1));

    // Subscriber for external
    remote_control_cmd_sub_ = create_subscription<Control>(
      "input/external/control_cmd", 1, std::bind(&VehicleCmdGate::onRemoteCtrlCmd, this, _1));

    // Subscriber for emergency
    emergency_control_cmd_sub_ = create_subscription<Control>(
      "input/emergency/control_cmd", 1, std::bind(&VehicleCmdGate::onEmergencyCtrlCmd, this, _1));

    // Parameter
    use_emergency_handling_ = declare_parameter<bool>("use_emergency_handling");
    check_external_emergency_heartbeat_ =
      declare_parameter<bool>("check_external_emergency_heartbeat");
    system_emergency_heartbeat_timeout_ =
      declare_parameter<double>("system_emergency_heartbeat_timeout");
    external_emergency_stop_heartbeat_timeout_ =
      declare_parameter<double>("external_emergency_stop_heartbeat_timeout");
    stop_hold_acceleration_ = declare_parameter<double>("stop_hold_acceleration");
    emergency_acceleration_ = declare_parameter<double>("emergency_acceleration");
    moderate_stop_service_acceleration_ =
      declare_parameter<double>("moderate_stop_service_acceleration");
    stop_check_duration_ = declare_parameter<double>("stop_check_duration");
    enable_cmd_limit_filter_ = declare_parameter<bool>("enable_cmd_limit_filter");
    filter_activated_count_threshold_ = declare_parameter<int>("filter_activated_count_threshold");
    filter_activated_velocity_threshold_ =
      declare_parameter<double>("filter_activated_velocity_threshold");

    // Vehicle Parameter
    const auto vehicle_info = autoware::vehicle_info_utils::VehicleInfoUtils(*this).getVehicleInfo();
    {
      VehicleCmdFilterParam p;
      p.wheel_base = vehicle_info.wheel_base_m;
      p.vel_lim = declare_parameter<double>("nominal.vel_lim");
      p.reference_speed_points =
        declare_parameter<std::vector<double>>("nominal.reference_speed_points");
      p.steer_lim = declare_parameter<std::vector<double>>("nominal.steer_lim");
      p.steer_rate_lim = declare_parameter<std::vector<double>>("nominal.steer_rate_lim");
      p.lon_acc_lim = declare_parameter<std::vector<double>>("nominal.lon_acc_lim");
      p.lon_jerk_lim = declare_parameter<std::vector<double>>("nominal.lon_jerk_lim");
      p.lat_acc_lim = declare_parameter<std::vector<double>>("nominal.lat_acc_lim");
      p.lat_jerk_lim = declare_parameter<std::vector<double>>("nominal.lat_jerk_lim");
      p.actual_steer_diff_lim =
        declare_parameter<std::vector<double>>("nominal.actual_steer_diff_lim");
      filter_.setParam(p);
    }

    {
      VehicleCmdFilterParam p;
      p.wheel_base = vehicle_info.wheel_base_m;
      p.vel_lim = declare_parameter<double>("on_transition.vel_lim");
      p.reference_speed_points =
        declare_parameter<std::vector<double>>("on_transition.reference_speed_points");
      p.steer_lim = declare_parameter<std::vector<double>>("on_transition.steer_lim");
      p.steer_rate_lim = declare_parameter<std::vector<double>>("on_transition.steer_rate_lim");
      p.lon_acc_lim = declare_parameter<std::vector<double>>("on_transition.lon_acc_lim");
      p.lon_jerk_lim = declare_parameter<std::vector<double>>("on_transition.lon_jerk_lim");
      p.lat_acc_lim = declare_parameter<std::vector<double>>("on_transition.lat_acc_lim");
      p.lat_jerk_lim = declare_parameter<std::vector<double>>("on_transition.lat_jerk_lim");
      p.actual_steer_diff_lim =
        declare_parameter<std::vector<double>>("on_transition.actual_steer_diff_lim");
      filter_on_transition_.setParam(p);
    }

    // Set default value
    current_gate_mode_.data = GateMode::AUTO;
    current_operation_mode_.mode = OperationModeState::STOP;

    // Service
    srv_engage_ = create_service<EngageSrv>(
      "~/service/engage", std::bind(&VehicleCmdGate::onEngageService, this, _1, _2));
    srv_external_emergency_ = create_service<SetEmergency>(
      "~/service/external_emergency",
      std::bind(&VehicleCmdGate::onExternalEmergencyStopService, this, _1, _2, _3));
    srv_external_emergency_stop_ = create_service<Trigger>(
      "~/service/external_emergency_stop",
      std::bind(&VehicleCmdGate::onSetExternalEmergencyStopService, this, _1, _2, _3));
    srv_clear_external_emergency_stop_ = create_service<Trigger>(
      "~/service/clear_external_emergency_stop",
      std::bind(&VehicleCmdGate::onClearExternalEmergencyStopService, this, _1, _2, _3));

    // Diagnostics Updater
    updater_.setHardwareID("vehicle_cmd_gate");
    updater_.add("heartbeat", [](auto & stat) {
      stat.summary(diagnostic_msgs::msg::DiagnosticStatus::OK, "Alive");
    });
    updater_.add("emergency_stop_operation", this, &VehicleCmdGate::checkExternalEmergencyStop);

    // Pause interface
    adapi_pause_ = std::make_unique<AdapiPauseInterface>(this);
    moderate_stop_interface_ = std::make_unique<ModerateStopInterface>(this);

    // Timer
    const auto update_period = 1.0 / declare_parameter<double>("update_rate");
    const auto period_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
      std::chrono::duration<double>(update_period));
    timer_ =
      rclcpp::create_timer(this, get_clock(), period_ns, std::bind(&VehicleCmdGate::onTimer, this));
    timer_pub_status_ = rclcpp::create_timer(
      this, get_clock(), period_ns, std::bind(&VehicleCmdGate::publishStatus, this));

    logger_configure_ = std::make_unique<autoware::universe_utils::LoggerLevelConfigure>(this);

    published_time_publisher_ =
      std::make_unique<autoware::universe_utils::PublishedTimePublisher>(this);

    // Parameter Callback
    set_param_res_ =
      this->add_on_set_parameters_callback(std::bind(&VehicleCmdGate::onParameter, this, _1));
  }
