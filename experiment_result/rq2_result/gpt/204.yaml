compilation.log: |
  Starting >>> nav2_costmap_2d
  Finished <<< nav2_costmap_2d [0.71s]

  Summary: 1 package finished [1.00s]
generate_code.cpp: |-
  void transformFootprint(
    double x, double y, double theta,
    const std::vector<geometry_msgs::msg::Point> & footprint_spec,
    geometry_msgs::msg::PolygonStamped & oriented_footprint)
  {
    // Clear the oriented footprint points
    oriented_footprint.polygon.points.clear();

    // Iterate through each point in the footprint specification
    for (const auto &point : footprint_spec) {
      // Create a new point for the transformed footprint
      geometry_msgs::msg::Point32 new_point;

      // Apply rotation and translation to transform the point
      new_point.x = x + (point.x * cos(theta) - point.y * sin(theta));
      new_point.y = y + (point.x * sin(theta) + point.y * cos(theta));
      new_point.z = point.z; // Assuming z remains unchanged

      // Add the transformed point to the oriented footprint
      oriented_footprint.polygon.points.push_back(new_point);
    }

    // Set the header for the oriented footprint
    oriented_footprint.header.stamp = rclcpp::Clock().now();
    oriented_footprint.header.frame_id = "base_link"; // Adjust frame_id as needed
  }
ground_truth.cpp: |-
  void transformFootprint(
    double x, double y, double theta,
    const std::vector<geometry_msgs::msg::Point> & footprint_spec,
    geometry_msgs::msg::PolygonStamped & oriented_footprint)
  {
    // build the oriented footprint at a given location
    oriented_footprint.polygon.points.clear();
    double cos_th = cos(theta);
    double sin_th = sin(theta);
    for (unsigned int i = 0; i < footprint_spec.size(); ++i) {
      geometry_msgs::msg::Point32 new_pt;
      new_pt.x = x + (footprint_spec[i].x * cos_th - footprint_spec[i].y * sin_th);
      new_pt.y = y + (footprint_spec[i].x * sin_th + footprint_spec[i].y * cos_th);
      oriented_footprint.polygon.points.push_back(new_pt);
    }
  }
