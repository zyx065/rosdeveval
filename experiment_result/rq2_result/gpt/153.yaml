compilation.log: |
  Starting >>> moveit_servo
  --- stderr: moveit_servo
  /root/repos/moveit_ws/src/moveit2/moveit_ros/moveit_servo/src/enforce_limits.cpp: In function ‘void moveit_servo::enforceVelocityLimits(const moveit::core::JointModelGroup*, double, sensor_msgs::msg::JointState&, double)’:
  /root/repos/moveit_ws/src/moveit2/moveit_ros/moveit_servo/src/enforce_limits.cpp:105:38: error: ‘const struct moveit::core::VariableBounds’ has no member named ‘max_velocity’; did you mean ‘max_velocity_’?
    105 |         double max_velocity = bounds.max_velocity;
        |                                      ^~~~~~~~~~~~
        |                                      max_velocity_
  gmake[2]: *** [CMakeFiles/moveit_servo_lib.dir/build.make:90: CMakeFiles/moveit_servo_lib.dir/src/enforce_limits.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:203: CMakeFiles/moveit_servo_lib.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< moveit_servo [3.11s, exited with code 2]

  Summary: 0 packages finished [3.58s]
    1 package failed: moveit_servo
    1 package had stderr output: moveit_servo
generate_code.cpp: |-
  void enforceVelocityLimits(const moveit::core::JointModelGroup* joint_model_group, const double publish_period,
                             sensor_msgs::msg::JointState& joint_state, const double override_velocity_scaling_factor)
  {
      // Ensure joint_model_group and joint_state have valid data
      if (!joint_model_group || joint_state.velocity.empty() || joint_state.position.empty())
      {
          RCLCPP_ERROR(rclcpp::get_logger("enforceVelocityLimits"), "Invalid joint_model_group or joint_state.");
          return;
      }

      // Retrieve velocity limits for the joints in the group
      const std::vector<const moveit::core::JointModel*>& joint_models = joint_model_group->getActiveJointModels();
      if (joint_models.size() != joint_state.velocity.size())
      {
          RCLCPP_ERROR(rclcpp::get_logger("enforceVelocityLimits"), "Mismatch between joint models and joint state velocities.");
          return;
      }

      // Determine scaling factor
      double scaling_factor = override_velocity_scaling_factor > 0.0 ? override_velocity_scaling_factor : 1.0;
      if (override_velocity_scaling_factor <= 0.0)
      {
          Eigen::VectorXd velocity(joint_state.velocity.size());
          for (size_t i = 0; i < joint_state.velocity.size(); ++i)
              velocity[i] = joint_state.velocity[i];

          scaling_factor = getVelocityScalingFactor(joint_model_group, velocity);
      }

      // Apply scaling factor and enforce velocity limits
      for (size_t i = 0; i < joint_models.size(); ++i)
      {
          const moveit::core::VariableBounds& bounds = joint_models[i]->getVariableBounds(joint_models[i]->getName());
          double max_velocity = bounds.max_velocity;

          // Scale velocity and enforce limits
          joint_state.velocity[i] *= scaling_factor;
          if (std::abs(joint_state.velocity[i]) > max_velocity)
          {
              joint_state.velocity[i] = std::copysign(max_velocity, joint_state.velocity[i]);
          }

          // Update position based on scaled velocity and publish period
          joint_state.position[i] += joint_state.velocity[i] * publish_period;
      }
  }
ground_truth.cpp: |-
  void enforceVelocityLimits(const moveit::core::JointModelGroup* joint_model_group, const double publish_period,
                             sensor_msgs::msg::JointState& joint_state, const double override_velocity_scaling_factor)
  {
    // Get the velocity scaling factor
    Eigen::VectorXd velocity =
        Eigen::Map<Eigen::VectorXd, Eigen::Unaligned>(joint_state.velocity.data(), joint_state.velocity.size());
    double velocity_scaling_factor = override_velocity_scaling_factor;
    // if the override velocity scaling factor is approximately zero then the user is not overriding the value.
    if (override_velocity_scaling_factor < 0.01)
      velocity_scaling_factor = getVelocityScalingFactor(joint_model_group, velocity);

    // Take a smaller step if the velocity scaling factor is less than 1
    if (velocity_scaling_factor < 1)
    {
      Eigen::VectorXd velocity_residuals = (1 - velocity_scaling_factor) * velocity;
      Eigen::VectorXd positions =
          Eigen::Map<Eigen::VectorXd, Eigen::Unaligned>(joint_state.position.data(), joint_state.position.size());
      positions -= velocity_residuals * publish_period;

      velocity *= velocity_scaling_factor;
      // Back to sensor_msgs type
      joint_state.velocity = std::vector<double>(velocity.data(), velocity.data() + velocity.size());
      joint_state.position = std::vector<double>(positions.data(), positions.data() + positions.size());
    }
  }
