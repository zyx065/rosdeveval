compilation.log: |
  Starting >>> moveit_servo
  Finished <<< moveit_servo [0.65s]

  Summary: 1 package finished [1.28s]
generate_code.cpp: |-
  void PoseTracking::targetPoseCallback(const geometry_msgs::msg::PoseStamped::ConstSharedPtr& msg)
  {
      // Lock the mutex to ensure thread safety
      std::lock_guard<std::mutex> lock(target_pose_mtx_);

      try
      {
          // Transform the incoming pose to the planning frame
          geometry_msgs::msg::PoseStamped transformed_pose = transform_buffer_.transform(*msg, planning_frame_);

          // Log the transformed pose for debugging purposes
          RCLCPP_DEBUG(LOGGER, "Transformed target pose: [position: (%.3f, %.3f, %.3f), orientation: (%.3f, %.3f, %.3f, %.3f)]",
                       transformed_pose.pose.position.x, transformed_pose.pose.position.y, transformed_pose.pose.position.z,
                       transformed_pose.pose.orientation.x, transformed_pose.pose.orientation.y, transformed_pose.pose.orientation.z,
                       transformed_pose.pose.orientation.w);

          // Update the internal state with the transformed pose
          target_pose_ = transformed_pose;
      }
      catch (const tf2::TransformException& ex)
      {
          // Log the error if the transformation fails
          RCLCPP_WARN(LOGGER, "Failed to transform target pose to planning frame '%s': %s", planning_frame_.c_str(), ex.what());
      }
  }
ground_truth.cpp: |-
  void PoseTracking::targetPoseCallback(const geometry_msgs::msg::PoseStamped::ConstSharedPtr& msg)
  {
    std::lock_guard<std::mutex> lock(target_pose_mtx_);
    target_pose_ = *msg;
    // If the target pose is not defined in planning frame, transform the target pose.
    if (target_pose_.header.frame_id != planning_frame_)
    {
      try
      {
        geometry_msgs::msg::TransformStamped target_to_planning_frame = transform_buffer_.lookupTransform(
            planning_frame_, target_pose_.header.frame_id, rclcpp::Time(0), rclcpp::Duration(100ms));
        tf2::doTransform(target_pose_, target_pose_, target_to_planning_frame);

        // Prevent doTransform from copying a stamp of 0, which will cause the haveRecentTargetPose check to fail servo motions
        target_pose_.header.stamp = node_->now();
      }
      catch (const tf2::TransformException& ex)
      {
        RCLCPP_WARN_STREAM(LOGGER, ex.what());
        return;
      }
    }
  }
