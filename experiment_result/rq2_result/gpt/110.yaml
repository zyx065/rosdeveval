compilation.log: |
  Starting >>> autoware_surround_obstacle_checker
  --- stderr: autoware_surround_obstacle_checker
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_surround_obstacle_checker/src/node.cpp: In member function ‘std::pair<bool, std::optional<rclcpp::Time> > autoware::surround_obstacle_checker::SurroundObstacleCheckerNode::isStopRequired(bool, bool, const autoware::surround_obstacle_checker::State&, const std::optional<rclcpp::Time>&, double) const’:
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_surround_obstacle_checker/src/node.cpp:381:78: error: unused parameter ‘state’ [-Werror=unused-parameter]
    381 |   const bool is_obstacle_found, const bool is_vehicle_stopped, const State & state,
        |                                                                ~~~~~~~~~~~~~~^~~~~
  In file included from /workspace/repos/autoware/build/autoware_surround_obstacle_checker/surround_obstacle_checker_node_parameters/include/surround_obstacle_checker_node_parameters.hpp:23,
                   from /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_surround_obstacle_checker/src/node.hpp:21,
                   from /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_surround_obstacle_checker/src/node.cpp:15:
  /opt/ros/humble/include/parameter_traits/parameter_traits/parameter_traits.hpp: In function ‘void __static_initialization_and_destruction_0(int, int)’:
  /opt/ros/humble/include/parameter_traits/parameter_traits/parameter_traits.hpp:51:13: warning: ‘parameter_traits::OK’ is deprecated: When returning tl::expected<void, std::string> default construct for OK with `{}`. [-Wdeprecated-declarations]
     51 | auto static OK
        |             ^~
  /opt/ros/humble/include/parameter_traits/parameter_traits/parameter_traits.hpp:51:13: note: declared here
  cc1plus: all warnings being treated as errors
  gmake[2]: *** [CMakeFiles/autoware_surround_obstacle_checker.dir/build.make:90: CMakeFiles/autoware_surround_obstacle_checker.dir/src/node.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:187: CMakeFiles/autoware_surround_obstacle_checker.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_surround_obstacle_checker [22.5s, exited with code 2]

  Summary: 0 packages finished [23.8s]
    1 package failed: autoware_surround_obstacle_checker
    1 package had stderr output: autoware_surround_obstacle_checker
generate_code.cpp: |-
  auto SurroundObstacleCheckerNode::isStopRequired(
    const bool is_obstacle_found, const bool is_vehicle_stopped, const State & state,
    const std::optional<rclcpp::Time> & last_obstacle_found_time, const double time_threshold) const
    -> std::pair<bool, std::optional<rclcpp::Time>>
  {
    // If an obstacle is found, stop is required
    if (is_obstacle_found) {
      // If this is the first time an obstacle is detected, record the current time
      rclcpp::Time current_time = this->now();
      return {true, last_obstacle_found_time.value_or(current_time)};
    }

    // If no obstacle is found and the vehicle is stopped, check the time threshold
    if (is_vehicle_stopped && last_obstacle_found_time.has_value()) {
      rclcpp::Time current_time = this->now();
      rclcpp::Duration time_since_last_obstacle = current_time - last_obstacle_found_time.value();

      // If the time since the last obstacle is within the threshold, continue to require stop
      if (time_since_last_obstacle.seconds() < time_threshold) {
        return {true, last_obstacle_found_time};
      }
    }

    // Otherwise, stop is not required
    return {false, std::nullopt};
  }
ground_truth.cpp: |-
  auto SurroundObstacleCheckerNode::isStopRequired(
    const bool is_obstacle_found, const bool is_vehicle_stopped, const State & state,
    const std::optional<rclcpp::Time> & last_obstacle_found_time, const double time_threshold) const
    -> std::pair<bool, std::optional<rclcpp::Time>>
  {
    if (!is_vehicle_stopped) {
      return std::make_pair(false, std::nullopt);
    }

    if (is_obstacle_found) {
      return std::make_pair(true, this->now());
    }

    if (state != State::STOP) {
      return std::make_pair(false, std::nullopt);
    }

    // Keep stop state
    if (last_obstacle_found_time.has_value()) {
      const auto elapsed_time = this->now() - last_obstacle_found_time.value();
      if (elapsed_time.seconds() <= time_threshold) {
        return std::make_pair(true, last_obstacle_found_time.value());
      }
    }

    return std::make_pair(false, std::nullopt);
  }
