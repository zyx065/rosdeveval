compilation.log: |
  Starting >>> nav2_voxel_grid
  Finished <<< nav2_voxel_grid [0.21s]

  Summary: 1 package finished [0.51s]
generate_code.cpp: |-
  inline bool markVoxelInMap(
      unsigned int x, unsigned int y, unsigned int z,
      unsigned int marked_threshold)
  {
      // Check if the voxel coordinates are within bounds
      if (x >= size_x_ || y >= size_y_ || z >= size_z_) {
          RCLCPP_WARN(logger, "Voxel coordinates out of bounds: (%u, %u, %u)", x, y, z);
          return false;
      }

      // Calculate the index in the data array
      unsigned int index = x + size_x_ * (y + size_y_ * z);

      // Mark the voxel in the data array
      data_[index]++;

      // Check if the marked bits exceed the threshold
      if (bitsBelowThreshold(data_[index], marked_threshold)) {
          RCLCPP_DEBUG(logger, "Voxel (%u, %u, %u) marked but below threshold: %u", x, y, z, data_[index]);
          return false;
      }

      // If the voxel is marked and meets the threshold, return true
      RCLCPP_DEBUG(logger, "Voxel (%u, %u, %u) marked and meets threshold: %u", x, y, z, data_[index]);
      return true;
  }
ground_truth.cpp: |-
  inline bool markVoxelInMap(
      unsigned int x, unsigned int y, unsigned int z,
      unsigned int marked_threshold)
    {
      if (x >= size_x_ || y >= size_y_ || z >= size_z_) {
        RCLCPP_DEBUG(logger, "Error, voxel out of bounds.\n");
        return false;
      }

      int index = y * size_x_ + x;
      uint32_t * col = &data_[index];
      uint32_t full_mask = ((uint32_t)1 << z << 16) | (1 << z);
      *col |= full_mask;  // clear unknown and mark cell

      unsigned int marked_bits = *col >> 16;

      // make sure the number of bits in each is below our thresholds
      return !bitsBelowThreshold(marked_bits, marked_threshold);
    }
