compilation.log: |
  Starting >>> autoware_radar_crossing_objects_noise_filter
  --- stderr: autoware_radar_crossing_objects_noise_filter
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_radar_crossing_objects_noise_filter/src/radar_crossing_objects_noise_filter_node.cpp: In member function ‘bool autoware::radar_crossing_objects_noise_filter::RadarCrossingObjectsNoiseFilterNode::isNoise(const DetectedObject&)’:
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_radar_crossing_objects_noise_filter/src/radar_crossing_objects_noise_filter_node.cpp:133:70: error: ‘const DetectedObject’ {aka ‘const struct autoware_perception_msgs::msg::DetectedObject_<std::allocator<void> >’} has no member named ‘velocity’
    133 |     double velocity_norm = autoware::universe_utils::calcNorm(object.velocity);
        |                                                                      ^~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_radar_crossing_objects_noise_filter/src/radar_crossing_objects_noise_filter_node.cpp:141:16: error: ‘const DetectedObject’ {aka ‘const struct autoware_perception_msgs::msg::DetectedObject_<std::allocator<void> >’} has no member named ‘distance’
    141 |     if (object.distance > max_distance_threshold) {
        |                ^~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_radar_crossing_objects_noise_filter/src/radar_crossing_objects_noise_filter_node.cpp:146:16: error: ‘const DetectedObject’ {aka ‘const struct autoware_perception_msgs::msg::DetectedObject_<std::allocator<void> >’} has no member named ‘size’
    146 |     if (object.size < min_size_threshold) {
        |                ^~~~
  gmake[2]: *** [CMakeFiles/autoware_radar_crossing_objects_noise_filter_node_component.dir/build.make:76: CMakeFiles/autoware_radar_crossing_objects_noise_filter_node_component.dir/src/radar_crossing_objects_noise_filter_node.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:159: CMakeFiles/autoware_radar_crossing_objects_noise_filter_node_component.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_radar_crossing_objects_noise_filter [5.17s, exited with code 2]

  Summary: 0 packages finished [6.58s]
    1 package failed: autoware_radar_crossing_objects_noise_filter
    1 package had stderr output: autoware_radar_crossing_objects_noise_filter
generate_code.cpp: |-
  bool RadarCrossingObjectsNoiseFilterNode::isNoise(const DetectedObject & object)
  {
      // Thresholds for noise classification
      const double min_velocity_threshold = 0.5;  // Minimum velocity to not be considered noise
      const double max_distance_threshold = 100.0; // Maximum distance to not be considered noise
      const double min_size_threshold = 0.1;      // Minimum size to not be considered noise

      // Calculate the norm of the velocity vector
      double velocity_norm = autoware::universe_utils::calcNorm(object.velocity);

      // Check if the object is below the velocity threshold
      if (velocity_norm < min_velocity_threshold) {
          return true; // Object is considered noise due to low velocity
      }

      // Check if the object is beyond the maximum distance threshold
      if (object.distance > max_distance_threshold) {
          return true; // Object is considered noise due to being too far
      }

      // Check if the object size is below the minimum size threshold
      if (object.size < min_size_threshold) {
          return true; // Object is considered noise due to small size
      }

      // If none of the conditions are met, the object is not noise
      return false;
  }
ground_truth.cpp: |-
  bool RadarCrossingObjectsNoiseFilterNode::isNoise(const DetectedObject & object)
  {
    const double velocity = std::abs(
      autoware::universe_utils::calcNorm(object.kinematics.twist_with_covariance.twist.linear));
    const double object_angle = tf2::getYaw(object.kinematics.pose_with_covariance.pose.orientation);
    const double object_position_angle = std::atan2(
      object.kinematics.pose_with_covariance.pose.position.y,
      object.kinematics.pose_with_covariance.pose.position.x);
    const double crossing_yaw =
      autoware::universe_utils::normalizeRadian(object_angle - object_position_angle);

    if (
      velocity > node_param_.velocity_threshold &&
      abs(std::cos(crossing_yaw)) < abs(std::cos(node_param_.angle_threshold))) {
      return true;
    } else {
      return false;
    }
  }
