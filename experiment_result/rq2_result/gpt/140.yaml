compilation.log: |
  Starting >>> pilz_industrial_motion_planner
  Finished <<< pilz_industrial_motion_planner [0.82s]

  Summary: 1 package finished [1.27s]
generate_code.cpp: |-
  bool pilz_industrial_motion_planner::isStateColliding(const planning_scene::PlanningSceneConstPtr& scene,
                                                        moveit::core::RobotState* rstate,
                                                        const moveit::core::JointModelGroup* const group,
                                                        const double* const ik_solution)
  {
    // Set the joint group positions in the robot state using the provided IK solution
    rstate->setJointGroupPositions(group, ik_solution);

    // Update the robot state to ensure all transformations and variables are consistent
    rstate->update();

    // Create a collision request object to specify the collision checking parameters
    collision_detection::CollisionRequest collision_request;
    collision_request.contacts = false;  // We only need a binary collision check (true/false)
    collision_request.verbose = false;   // No verbose output required

    // Create a collision result object to store the result of the collision check
    collision_detection::CollisionResult collision_result;

    // Perform the collision check using the planning scene
    scene->checkSelfCollision(collision_request, collision_result, *rstate);

    // Return whether the robot state is in collision
    return collision_result.collision;
  }
ground_truth.cpp: |-
  bool pilz_industrial_motion_planner::isStateColliding(const planning_scene::PlanningSceneConstPtr& scene,
                                                        moveit::core::RobotState* rstate,
                                                        const moveit::core::JointModelGroup* const group,
                                                        const double* const ik_solution)
  {
    rstate->setJointGroupPositions(group, ik_solution);
    rstate->update();
    collision_detection::CollisionRequest collision_req;
    collision_req.group_name = group->getName();
    collision_req.verbose = true;
    collision_detection::CollisionResult collision_res;
    scene->checkSelfCollision(collision_req, collision_res, *rstate);
    return !collision_res.collision;
  }
