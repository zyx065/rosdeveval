compilation.log: |
  Starting >>> autoware_motion_velocity_obstacle_velocity_limiter_module
  --- stderr: autoware_motion_velocity_obstacle_velocity_limiter_module
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_obstacle_velocity_limiter_module/src/distance.cpp: In function ‘std::optional<double> autoware::motion_velocity_planner::obstacle_velocity_limiter::distanceToClosestCollision(const linestring_t&, const polygon_t&, const autoware::motion_velocity_planner::obstacle_velocity_limiter::CollisionChecker&, const autoware::motion_velocity_planner::obstacle_velocity_limiter::ProjectionParameters&)’:
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_obstacle_velocity_limiter_module/src/distance.cpp:39:27: error: ‘const struct autoware::motion_velocity_planner::obstacle_velocity_limiter::CollisionChecker’ has no member named ‘checkCollision’
     39 |     if (collision_checker.checkCollision(point, footprint, params)) {
        |                           ^~~~~~~~~~~~~~
  gmake[2]: *** [CMakeFiles/autoware_motion_velocity_obstacle_velocity_limiter_module.dir/build.make:90: CMakeFiles/autoware_motion_velocity_obstacle_velocity_limiter_module.dir/src/distance.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:159: CMakeFiles/autoware_motion_velocity_obstacle_velocity_limiter_module.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_motion_velocity_obstacle_velocity_limiter_module [11.6s, exited with code 2]

  Summary: 0 packages finished [13.0s]
    1 package failed: autoware_motion_velocity_obstacle_velocity_limiter_module
    1 package had stderr output: autoware_motion_velocity_obstacle_velocity_limiter_module
generate_code.cpp: |-
  std::optional<double> distanceToClosestCollision(
    const linestring_t & projection, const polygon_t & footprint,
    const CollisionChecker & collision_checker, const ProjectionParameters & params)
  {
    // Initialize the minimum distance to an invalid state
    std::optional<double> min_distance = std::nullopt;

    // Iterate through each point in the projection line
    for (const auto & point : projection) {
      // Check if the footprint at the current point collides with any obstacles
      if (collision_checker.checkCollision(point, footprint, params)) {
        // Calculate the arc distance from the start of the projection to the collision point
        double distance = arcDistance(projection.front(), params.heading, point);

        // Update the minimum distance if this collision is closer
        if (!min_distance || distance < *min_distance) {
          min_distance = distance;
        }
      }
    }

    // Return the minimum distance to the closest collision, or std::nullopt if no collision was found
    return min_distance;
  }
ground_truth.cpp: |-
  std::optional<double> distanceToClosestCollision(
    const linestring_t & projection, const polygon_t & footprint,
    const CollisionChecker & collision_checker, const ProjectionParameters & params)
  {
    std::optional<double> distance;
    if (projection.empty()) return distance;
    double min_dist = std::numeric_limits<double>::max();
    for (const auto & obs_point : collision_checker.intersections(footprint)) {
      if (params.distance_method == ProjectionParameters::EXACT) {
        if (params.model == ProjectionParameters::PARTICLE) {
          const auto euclidean_dist = bg::distance(obs_point, projection.front());
          const auto collision_heading = std::atan2(
            obs_point.y() - projection.front().y(), obs_point.x() - projection.front().x());
          const auto angle = params.heading - collision_heading;
          const auto long_dist = std::abs(std::cos(angle)) * euclidean_dist;
          min_dist = std::min(min_dist, long_dist);
        } else {  // BICYCLE model with curved projection
          min_dist = std::min(min_dist, arcDistance(projection.front(), params.heading, obs_point));
        }
      } else {  // APPROXIMATION
        const auto euclidean_dist = bg::distance(obs_point, projection.front());
        min_dist = std::min(min_dist, euclidean_dist);
      }
    }
    if (min_dist != std::numeric_limits<double>::max()) distance = min_dist;
    return distance;
  }
