compilation.log: |
  Starting >>> autoware_velocity_smoother
  --- stderr: autoware_velocity_smoother
  In file included from /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_velocity_smoother/include/autoware/velocity_smoother/node.hpp:28,
                   from /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_velocity_smoother/src/node.cpp:15:
  /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/system/time_keeper.hpp: In instantiation of ‘autoware::universe_utils::TimeKeeper::TimeKeeper(Reporters ...) [with Reporters = {std::shared_ptr<rclcpp::Clock>}]’:
  /usr/include/c++/11/ext/new_allocator.h:162:4:   required from ‘void __gnu_cxx::new_allocator<_Tp>::construct(_Up*, _Args&& ...) [with _Up = autoware::universe_utils::TimeKeeper; _Args = {std::shared_ptr<rclcpp::Clock>&}; _Tp = autoware::universe_utils::TimeKeeper]’
  /usr/include/c++/11/bits/alloc_traits.h:516:17:   required from ‘static void std::allocator_traits<std::allocator<_Tp1> >::construct(std::allocator_traits<std::allocator<_Tp1> >::allocator_type&, _Up*, _Args&& ...) [with _Up = autoware::universe_utils::TimeKeeper; _Args = {std::shared_ptr<rclcpp::Clock>&}; _Tp = autoware::universe_utils::TimeKeeper; std::allocator_traits<std::allocator<_Tp1> >::allocator_type = std::allocator<autoware::universe_utils::TimeKeeper>]’
  /usr/include/c++/11/bits/shared_ptr_base.h:519:39:   required from ‘std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_Sp_counted_ptr_inplace(_Alloc, _Args&& ...) [with _Args = {std::shared_ptr<rclcpp::Clock>&}; _Tp = autoware::universe_utils::TimeKeeper; _Alloc = std::allocator<autoware::universe_utils::TimeKeeper>; __gnu_cxx::_Lock_policy _Lp = __gnu_cxx::_S_atomic]’
  /usr/include/c++/11/bits/shared_ptr_base.h:650:16:   required from ‘std::__shared_count<_Lp>::__shared_count(_Tp*&, std::_Sp_alloc_shared_tag<_Alloc>, _Args&& ...) [with _Tp = autoware::universe_utils::TimeKeeper; _Alloc = std::allocator<autoware::universe_utils::TimeKeeper>; _Args = {std::shared_ptr<rclcpp::Clock>&}; __gnu_cxx::_Lock_policy _Lp = __gnu_cxx::_S_atomic]’
  /usr/include/c++/11/bits/shared_ptr_base.h:1342:14:   required from ‘std::__shared_ptr<_Tp, _Lp>::__shared_ptr(std::_Sp_alloc_shared_tag<_Tp>, _Args&& ...) [with _Alloc = std::allocator<autoware::universe_utils::TimeKeeper>; _Args = {std::shared_ptr<rclcpp::Clock>&}; _Tp = autoware::universe_utils::TimeKeeper; __gnu_cxx::_Lock_policy _Lp = __gnu_cxx::_S_atomic]’
  /usr/include/c++/11/bits/shared_ptr.h:409:59:   required from ‘std::shared_ptr<_Tp>::shared_ptr(std::_Sp_alloc_shared_tag<_Tp>, _Args&& ...) [with _Alloc = std::allocator<autoware::universe_utils::TimeKeeper>; _Args = {std::shared_ptr<rclcpp::Clock>&}; _Tp = autoware::universe_utils::TimeKeeper]’
  /usr/include/c++/11/bits/shared_ptr.h:862:14:   required from ‘std::shared_ptr<_Tp> std::allocate_shared(const _Alloc&, _Args&& ...) [with _Tp = autoware::universe_utils::TimeKeeper; _Alloc = std::allocator<autoware::universe_utils::TimeKeeper>; _Args = {std::shared_ptr<rclcpp::Clock>&}]’
  /usr/include/c++/11/bits/shared_ptr.h:878:39:   required from ‘std::shared_ptr<_Tp> std::make_shared(_Args&& ...) [with _Tp = autoware::universe_utils::TimeKeeper; _Args = {std::shared_ptr<rclcpp::Clock>&}]’
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_velocity_smoother/src/node.cpp:77:72:   required from here
  /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/system/time_keeper.hpp:126:18: error: no matching function for call to ‘autoware::universe_utils::TimeKeeper::add_reporter(std::shared_ptr<rclcpp::Clock>&)’
    126 |     (add_reporter(reporters), ...);
        |      ~~~~~~~~~~~~^~~~~~~~~~~
  /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/system/time_keeper.hpp:134:8: note: candidate: ‘void autoware::universe_utils::TimeKeeper::add_reporter(std::ostream*)’
    134 |   void add_reporter(std::ostream * os);
        |        ^~~~~~~~~~~~
  /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/system/time_keeper.hpp:134:36: note:   no known conversion for argument 1 from ‘std::shared_ptr<rclcpp::Clock>’ to ‘std::ostream*’ {aka ‘std::basic_ostream<char>*’}
    134 |   void add_reporter(std::ostream * os);
        |                     ~~~~~~~~~~~~~~~^~
  /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/system/time_keeper.hpp:141:8: note: candidate: ‘void autoware::universe_utils::TimeKeeper::add_reporter(rclcpp::Publisher<tier4_debug_msgs::msg::ProcessingTimeTree_<std::allocator<void> > >::SharedPtr)’
    141 |   void add_reporter(rclcpp::Publisher<ProcessingTimeDetail>::SharedPtr publisher);
        |        ^~~~~~~~~~~~
  /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/system/time_keeper.hpp:141:72: note:   no known conversion for argument 1 from ‘shared_ptr<rclcpp::Clock>’ to ‘shared_ptr<rclcpp::Publisher<tier4_debug_msgs::msg::ProcessingTimeTree_<std::allocator<void> > >>’
    141 |   void add_reporter(rclcpp::Publisher<ProcessingTimeDetail>::SharedPtr publisher);
        |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~
  gmake[2]: *** [CMakeFiles/autoware_velocity_smoother_node.dir/build.make:76: CMakeFiles/autoware_velocity_smoother_node.dir/src/node.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:208: CMakeFiles/autoware_velocity_smoother_node.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_velocity_smoother [9.82s, exited with code 2]

  Summary: 0 packages finished [11.1s]
    1 package failed: autoware_velocity_smoother
    1 package had stderr output: autoware_velocity_smoother
generate_code.cpp: |-
  VelocitySmootherNode::VelocitySmootherNode(const rclcpp::NodeOptions & node_options)
  : Node("velocity_smoother", node_options),
    diagnostics_interface_(std::make_unique<DiagnosticsInterface>(this, "velocity_smoother"))
  {
    // Initialize parameters
    this->declare_parameter("over_stop_velocity_warn_thr", 0.5);
    this->declare_parameter("wheelbase", 2.5);
    this->declare_parameter("base_link2front", 1.0);
    this->declare_parameter("publish_debug_trajs", false);
    this->declare_parameter("max_velocity_with_deceleration", 10.0);

    // Retrieve parameters
    over_stop_velocity_warn_thr_ = this->get_parameter("over_stop_velocity_warn_thr").as_double();
    wheelbase_ = this->get_parameter("wheelbase").as_double();
    base_link2front_ = this->get_parameter("base_link2front").as_double();
    publish_debug_trajs_ = this->get_parameter("publish_debug_trajs").as_bool();
    max_velocity_with_deceleration_ = this->get_parameter("max_velocity_with_deceleration").as_double();

    // Initialize publishers
    pub_dist_to_stopline_ = this->create_publisher<Float32Stamped>("dist_to_stopline", 10);
    pub_trajectory_raw_ = this->create_publisher<Trajectory>("trajectory_raw", 10);
    pub_velocity_limit_ = this->create_publisher<VelocityLimit>("velocity_limit", 10);
    pub_trajectory_vel_lim_ = this->create_publisher<Trajectory>("trajectory_vel_lim", 10);
    pub_trajectory_latacc_filtered_ = this->create_publisher<Trajectory>("trajectory_latacc_filtered", 10);
    pub_trajectory_steering_rate_limited_ = this->create_publisher<Trajectory>("trajectory_steering_rate_limited", 10);
    pub_trajectory_resampled_ = this->create_publisher<Trajectory>("trajectory_resampled", 10);
    debug_closest_velocity_ = this->create_publisher<Float32Stamped>("debug/closest_velocity", 10);
    debug_closest_acc_ = this->create_publisher<Float32Stamped>("debug/closest_acc", 10);
    debug_closest_jerk_ = this->create_publisher<Float32Stamped>("debug/closest_jerk", 10);
    debug_calculation_time_ = this->create_publisher<Float64Stamped>("debug/calculation_time", 10);
    debug_closest_max_velocity_ = this->create_publisher<Float32Stamped>("debug/closest_max_velocity", 10);
    debug_processing_time_detail_ = this->create_publisher<autoware::universe_utils::ProcessingTimeDetail>("debug/processing_time_detail", 10);
    pub_forward_filtered_trajectory_ = this->create_publisher<Trajectory>("forward_filtered_trajectory", 10);
    pub_backward_filtered_trajectory_ = this->create_publisher<Trajectory>("backward_filtered_trajectory", 10);
    pub_merged_filtered_trajectory_ = this->create_publisher<Trajectory>("merged_filtered_trajectory", 10);
    pub_closest_merged_velocity_ = this->create_publisher<Float32Stamped>("closest_merged_velocity", 10);

    // Initialize utility objects
    clock_ = this->get_clock();
    time_keeper_ = std::make_shared<autoware::universe_utils::TimeKeeper>(clock_);
    logger_configure_ = std::make_unique<autoware::universe_utils::LoggerLevelConfigure>(this);
    published_time_publisher_ = std::make_unique<autoware::universe_utils::PublishedTimePublisher>(this);

    // Setup smoother
    setupSmoother(wheelbase_);

    // Initialize common parameters
    initCommonParam();

    // Parameter callback for dynamic reconfiguration
    set_param_res_ = this->add_on_set_parameters_callback(
      [this](const std::vector<rclcpp::Parameter> & parameters) {
        rcl_interfaces::msg::SetParametersResult result;
        result.successful = true;

        for (const auto & param : parameters) {
          if (param.get_name() == "over_stop_velocity_warn_thr") {
            over_stop_velocity_warn_thr_ = param.as_double();
          } else if (param.get_name() == "wheelbase") {
            wheelbase_ = param.as_double();
            setupSmoother(wheelbase_);
          } else if (param.get_name() == "base_link2front") {
            base_link2front_ = param.as_double();
          } else if (param.get_name() == "publish_debug_trajs") {
            publish_debug_trajs_ = param.as_bool();
          } else if (param.get_name() == "max_velocity_with_deceleration") {
            max_velocity_with_deceleration_ = param.as_double();
          } else {
            result.successful = false;
            result.reason = "Unknown parameter: " + param.get_name();
          }
        }

        return result;
      });
  }
ground_truth.cpp: |-
  VelocitySmootherNode::VelocitySmootherNode(const rclcpp::NodeOptions & node_options)
  : Node("velocity_smoother", node_options),
    diagnostics_interface_(std::make_unique<DiagnosticsInterface>(this, "velocity_smoother"))
  {
    using std::placeholders::_1;

    // set common params
    const auto vehicle_info = autoware::vehicle_info_utils::VehicleInfoUtils(*this).getVehicleInfo();
    wheelbase_ = vehicle_info.wheel_base_m;
    base_link2front_ = vehicle_info.max_longitudinal_offset_m;
    initCommonParam();
    over_stop_velocity_warn_thr_ = declare_parameter<double>("over_stop_velocity_warn_thr");

    // create time_keeper and its publisher
    // NOTE: This has to be called before setupSmoother to pass the time_keeper to the smoother.
    debug_processing_time_detail_ = create_publisher<autoware::universe_utils::ProcessingTimeDetail>(
      "~/debug/processing_time_detail_ms", 1);
    time_keeper_ =
      std::make_shared<autoware::universe_utils::TimeKeeper>(debug_processing_time_detail_);

    // create smoother
    setupSmoother(wheelbase_);

    // publishers, subscribers
    pub_trajectory_ = create_publisher<Trajectory>("~/output/trajectory", 1);
    pub_virtual_wall_ = create_publisher<MarkerArray>("~/virtual_wall", 1);
    pub_velocity_limit_ = create_publisher<VelocityLimit>(
      "~/output/current_velocity_limit_mps", rclcpp::QoS{1}.transient_local());
    pub_dist_to_stopline_ = create_publisher<Float32Stamped>("~/distance_to_stopline", 1);
    sub_current_trajectory_ = create_subscription<Trajectory>(
      "~/input/trajectory", 1, std::bind(&VelocitySmootherNode::onCurrentTrajectory, this, _1));

    // parameter update
    set_param_res_ =
      this->add_on_set_parameters_callback(std::bind(&VelocitySmootherNode::onParameter, this, _1));

    // debug
    publish_debug_trajs_ = declare_parameter<bool>("publish_debug_trajs");
    debug_closest_velocity_ = create_publisher<Float32Stamped>("~/closest_velocity", 1);
    debug_closest_acc_ = create_publisher<Float32Stamped>("~/closest_acceleration", 1);
    debug_closest_jerk_ = create_publisher<Float32Stamped>("~/closest_jerk", 1);
    debug_closest_max_velocity_ = create_publisher<Float32Stamped>("~/closest_max_velocity", 1);
    debug_calculation_time_ = create_publisher<Float64Stamped>("~/debug/processing_time_ms", 1);
    pub_trajectory_raw_ = create_publisher<Trajectory>("~/debug/trajectory_raw", 1);
    pub_trajectory_vel_lim_ =
      create_publisher<Trajectory>("~/debug/trajectory_external_velocity_limited", 1);
    pub_trajectory_latacc_filtered_ =
      create_publisher<Trajectory>("~/debug/trajectory_lateral_acc_filtered", 1);
    pub_trajectory_steering_rate_limited_ =
      create_publisher<Trajectory>("~/debug/trajectory_steering_rate_limited", 1);
    pub_trajectory_resampled_ = create_publisher<Trajectory>("~/debug/trajectory_time_resampled", 1);

    external_velocity_limit_.velocity = node_param_.max_velocity;
    max_velocity_with_deceleration_ = node_param_.max_velocity;

    // publish default max velocity
    VelocityLimit max_vel_msg{};
    max_vel_msg.stamp = this->now();
    max_vel_msg.max_velocity = node_param_.max_velocity;
    pub_velocity_limit_->publish(max_vel_msg);

    clock_ = get_clock();

    logger_configure_ = std::make_unique<autoware::universe_utils::LoggerLevelConfigure>(this);
    published_time_publisher_ =
      std::make_unique<autoware::universe_utils::PublishedTimePublisher>(this);
  }
