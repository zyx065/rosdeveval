compilation.log: |
  Starting >>> autoware_velocity_smoother
  --- stderr: autoware_velocity_smoother
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_velocity_smoother/src/trajectory_utils.cpp: In function ‘std::vector<double> autoware::velocity_smoother::trajectory_utils::calcTrajectoryCurvatureFrom3Points(const TrajectoryPoints&, size_t)’:
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_velocity_smoother/src/trajectory_utils.cpp:198:27: error: ‘getPoint’ was not declared in this scope; did you mean ‘autoware::universe_utils::getPoint’?
    198 |     const auto & p_prev = getPoint(trajectory[idx_prev]);
        |                           ^~~~~~~~
        |                           autoware::universe_utils::getPoint
  In file included from /workspace/repos/autoware/install/autoware_motion_utils/include/autoware/motion_utils/trajectory/trajectory.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_velocity_smoother/src/trajectory_utils.cpp:18:
  /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/geometry/geometry.hpp:102:27: note: ‘autoware::universe_utils::getPoint’ declared here
    102 | geometry_msgs::msg::Point getPoint(const T & p)
        |                           ^~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_velocity_smoother/src/trajectory_utils.cpp:203:21: error: ‘calcCurvature’ was not declared in this scope
    203 |     curvatures[i] = calcCurvature(p_prev, p_curr, p_next);
        |                     ^~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_velocity_smoother/src/trajectory_utils.cpp:203:21: note: suggested alternatives:
  In file included from /workspace/repos/autoware/install/autoware_motion_utils/include/autoware/motion_utils/trajectory/trajectory.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_velocity_smoother/src/trajectory_utils.cpp:18:
  /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/geometry/geometry.hpp:443:8: note:   ‘autoware::universe_utils::calcCurvature’
    443 | double calcCurvature(
        |        ^~~~~~~~~~~~~
  In file included from /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_velocity_smoother/src/trajectory_utils.cpp:18:
  /workspace/repos/autoware/install/autoware_motion_utils/include/autoware/motion_utils/trajectory/trajectory.hpp:954:21: note:   ‘autoware::motion_utils::calcCurvature’
    954 | std::vector<double> calcCurvature(const T & points)
        |                     ^~~~~~~~~~~~~
  gmake[2]: *** [CMakeFiles/smoother.dir/build.make:160: CMakeFiles/smoother.dir/src/trajectory_utils.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:182: CMakeFiles/smoother.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_velocity_smoother [5.26s, exited with code 2]

  Summary: 0 packages finished [6.63s]
    1 package failed: autoware_velocity_smoother
    1 package had stderr output: autoware_velocity_smoother
generate_code.cpp: |-
  std::vector<double> calcTrajectoryCurvatureFrom3Points(
    const TrajectoryPoints & trajectory, size_t idx_dist)
  {
    // Ensure the trajectory has at least 3 points
    if (trajectory.size() < 3) {
      return std::vector<double>(trajectory.size(), 0.0);
    }

    // Constrain idx_dist to be within valid bounds
    idx_dist = std::max<size_t>(1, std::min<size_t>(idx_dist, trajectory.size() - 1));

    // Throw an error if idx_dist is invalid
    if (idx_dist < 1) {
      throw std::logic_error("idx_dist must be greater than or equal to 1.");
    }

    std::vector<double> curvatures(trajectory.size(), 0.0);

    // Iterate through the trajectory points
    for (size_t i = 0; i < trajectory.size(); ++i) {
      // Determine indices for the three points
      const size_t idx_prev = (i >= idx_dist) ? i - idx_dist : 0;
      const size_t idx_next = (i + idx_dist < trajectory.size()) ? i + idx_dist : trajectory.size() - 1;

      // Retrieve the three points
      const auto & p_prev = getPoint(trajectory[idx_prev]);
      const auto & p_curr = getPoint(trajectory[i]);
      const auto & p_next = getPoint(trajectory[idx_next]);

      // Calculate curvature using the three points
      curvatures[i] = calcCurvature(p_prev, p_curr, p_next);
    }

    return curvatures;
  }
ground_truth.cpp: |-
  std::vector<double> calcTrajectoryCurvatureFrom3Points(
    const TrajectoryPoints & trajectory, size_t idx_dist)
  {
    using autoware::universe_utils::calcCurvature;
    using autoware::universe_utils::getPoint;

    if (trajectory.size() < 3) {
      const std::vector<double> k_arr(trajectory.size(), 0.0);
      return k_arr;
    }

    // if the idx size is not enough, change the idx_dist
    const auto max_idx_dist = static_cast<size_t>(std::floor((trajectory.size() - 1) / 2.0));
    idx_dist = std::max(1ul, std::min(idx_dist, max_idx_dist));

    if (idx_dist < 1) {
      throw std::logic_error("idx_dist less than 1 is not expected");
    }

    // calculate curvature by circle fitting from three points
    std::vector<double> k_arr(trajectory.size(), 0.0);

    for (size_t i = 1; i + 1 < trajectory.size(); i++) {
      double curvature = 0.0;
      const auto p0 = getPoint(trajectory.at(i - std::min(idx_dist, i)));
      const auto p1 = getPoint(trajectory.at(i));
      const auto p2 = getPoint(trajectory.at(i + std::min(idx_dist, trajectory.size() - 1 - i)));
      try {
        curvature = calcCurvature(p0, p1, p2);
      } catch (std::exception const & e) {
        // ...code that handles the error...
        RCLCPP_WARN(
          rclcpp::get_logger("autoware_velocity_smoother").get_child("trajectory_utils"), "%s",
          e.what());
        if (i > 1) {
          curvature = k_arr.at(i - 1);  // previous curvature
        } else {
          curvature = 0.0;
        }
      }
      k_arr.at(i) = curvature;
    }
    // copy curvatures for the last and first points;
    k_arr.at(0) = k_arr.at(1);
    k_arr.back() = k_arr.at((trajectory.size() - 2));

    return k_arr;
  }
