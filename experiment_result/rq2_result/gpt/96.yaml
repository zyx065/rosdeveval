compilation.log: |
  Starting >>> perception_utils
  Finished <<< perception_utils [1.71s]

  Summary: 1 package finished [3.13s]
generate_code.cpp: |-
  cv::Mat runLengthDecoder(const std::vector<uint8_t> & rle_data, const int rows, const int cols) {
      // Create an empty matrix with the specified dimensions
      cv::Mat decoded_image = cv::Mat::zeros(rows, cols, CV_8UC1);

      // Flatten the matrix for easier access during decoding
      uint8_t* data_ptr = decoded_image.ptr<uint8_t>();

      // Index to track the position in the decoded matrix
      int index = 0;

      // Iterate through the run-length encoded data
      for (size_t i = 0; i < rle_data.size(); i += 2) {
          uint8_t value = rle_data[i];       // Value (0 or 255 for binary image)
          uint8_t length = rle_data[i + 1]; // Length of the run

          // Fill the decoded matrix with the value for the specified length
          for (int j = 0; j < length; ++j) {
              if (index >= rows * cols) {
                  throw std::runtime_error("Run-length data exceeds matrix size");
              }
              data_ptr[index++] = value;
          }
      }

      // Ensure the decoded matrix matches the expected size
      if (index != rows * cols) {
          throw std::runtime_error("Run-length data does not match matrix size");
      }

      return decoded_image;
  }
ground_truth.cpp: |-
  cv::Mat runLengthDecoder(const std::vector<uint8_t> & rle_data, const int rows, const int cols)
  {
    cv::Mat mask(rows, cols, CV_8UC1, cv::Scalar(0));
    int idx = 0;
    int step = sizeof(uint8_t) + sizeof(int);
    for (size_t i = 0; i < rle_data.size(); i += step) {
      uint8_t value;
      int length;
      std::memcpy(&value, &rle_data[i], sizeof(uint8_t));
      std::memcpy(
        &length, &rle_data[i + 1],
        sizeof(
          int));  // under the condition that we know rle_data[i] only consume 1 element of the vector
      for (int j = 0; j < length; ++j) {
        int row_idx = static_cast<int>(idx / cols);
        int col_idx = static_cast<int>(idx % cols);
        mask.at<uint8_t>(row_idx, col_idx) = value;
        idx++;
        if (idx > rows * cols) {
          break;
        }
      }
    }
    return mask;
  }
