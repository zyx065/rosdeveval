compilation.log: |
  Starting >>> moveit_core
  --- stderr: moveit_core
  /root/repos/moveit_ws/src/moveit2/moveit_core/distance_field/src/find_internal_points.cpp: In function ‘void distance_field::findInternalPointsConvex(const bodies::Body&, double, EigenSTL::vector_Vector3d&)’:
  /root/repos/moveit_ws/src/moveit2/moveit_core/distance_field/src/find_internal_points.cpp:47:31: error: no matching function for call to ‘bodies::Body::computeBoundingSphere(Eigen::Vector3d&, double&) const’
     47 |     body.computeBoundingSphere(center, radius);
        |     ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~
  In file included from /root/repos/moveit_ws/src/moveit2/moveit_core/distance_field/include/moveit/distance_field/find_internal_points.h:40,
                   from /root/repos/moveit_ws/src/moveit2/moveit_core/distance_field/src/find_internal_points.cpp:37:
  /opt/ros/humble/include/geometric_shapes/geometric_shapes/bodies.h:234:16: note: candidate: ‘virtual void bodies::Body::computeBoundingSphere(bodies::BoundingSphere&) const’
    234 |   virtual void computeBoundingSphere(BoundingSphere& sphere) const = 0;
        |                ^~~~~~~~~~~~~~~~~~~~~
  /opt/ros/humble/include/geometric_shapes/geometric_shapes/bodies.h:234:16: note:   candidate expects 1 argument, 2 provided
  gmake[2]: *** [distance_field/CMakeFiles/moveit_distance_field.dir/build.make:93: distance_field/CMakeFiles/moveit_distance_field.dir/src/find_internal_points.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:955: distance_field/CMakeFiles/moveit_distance_field.dir/all] Error 2
  gmake: *** [Makefile:149: all] Error 2
  ---
  Failed   <<< moveit_core [1.41s, exited with code 2]

  Summary: 0 packages finished [1.86s]
    1 package failed: moveit_core
    1 package had stderr output: moveit_core
generate_code.cpp: |-
  void distance_field::findInternalPointsConvex(const bodies::Body& body, double resolution,
                                                EigenSTL::vector_Vector3d& points)
  {
      points.clear();

      // Get the bounding sphere of the body
      Eigen::Vector3d center;
      double radius;
      body.computeBoundingSphere(center, radius);

      // Define the bounds of the sampling grid
      double min_x = center.x() - radius;
      double max_x = center.x() + radius;
      double min_y = center.y() - radius;
      double max_y = center.y() + radius;
      double min_z = center.z() - radius;
      double max_z = center.z() + radius;

      // Iterate through the grid points within the bounding sphere
      for (double x = min_x; x <= max_x; x += resolution)
      {
          for (double y = min_y; y <= max_y; y += resolution)
          {
              for (double z = min_z; z <= max_z; z += resolution)
              {
                  Eigen::Vector3d point(x, y, z);

                  // Check if the point is inside the convex body
                  if (body.containsPoint(point))
                  {
                      points.push_back(point);
                  }
              }
          }
      }
  }
ground_truth.cpp: |-
  void distance_field::findInternalPointsConvex(const bodies::Body& body, double resolution,
                                                EigenSTL::vector_Vector3d& points)
  {
    bodies::BoundingSphere sphere;
    body.computeBoundingSphere(sphere);
    double xval_s = std::floor((sphere.center.x() - sphere.radius - resolution) / resolution) * resolution;
    double yval_s = std::floor((sphere.center.y() - sphere.radius - resolution) / resolution) * resolution;
    double zval_s = std::floor((sphere.center.z() - sphere.radius - resolution) / resolution) * resolution;
    double xval_e = sphere.center.x() + sphere.radius + resolution;
    double yval_e = sphere.center.y() + sphere.radius + resolution;
    double zval_e = sphere.center.z() + sphere.radius + resolution;
    Eigen::Vector3d pt;
    for (pt.x() = xval_s; pt.x() <= xval_e; pt.x() += resolution)
    {
      for (pt.y() = yval_s; pt.y() <= yval_e; pt.y() += resolution)
      {
        for (pt.z() = zval_s; pt.z() <= zval_e; pt.z() += resolution)
        {
          if (body.containsPoint(pt))
          {
            points.push_back(pt);
          }
        }
      }
    }
  }
