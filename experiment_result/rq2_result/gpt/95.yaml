compilation.log: ""
generate_code.cpp: |-
  std::optional<double> calcDecelDistWithJerkAndAccConstraints(
    const double current_vel, const double target_vel, const double current_acc, const double acc_min,
    const double jerk_acc, const double jerk_dec)
  {
    // Ensure the current velocity is greater than or equal to the target velocity
    if (current_vel < target_vel) {
      return std::nullopt;
    }

    // Check if the current acceleration is above the minimum acceleration limit
    if (current_acc > acc_min) {
      // Plan Type 1: Deceleration involves a phase where acceleration is clamped to the minimum acceleration
      const double t_during_min_acc = (acc_min - current_acc) / jerk_dec; // Time to reach acc_min
      auto dist_plan_type1 = calcDecelDistPlanType1(
        current_vel, target_vel, current_acc, acc_min, jerk_acc, jerk_dec, t_during_min_acc);
      if (dist_plan_type1) {
        return dist_plan_type1;
      }
    }

    // Plan Type 2: Deceleration without clamping to the minimum acceleration
    auto dist_plan_type2 = calcDecelDistPlanType2(
      current_vel, target_vel, current_acc, jerk_acc, jerk_dec);
    if (dist_plan_type2) {
      return dist_plan_type2;
    }

    // Plan Type 3: Deceleration without considering the current acceleration
    auto dist_plan_type3 = calcDecelDistPlanType3(
      current_vel, target_vel, current_acc, jerk_acc);
    if (dist_plan_type3) {
      return dist_plan_type3;
    }

    // If no valid plan is found, return std::nullopt
    return std::nullopt;
  }
ground_truth.cpp: |-
  std::optional<double> calcDecelDistWithJerkAndAccConstraints(
    const double current_vel, const double target_vel, const double current_acc, const double acc_min,
    const double jerk_acc, const double jerk_dec)
  {
    if (current_vel < target_vel) {
      return {};
    }

    constexpr double epsilon = 1e-3;
    const double jerk_before_min_acc = acc_min < current_acc ? jerk_dec : jerk_acc;
    const double t_before_min_acc = (acc_min - current_acc) / jerk_before_min_acc;
    const double jerk_after_min_acc = jerk_acc;
    const double t_after_min_acc = (0.0 - acc_min) / jerk_after_min_acc;

    const double t_during_min_acc =
      (target_vel - current_vel - current_acc * t_before_min_acc -
       0.5 * jerk_before_min_acc * std::pow(t_before_min_acc, 2) - acc_min * t_after_min_acc -
       0.5 * jerk_after_min_acc * std::pow(t_after_min_acc, 2)) /
      acc_min;

    // check if it is possible to decelerate to the target velocity
    // by simply bringing the current acceleration to zero.
    const auto is_decel_needed =
      0.5 * (0.0 - current_acc) / jerk_acc * current_acc > target_vel - current_vel;

    if (t_during_min_acc > epsilon) {
      return calcDecelDistPlanType1(
        current_vel, target_vel, current_acc, acc_min, jerk_acc, jerk_dec, t_during_min_acc);
    }
    if (is_decel_needed || current_acc > epsilon) {
      return calcDecelDistPlanType2(current_vel, target_vel, current_acc, jerk_acc, jerk_dec);
    }

    return calcDecelDistPlanType3(current_vel, target_vel, current_acc, jerk_acc);
  }
