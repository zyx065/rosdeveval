compilation.log: |
  Starting >>> nav2_smac_planner
  --- stderr: nav2_smac_planner
  /root/repos/nav_ws/src/nav2_smac_planner/src/node_2d.cpp: In member function ‘void nav2_smac_planner::Node2D::getNeighbors(std::function<bool(const unsigned int&, nav2_smac_planner::Node2D*&)>&, nav2_smac_planner::GridCollisionChecker*, const bool&, nav2_smac_planner::Node2D::NodeVector&)’:
  /root/repos/nav_ws/src/nav2_smac_planner/src/node_2d.cpp:127:28: error: ‘class nav2_smac_planner::Node2D’ has no member named ‘x’
    127 |     int neighbor_x = this->x + dx[i];
        |                            ^
  /root/repos/nav_ws/src/nav2_smac_planner/src/node_2d.cpp:128:28: error: ‘class nav2_smac_planner::Node2D’ has no member named ‘y’
    128 |     int neighbor_y = this->y + dy[i];
        |                            ^
  /root/repos/nav_ws/src/nav2_smac_planner/src/node_2d.cpp:131:48: error: ‘toIndex’ is not a member of ‘nav2_smac_planner::Node2D::Coordinates’
    131 |     unsigned int neighbor_index = Coordinates::toIndex(neighbor_x, neighbor_y);
        |                                                ^~~~~~~
  /root/repos/nav_ws/src/nav2_smac_planner/src/node_2d.cpp: In member function ‘void nav2_smac_planner::Node2D::getNeighbors(std::function<bool(const unsigned int&, nav2_smac_planner::Node2D*&)>&, nav2_smac_planner::GridCollisionChecker*, const bool&, nav2_smac_planner::Node2D::NodeVector&)’:
  /root/repos/nav_ws/src/nav2_smac_planner/src/node_2d.cpp:127:28: error: ‘class nav2_smac_planner::Node2D’ has no member named ‘x’
    127 |     int neighbor_x = this->x + dx[i];
        |                            ^
  /root/repos/nav_ws/src/nav2_smac_planner/src/node_2d.cpp:128:28: error: ‘class nav2_smac_planner::Node2D’ has no member named ‘y’
    128 |     int neighbor_y = this->y + dy[i];
        |                            ^
  /root/repos/nav_ws/src/nav2_smac_planner/src/node_2d.cpp:131:48: error: ‘toIndex’ is not a member of ‘nav2_smac_planner::Node2D::Coordinates’
    131 |     unsigned int neighbor_index = Coordinates::toIndex(neighbor_x, neighbor_y);
        |                                                ^~~~~~~
  /root/repos/nav_ws/src/nav2_smac_planner/src/node_2d.cpp: In member function ‘void nav2_smac_planner::Node2D::getNeighbors(std::function<bool(const unsigned int&, nav2_smac_planner::Node2D*&)>&, nav2_smac_planner::GridCollisionChecker*, const bool&, nav2_smac_planner::Node2D::NodeVector&)’:
  /root/repos/nav_ws/src/nav2_smac_planner/src/node_2d.cpp:127:28: error: ‘class nav2_smac_planner::Node2D’ has no member named ‘x’
    127 |     int neighbor_x = this->x + dx[i];
        |                            ^
  /root/repos/nav_ws/src/nav2_smac_planner/src/node_2d.cpp:128:28: error: ‘class nav2_smac_planner::Node2D’ has no member named ‘y’
    128 |     int neighbor_y = this->y + dy[i];
        |                            ^
  /root/repos/nav_ws/src/nav2_smac_planner/src/node_2d.cpp:131:48: error: ‘toIndex’ is not a member of ‘nav2_smac_planner::Node2D::Coordinates’
    131 |     unsigned int neighbor_index = Coordinates::toIndex(neighbor_x, neighbor_y);
        |                                                ^~~~~~~
  gmake[2]: *** [CMakeFiles/nav2_smac_planner_2d.dir/build.make:188: CMakeFiles/nav2_smac_planner_2d.dir/src/node_2d.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:222: CMakeFiles/nav2_smac_planner_2d.dir/all] Error 2
  gmake[1]: *** Waiting for unfinished jobs....
  gmake[2]: *** [CMakeFiles/nav2_smac_planner.dir/build.make:188: CMakeFiles/nav2_smac_planner.dir/src/node_2d.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:196: CMakeFiles/nav2_smac_planner.dir/all] Error 2
  gmake[2]: *** [CMakeFiles/nav2_smac_planner_lattice.dir/build.make:188: CMakeFiles/nav2_smac_planner_lattice.dir/src/node_2d.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:248: CMakeFiles/nav2_smac_planner_lattice.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< nav2_smac_planner [5.04s, exited with code 2]

  Summary: 0 packages finished [5.35s]
    1 package failed: nav2_smac_planner
    1 package had stderr output: nav2_smac_planner
generate_code.cpp: |-
  void Node2D::getNeighbors(
    std::function<bool(const unsigned int &, nav2_smac_planner::Node2D * &)> & NeighborGetter,
    GridCollisionChecker * collision_checker,
    const bool & traverse_unknown,
    NodeVector & neighbors)
  {
    // Define possible movement offsets for 8-connected grid (diagonal and straight moves)
    const int dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};
    const int dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};

    // Clear the neighbors vector before populating
    neighbors.clear();

    // Iterate through all possible neighbors
    for (int i = 0; i < 8; ++i) {
      // Calculate the coordinates of the neighbor
      int neighbor_x = this->x + dx[i];
      int neighbor_y = this->y + dy[i];

      // Convert coordinates to an index
      unsigned int neighbor_index = Coordinates::toIndex(neighbor_x, neighbor_y);

      // Retrieve the neighbor node using the NeighborGetter function
      nav2_smac_planner::Node2D * neighbor_node = nullptr;
      if (!NeighborGetter(neighbor_index, neighbor_node)) {
        continue; // Skip if the neighbor node cannot be retrieved
      }

      // Check if the neighbor node is valid
      if (!neighbor_node->isNodeValid(traverse_unknown, collision_checker)) {
        continue; // Skip if the neighbor node is invalid
      }

      // Add the valid neighbor node to the neighbors vector
      neighbors.push_back(neighbor_node);
    }
  }
ground_truth.cpp: |-
  void Node2D::getNeighbors(
    std::function<bool(const unsigned int &, nav2_smac_planner::Node2D * &)> & NeighborGetter,
    GridCollisionChecker * collision_checker,
    const bool & traverse_unknown,
    NodeVector & neighbors)
  {
    // NOTE(stevemacenski): Irritatingly, the order here matters. If you start in free
    // space and then expand 8-connected, the first set of neighbors will be all cost
    // 1.0. Then its expansion will all be 2 * 1.0 but now multiple
    // nodes are touching that node so the last cell to update the back pointer wins.
    // Thusly, the ordering ends with the cardinal directions for both sets such that
    // behavior is consistent in large free spaces between them.
    // 100  50   0
    // 100  50  50
    // 100 100 100   where lower-middle '100' is visited with same cost by both bottom '50' nodes
    // Therefore, it is valuable to have some low-potential across the entire map
    // rather than a small inflation around the obstacles
    int index;
    NodePtr neighbor;
    int node_i = this->getIndex();
    const Coordinates parent = getCoords(this->getIndex());
    Coordinates child;

    for (unsigned int i = 0; i != _neighbors_grid_offsets.size(); ++i) {
      index = node_i + _neighbors_grid_offsets[i];

      // Check for wrap around conditions
      child = getCoords(index);
      if (fabs(parent.x - child.x) > 1 || fabs(parent.y - child.y) > 1) {
        continue;
      }

      if (NeighborGetter(index, neighbor)) {
        if (neighbor->isNodeValid(traverse_unknown, collision_checker) && !neighbor->wasVisited()) {
          neighbors.push_back(neighbor);
        }
      }
    }
  }
