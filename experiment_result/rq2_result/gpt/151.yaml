compilation.log: |
  Starting >>> moveit_core
  Finished <<< moveit_core [0.86s]

  Summary: 1 package finished [1.30s]
generate_code.cpp: |-
  void FloatingJointModel::interpolate(const double* from, const double* to, const double t, double* state) const
  {
      // Interpolation for the position (x, y, z)
      state[0] = from[0] + t * (to[0] - from[0]); // x
      state[1] = from[1] + t * (to[1] - from[1]); // y
      state[2] = from[2] + t * (to[2] - from[2]); // z

      // Interpolation for the orientation (quaternion: w, x, y, z)
      const double* from_quat = from + 3; // Orientation starts at index 3
      const double* to_quat = to + 3;     // Orientation starts at index 3
      double* state_quat = state + 3;     // Orientation starts at index 3

      // Perform spherical linear interpolation (slerp) for quaternions
      double dot_product = from_quat[0] * to_quat[0] + from_quat[1] * to_quat[1] +
                           from_quat[2] * to_quat[2] + from_quat[3] * to_quat[3];

      // If the dot product is negative, slerp won't take the shorter path.
      // Invert one quaternion to ensure the shortest path is taken.
      if (dot_product < 0.0)
      {
          dot_product = -dot_product;
          to_quat = new double[4]{-to_quat[0], -to_quat[1], -to_quat[2], -to_quat[3]};
      }

      // Clamp dot product to avoid numerical errors
      dot_product = std::min(std::max(dot_product, -1.0), 1.0);

      double theta = std::acos(dot_product); // Angle between the two quaternions
      double sin_theta = std::sin(theta);

      if (sin_theta > 1e-6) // If the angle is significant
      {
          double weight_from = std::sin((1 - t) * theta) / sin_theta;
          double weight_to = std::sin(t * theta) / sin_theta;

          state_quat[0] = weight_from * from_quat[0] + weight_to * to_quat[0];
          state_quat[1] = weight_from * from_quat[1] + weight_to * to_quat[1];
          state_quat[2] = weight_from * from_quat[2] + weight_to * to_quat[2];
          state_quat[3] = weight_from * from_quat[3] + weight_to * to_quat[3];
      }
      else // If the angle is very small, use linear interpolation
      {
          state_quat[0] = (1 - t) * from_quat[0] + t * to_quat[0];
          state_quat[1] = (1 - t) * from_quat[1] + t * to_quat[1];
          state_quat[2] = (1 - t) * from_quat[2] + t * to_quat[2];
          state_quat[3] = (1 - t) * from_quat[3] + t * to_quat[3];
      }

      // Normalize the resulting quaternion to ensure it remains valid
      double norm = std::sqrt(state_quat[0] * state_quat[0] + state_quat[1] * state_quat[1] +
                              state_quat[2] * state_quat[2] + state_quat[3] * state_quat[3]);

      state_quat[0] /= norm;
      state_quat[1] /= norm;
      state_quat[2] /= norm;
      state_quat[3] /= norm;

      // Clean up dynamically allocated memory if used
      if (dot_product < 0.0)
      {
          delete[] to_quat;
      }
  }
ground_truth.cpp: |-
  void FloatingJointModel::interpolate(const double* from, const double* to, const double t, double* state) const
  {
    // interpolate position
    state[0] = from[0] + (to[0] - from[0]) * t;
    state[1] = from[1] + (to[1] - from[1]) * t;
    state[2] = from[2] + (to[2] - from[2]) * t;

    // Check if the quaternions are significantly different
    if (abs(from[3] - to[3]) + abs(from[4] - to[4]) + abs(from[5] - to[5]) + abs(from[6] - to[6]) >
        std::numeric_limits<double>::epsilon())
    {
      // Note the ordering: Eigen takes w first!
      Eigen::Quaterniond q1(from[6], from[3], from[4], from[5]);
      Eigen::Quaterniond q2(to[6], to[3], to[4], to[5]);

      Eigen::Quaterniond q = q1.slerp(t, q2);

      state[3] = q.x();
      state[4] = q.y();
      state[5] = q.z();
      state[6] = q.w();
    }
    else
    {
      state[3] = from[3];
      state[4] = from[4];
      state[5] = from[5];
      state[6] = from[6];
    }
  }
