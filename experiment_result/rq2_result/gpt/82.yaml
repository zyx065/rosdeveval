compilation.log: |
  Starting >>> autoware_pid_longitudinal_controller
  --- stderr: autoware_pid_longitudinal_controller
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp: In member function ‘double autoware::motion::control::pid_longitudinal_controller::SmoothStop::calculate(double, double, double, const std::vector<std::pair<rclcpp::Time, double> >&, double, autoware::motion::control::pid_longitudinal_controller::DebugValues&)’:
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp:123:7: error: no match for ‘operator!’ (operand type is ‘autoware::motion::control::pid_longitudinal_controller::SmoothStop::Params’)
    123 |   if (!m_params) {
        |       ^~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp:123:7: note: candidate: ‘operator!(bool)’ (built-in)
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp:123:7: note:   no known conversion for argument 1 from ‘autoware::motion::control::pid_longitudinal_controller::SmoothStop::Params’ to ‘bool’
  In file included from /opt/ros/humble/include/libstatistics_collector/libstatistics_collector/moving_average_statistics/moving_average.hpp:30,
                   from /opt/ros/humble/include/libstatistics_collector/libstatistics_collector/collector/collector.hpp:22,
                   from /opt/ros/humble/include/libstatistics_collector/libstatistics_collector/topic_statistics_collector/topic_statistics_collector.hpp:24,
                   from /opt/ros/humble/include/libstatistics_collector/libstatistics_collector/topic_statistics_collector/received_message_age.hpp:26,
                   from /opt/ros/humble/include/rclcpp/rclcpp/topic_statistics/subscription_topic_statistics.hpp:26,
                   from /opt/ros/humble/include/rclcpp/rclcpp/subscription.hpp:50,
                   from /opt/ros/humble/include/rclcpp/rclcpp/any_executable.hpp:25,
                   from /opt/ros/humble/include/rclcpp/rclcpp/memory_strategy.hpp:25,
                   from /opt/ros/humble/include/rclcpp/rclcpp/memory_strategies.hpp:18,
                   from /opt/ros/humble/include/rclcpp/rclcpp/executor_options.hpp:20,
                   from /opt/ros/humble/include/rclcpp/rclcpp/executor.hpp:37,
                   from /opt/ros/humble/include/rclcpp/rclcpp/executors/multi_threaded_executor.hpp:25,
                   from /opt/ros/humble/include/rclcpp/rclcpp/executors.hpp:21,
                   from /opt/ros/humble/include/rclcpp/rclcpp/rclcpp.hpp:155,
                   from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/include/autoware/pid_longitudinal_controller/smooth_stop.hpp:19,
                   from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp:15:
  /opt/ros/humble/include/rcpputils/rcpputils/thread_safety_annotations.hpp:55:27: note: candidate: ‘const std::mutex& operator!(const std::mutex&)’
     55 | inline const std::mutex & operator!(const std::mutex & a)
        |                           ^~~~~~~~
  /opt/ros/humble/include/rcpputils/rcpputils/thread_safety_annotations.hpp:55:56: note:   no known conversion for argument 1 from ‘autoware::motion::control::pid_longitudinal_controller::SmoothStop::Params’ to ‘const std::mutex&’
     55 | inline const std::mutex & operator!(const std::mutex & a)
        |                                     ~~~~~~~~~~~~~~~~~~~^
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp:128:25: error: no match for ‘operator*’ (operand type is ‘autoware::motion::control::pid_longitudinal_controller::SmoothStop::Params’)
    128 |   const auto & params = *m_params;
        |                         ^~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp:118:66: error: unused parameter ‘current_acc’ [-Werror=unused-parameter]
    118 |   const double stop_dist, const double current_vel, const double current_acc,
        |                                                     ~~~~~~~~~~~~~^~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp:119:79: error: unused parameter ‘delay_time’ [-Werror=unused-parameter]
    119 |   const std::vector<std::pair<rclcpp::Time, double>> & vel_hist, const double delay_time,
        |                                                                  ~~~~~~~~~~~~~^~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp:120:17: error: unused parameter ‘debug_values’ [-Werror=unused-parameter]
    120 |   DebugValues & debug_values)
        |   ~~~~~~~~~~~~~~^~~~~~~~~~~~
  cc1plus: all warnings being treated as errors
  gmake[2]: *** [CMakeFiles/autoware_pid_longitudinal_controller_lib.dir/build.make:118: CMakeFiles/autoware_pid_longitudinal_controller_lib.dir/src/smooth_stop.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:157: CMakeFiles/autoware_pid_longitudinal_controller_lib.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_pid_longitudinal_controller [2.71s, exited with code 2]

  Summary: 0 packages finished [4.10s]
    1 package failed: autoware_pid_longitudinal_controller
    1 package had stderr output: autoware_pid_longitudinal_controller
generate_code.cpp: |-
  double SmoothStop::calculate(
    const double stop_dist, const double current_vel, const double current_acc,
    const std::vector<std::pair<rclcpp::Time, double>> & vel_hist, const double delay_time,
    DebugValues & debug_values)
  {
    // Ensure parameters are initialized
    if (!m_params) {
      throw std::runtime_error("Parameters have not been initialized.");
    }

    // Extract parameters for readability
    const auto & params = *m_params;

    // Handle case where stop_dist is negative (vehicle has passed stop line)
    if (stop_dist < 0.0) {
      return params.strong_stop_acc;
    }

    // Handle case where vehicle is nearly stationary
    if (current_vel < params.min_running_vel) {
      if (stop_dist < params.weak_stop_dist) {
        return params.weak_stop_acc;
      }
      return 0.0; // No acceleration needed for very low velocity
    }

    // Predict time to stop using velocity history
    const auto time_to_stop_opt = calcTimeToStop(vel_hist);
    const double time_to_stop = time_to_stop_opt ? *time_to_stop_opt : std::numeric_limits<double>::max();

    // Calculate stopping acceleration based on stop distance and velocity
    if (stop_dist < params.strong_stop_dist) {
      return params.strong_stop_acc;
    } else if (time_to_stop < params.weak_stop_time) {
      return params.weak_stop_acc;
    } else if (current_vel > params.min_fast_vel) {
      return params.weak_acc;
    }

    // Default to weak acceleration for smooth stopping
    return params.weak_acc;
  }
ground_truth.cpp: |-
  double SmoothStop::calculate(
    const double stop_dist, const double current_vel, const double current_acc,
    const std::vector<std::pair<rclcpp::Time, double>> & vel_hist, const double delay_time,
    DebugValues & debug_values)
  {
    if (!m_is_set_params) {
      throw std::runtime_error("Trying to calculate uninitialized SmoothStop");
    }

    // predict time to stop
    const auto time_to_stop = calcTimeToStop(vel_hist);

    // calculate some flags
    const bool is_fast_vel = std::abs(current_vel) > m_params.min_fast_vel;
    const bool is_running = std::abs(current_vel) > m_params.min_running_vel ||
                            std::abs(current_acc) > m_params.min_running_acc;

    // when exceeding the stopline (stop_dist is negative in these cases.)
    if (stop_dist < m_params.strong_stop_dist) {  // when exceeding the stopline much
      debug_values.setValues(
        DebugValues::TYPE::SMOOTH_STOP_MODE, static_cast<int>(Mode::STRONG_STOP));
      return m_params.strong_stop_acc;
    } else if (stop_dist < m_params.weak_stop_dist) {  // when exceeding the stopline a bit
      debug_values.setValues(DebugValues::TYPE::SMOOTH_STOP_MODE, static_cast<int>(Mode::WEAK_STOP));
      return m_params.weak_stop_acc;
    }

    // when the car is running
    if (is_running) {
      // when the car will not stop in a certain time
      if (
        (time_to_stop && *time_to_stop > m_params.weak_stop_time + delay_time) ||
        (!time_to_stop && is_fast_vel)) {
        debug_values.setValues(DebugValues::TYPE::SMOOTH_STOP_MODE, static_cast<int>(Mode::STRONG));
        return m_strong_acc;
      }

      m_weak_acc_time = rclcpp::Clock{RCL_ROS_TIME}.now();
      debug_values.setValues(DebugValues::TYPE::SMOOTH_STOP_MODE, static_cast<int>(Mode::WEAK));
      return m_params.weak_acc;
    }

    // for 0.5 seconds after the car stopped
    if ((rclcpp::Clock{RCL_ROS_TIME}.now() - m_weak_acc_time).seconds() < 0.5) {
      debug_values.setValues(DebugValues::TYPE::SMOOTH_STOP_MODE, static_cast<int>(Mode::WEAK));
      return m_params.weak_acc;
    }

    // when the car is not running
    debug_values.setValues(DebugValues::TYPE::SMOOTH_STOP_MODE, static_cast<int>(Mode::STRONG_STOP));
    return m_params.strong_stop_acc;
  }
