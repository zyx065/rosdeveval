compilation.log: |
  Starting >>> moveit_core
  --- stderr: moveit_core
  /root/repos/moveit_ws/src/moveit2/moveit_core/robot_trajectory/src/robot_trajectory.cpp: In function ‘std::optional<double> robot_trajectory::smoothness(const robot_trajectory::RobotTrajectory&)’:
  /root/repos/moveit_ws/src/moveit2/moveit_core/robot_trajectory/src/robot_trajectory.cpp:640:28: error: request for member ‘size’ in ‘prev_positions’, which is of non-class type ‘const double* const’
    640 |         if (prev_positions.size() != curr_positions.size() || curr_positions.size() != next_positions.size())
        |                            ^~~~
  /root/repos/moveit_ws/src/moveit2/moveit_core/robot_trajectory/src/robot_trajectory.cpp:640:53: error: request for member ‘size’ in ‘curr_positions’, which is of non-class type ‘const double* const’
    640 |         if (prev_positions.size() != curr_positions.size() || curr_positions.size() != next_positions.size())
        |                                                     ^~~~
  /root/repos/moveit_ws/src/moveit2/moveit_core/robot_trajectory/src/robot_trajectory.cpp:640:78: error: request for member ‘size’ in ‘curr_positions’, which is of non-class type ‘const double* const’
    640 |         if (prev_positions.size() != curr_positions.size() || curr_positions.size() != next_positions.size())
        |                                                                              ^~~~
  /root/repos/moveit_ws/src/moveit2/moveit_core/robot_trajectory/src/robot_trajectory.cpp:640:103: error: request for member ‘size’ in ‘next_positions’, which is of non-class type ‘const double* const’
    640 |         if (prev_positions.size() != curr_positions.size() || curr_positions.size() != next_positions.size())
        |                                                                                                       ^~~~
  /root/repos/moveit_ws/src/moveit2/moveit_core/robot_trajectory/src/robot_trajectory.cpp:647:52: error: request for member ‘size’ in ‘prev_positions’, which is of non-class type ‘const double* const’
    647 |         for (std::size_t j = 0; j < prev_positions.size(); ++j)
        |                                                    ^~~~
  gmake[2]: *** [robot_trajectory/CMakeFiles/moveit_robot_trajectory.dir/build.make:79: robot_trajectory/CMakeFiles/moveit_robot_trajectory.dir/src/robot_trajectory.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:1855: robot_trajectory/CMakeFiles/moveit_robot_trajectory.dir/all] Error 2
  gmake: *** [Makefile:149: all] Error 2
  ---
  Failed   <<< moveit_core [5.53s, exited with code 2]

  Summary: 0 packages finished [6.00s]
    1 package failed: moveit_core
    1 package had stderr output: moveit_core
generate_code.cpp: |-
  std::optional<double> smoothness(RobotTrajectory const& trajectory)
  {
      // Check if the trajectory has enough waypoints to calculate smoothness
      if (trajectory.getWayPointCount() < 3)
      {
          return std::nullopt; // Not enough waypoints to calculate smoothness
      }

      double total_angle_deviation = 0.0;

      // Iterate through the trajectory waypoints
      for (std::size_t i = 1; i < trajectory.getWayPointCount() - 1; ++i)
      {
          // Get the previous, current, and next waypoints
          const auto& prev_state = trajectory.getWayPoint(i - 1);
          const auto& curr_state = trajectory.getWayPoint(i);
          const auto& next_state = trajectory.getWayPoint(i + 1);

          // Extract joint positions from the robot states
          const auto& prev_positions = prev_state.getVariablePositions();
          const auto& curr_positions = curr_state.getVariablePositions();
          const auto& next_positions = next_state.getVariablePositions();

          // Ensure the joint position vectors are of the same size
          if (prev_positions.size() != curr_positions.size() || curr_positions.size() != next_positions.size())
          {
              return std::nullopt; // Inconsistent joint position sizes
          }

          // Calculate the angle deviation for each joint
          double waypoint_angle_deviation = 0.0;
          for (std::size_t j = 0; j < prev_positions.size(); ++j)
          {
              double v1 = curr_positions[j] - prev_positions[j]; // Vector from previous to current
              double v2 = next_positions[j] - curr_positions[j]; // Vector from current to next

              // Calculate the angle deviation using the dot product formula
              double dot_product = v1 * v2;
              double magnitude_v1 = std::abs(v1);
              double magnitude_v2 = std::abs(v2);

              if (magnitude_v1 > 1e-6 && magnitude_v2 > 1e-6) // Avoid division by zero
              {
                  double cos_theta = dot_product / (magnitude_v1 * magnitude_v2);
                  cos_theta = std::clamp(cos_theta, -1.0, 1.0); // Clamp to valid range for acos
                  waypoint_angle_deviation += std::acos(cos_theta); // Angle deviation in radians
              }
          }

          // Accumulate the total angle deviation
          total_angle_deviation += waypoint_angle_deviation;
      }

      // Return the total smoothness metric (lower is smoother)
      return total_angle_deviation;
  }
ground_truth.cpp: |-
  std::optional<double> smoothness(RobotTrajectory const& trajectory)
  {
    if (trajectory.getWayPointCount() > 2)
    {
      auto smoothness = 0.0;
      double a = trajectory.getWayPoint(0).distance(trajectory.getWayPoint(1));
      for (std::size_t k = 2; k < trajectory.getWayPointCount(); ++k)
      {
        // view the path as a sequence of segments, and look at the triangles it forms:
        //          s1
        //          /\          s4
        //      a  /  \ b       |
        //        /    \        |
        //       /......\_______|
        //     s0    c   s2     s3

        // use Pythagoras generalized theorem to find the cos of the angle between segments a and b
        double b = trajectory.getWayPoint(k - 1).distance(trajectory.getWayPoint(k));
        double cdist = trajectory.getWayPoint(k - 2).distance(trajectory.getWayPoint(k));
        double acos_value = (a * a + b * b - cdist * cdist) / (2.0 * a * b);
        if (acos_value > -1.0 && acos_value < 1.0)
        {
          // the smoothness is actually the outside angle of the one we compute
          double angle = (M_PI - acos(acos_value));

          // and we normalize by the length of the segments
          double u = 2.0 * angle;  /// (a + b);
          smoothness += u * u;
        }
        a = b;
      }
      smoothness /= (double)trajectory.getWayPointCount();
      return smoothness;
    }
    // In case the path is to short, no value is returned
    return std::nullopt;
  }
