compilation.log: |
  Starting >>> nav2_costmap_2d
  --- stderr: nav2_costmap_2d
  /root/repos/nav_ws/src/nav2_costmap_2d/src/footprint_collision_checker.cpp: In member function ‘double nav2_costmap_2d::FootprintCollisionChecker<CostmapT>::footprintCostAtPose(double, double, double, nav2_costmap_2d::Footprint)’:
  /root/repos/nav_ws/src/nav2_costmap_2d/src/footprint_collision_checker.cpp:137:36: error: no matching function for call to ‘std::vector<geometry_msgs::msg::Point_<std::allocator<void> > >::push_back(<brace-enclosed initializer list>)’
    137 |     transformed_footprint.push_back({transformed_x, transformed_y});
        |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  In file included from /usr/include/c++/11/vector:67,
                   from /root/repos/nav_ws/src/nav2_costmap_2d/src/footprint_collision_checker.cpp:19:
  /usr/include/c++/11/bits/stl_vector.h:1187:7: note: candidate: ‘void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = geometry_msgs::msg::Point_<std::allocator<void> >; _Alloc = std::allocator<geometry_msgs::msg::Point_<std::allocator<void> > >; std::vector<_Tp, _Alloc>::value_type = geometry_msgs::msg::Point_<std::allocator<void> >]’
   1187 |       push_back(const value_type& __x)
        |       ^~~~~~~~~
  /usr/include/c++/11/bits/stl_vector.h:1187:35: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘const value_type&’ {aka ‘const geometry_msgs::msg::Point_<std::allocator<void> >&’}
   1187 |       push_back(const value_type& __x)
        |                 ~~~~~~~~~~~~~~~~~~^~~
  /usr/include/c++/11/bits/stl_vector.h:1203:7: note: candidate: ‘void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = geometry_msgs::msg::Point_<std::allocator<void> >; _Alloc = std::allocator<geometry_msgs::msg::Point_<std::allocator<void> > >; std::vector<_Tp, _Alloc>::value_type = geometry_msgs::msg::Point_<std::allocator<void> >]’
   1203 |       push_back(value_type&& __x)
        |       ^~~~~~~~~
  /usr/include/c++/11/bits/stl_vector.h:1203:30: note:   no known conversion for argument 1 from ‘<brace-enclosed initializer list>’ to ‘std::vector<geometry_msgs::msg::Point_<std::allocator<void> > >::value_type&&’ {aka ‘geometry_msgs::msg::Point_<std::allocator<void> >&&’}
   1203 |       push_back(value_type&& __x)
        |                 ~~~~~~~~~~~~~^~~
  gmake[2]: *** [CMakeFiles/nav2_costmap_2d_core.dir/build.make:230: CMakeFiles/nav2_costmap_2d_core.dir/src/footprint_collision_checker.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:269: CMakeFiles/nav2_costmap_2d_core.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< nav2_costmap_2d [2.69s, exited with code 2]

  Summary: 0 packages finished [2.96s]
    1 package failed: nav2_costmap_2d
    1 package had stderr output: nav2_costmap_2d
generate_code.cpp: |-
  double FootprintCollisionChecker<CostmapT>::footprintCostAtPose(
    double x, double y, double theta, const Footprint footprint)
  {
    // Transform the footprint to the given pose
    Footprint transformed_footprint;
    for (const auto& point : footprint) {
      double transformed_x = x + point.x * cos(theta) - point.y * sin(theta);
      double transformed_y = y + point.x * sin(theta) + point.y * cos(theta);
      transformed_footprint.push_back({transformed_x, transformed_y});
    }

    // Calculate the cost of the transformed footprint using the footprintCost function
    return footprintCost(transformed_footprint);
  }
ground_truth.cpp: |-
  double FootprintCollisionChecker<CostmapT>::footprintCostAtPose(
    double x, double y, double theta, const Footprint footprint)
  {
    double cos_th = cos(theta);
    double sin_th = sin(theta);
    Footprint oriented_footprint;
    for (unsigned int i = 0; i < footprint.size(); ++i) {
      geometry_msgs::msg::Point new_pt;
      new_pt.x = x + (footprint[i].x * cos_th - footprint[i].y * sin_th);
      new_pt.y = y + (footprint[i].x * sin_th + footprint[i].y * cos_th);
      oriented_footprint.push_back(new_pt);
    }

    return footprintCost(oriented_footprint);
  }
