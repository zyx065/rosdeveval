compilation.log: |
  Starting >>> nav2_rotation_shim_controller
  --- stderr: nav2_rotation_shim_controller
  /root/repos/nav_ws/src/nav2_rotation_shim_controller/src/nav2_rotation_shim_controller.cpp: In member function ‘virtual void nav2_rotation_shim_controller::RotationShimController::configure(const WeakPtr&, std::string, std::shared_ptr<tf2_ros::Buffer>, std::shared_ptr<nav2_costmap_2d::Costmap2DROS>)’:
  /root/repos/nav_ws/src/nav2_rotation_shim_controller/src/nav2_rotation_shim_controller.cpp:99:37: error: no matching function for call to ‘nav2_controller::PositionGoalChecker::initialize(rclcpp_lifecycle::LifecycleNode::WeakPtr&, std::string&)’
     99 |   position_goal_checker_->initialize(node_, plugin_name_);
        |   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~
  In file included from /root/repos/nav_ws/src/nav2_rotation_shim_controller/include/nav2_rotation_shim_controller/nav2_rotation_shim_controller.hpp:34,
                   from /root/repos/nav_ws/src/nav2_rotation_shim_controller/src/nav2_rotation_shim_controller.cpp:22:
  /root/repos/nav_ws/install/nav2_controller/include/nav2_controller/plugins/position_goal_checker.hpp:39:8: note: candidate: ‘virtual void nav2_controller::PositionGoalChecker::initialize(const WeakPtr&, const string&, std::shared_ptr<nav2_costmap_2d::Costmap2DROS>)’
     39 |   void initialize(
        |        ^~~~~~~~~~
  /root/repos/nav_ws/install/nav2_controller/include/nav2_controller/plugins/position_goal_checker.hpp:39:8: note:   candidate expects 3 arguments, 2 provided
  gmake[2]: *** [CMakeFiles/nav2_rotation_shim_controller.dir/build.make:76: CMakeFiles/nav2_rotation_shim_controller.dir/src/nav2_rotation_shim_controller.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:172: CMakeFiles/nav2_rotation_shim_controller.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< nav2_rotation_shim_controller [3.91s, exited with code 2]

  Summary: 0 packages finished [4.22s]
    1 package failed: nav2_rotation_shim_controller
    1 package had stderr output: nav2_rotation_shim_controller
generate_code.cpp: |-
  void RotationShimController::configure(
    const rclcpp_lifecycle::LifecycleNode::WeakPtr & parent,
    std::string name, std::shared_ptr<tf2_ros::Buffer> tf,
    std::shared_ptr<nav2_costmap_2d::Costmap2DROS> costmap_ros)
  {
    // Store the parent node and plugin name
    node_ = parent;
    plugin_name_ = name;
    tf_ = tf;
    costmap_ros_ = costmap_ros;

    // Lock the parent node to access its parameters and interfaces
    auto node = node_.lock();
    if (!node) {
      throw std::runtime_error("Failed to lock parent node in RotationShimController::configure");
    }

    // Initialize logger and clock
    logger_ = node->get_logger();
    clock_ = node->get_clock();

    // Load parameters
    node->declare_parameter(plugin_name_ + ".forward_sampling_distance", 0.5);
    node->declare_parameter(plugin_name_ + ".angular_dist_threshold", 0.1);
    node->declare_parameter(plugin_name_ + ".angular_disengage_threshold", 0.05);
    node->declare_parameter(plugin_name_ + ".rotate_to_heading_angular_vel", 0.5);
    node->declare_parameter(plugin_name_ + ".max_angular_accel", 1.0);
    node->declare_parameter(plugin_name_ + ".control_duration", 0.1);
    node->declare_parameter(plugin_name_ + ".simulate_ahead_time", 2.0);
    node->declare_parameter(plugin_name_ + ".rotate_to_goal_heading", true);
    node->declare_parameter(plugin_name_ + ".closed_loop", true);

    node->get_parameter(plugin_name_ + ".forward_sampling_distance", forward_sampling_distance_);
    node->get_parameter(plugin_name_ + ".angular_dist_threshold", angular_dist_threshold_);
    node->get_parameter(plugin_name_ + ".angular_disengage_threshold", angular_disengage_threshold_);
    node->get_parameter(plugin_name_ + ".rotate_to_heading_angular_vel", rotate_to_heading_angular_vel_);
    node->get_parameter(plugin_name_ + ".max_angular_accel", max_angular_accel_);
    node->get_parameter(plugin_name_ + ".control_duration", control_duration_);
    node->get_parameter(plugin_name_ + ".simulate_ahead_time", simulate_ahead_time_);
    node->get_parameter(plugin_name_ + ".rotate_to_goal_heading", rotate_to_goal_heading_);
    node->get_parameter(plugin_name_ + ".closed_loop", closed_loop_);

    // Initialize collision checker
    collision_checker_ = std::make_unique<nav2_costmap_2d::FootprintCollisionChecker<nav2_costmap_2d::Costmap2D *>>(
      costmap_ros_->getCostmap());

    // Load the primary controller plugin
    lp_loader_ = pluginlib::ClassLoader<nav2_core::Controller>("nav2_core", "nav2_core::Controller");
    std::string primary_controller_name;
    node->declare_parameter(plugin_name_ + ".primary_controller", "DWBLocalPlanner");
    node->get_parameter(plugin_name_ + ".primary_controller", primary_controller_name);

    try {
      primary_controller_ = lp_loader_.createUniqueInstance(primary_controller_name);
      primary_controller_->configure(node_, plugin_name_, tf_, costmap_ros_);
    } catch (const pluginlib::PluginlibException & ex) {
      RCLCPP_FATAL(logger_, "Failed to load primary controller plugin. Exception: %s", ex.what());
      throw std::runtime_error("Failed to load primary controller plugin");
    }

    // Initialize position goal checker
    position_goal_checker_ = std::make_unique<nav2_controller::PositionGoalChecker>();
    position_goal_checker_->initialize(node_, plugin_name_);

    // Dynamic parameters callback
    dyn_params_handler_ = node->add_on_set_parameters_callback(
      std::bind(&RotationShimController::dynamicParametersCallback, this, std::placeholders::_1));

    // Initialize state variables
    path_updated_ = false;
    in_rotation_ = false;

    RCLCPP_INFO(logger_, "RotationShimController configured successfully");
  }
ground_truth.cpp: |-
  void RotationShimController::configure(
    const rclcpp_lifecycle::LifecycleNode::WeakPtr & parent,
    std::string name, std::shared_ptr<tf2_ros::Buffer> tf,
    std::shared_ptr<nav2_costmap_2d::Costmap2DROS> costmap_ros)
  {
    position_goal_checker_ = std::make_unique<nav2_controller::PositionGoalChecker>();
    position_goal_checker_->initialize(parent, plugin_name_ + ".position_checker", costmap_ros);
    plugin_name_ = name;
    node_ = parent;
    auto node = parent.lock();

    tf_ = tf;
    costmap_ros_ = costmap_ros;
    logger_ = node->get_logger();
    clock_ = node->get_clock();

    std::string primary_controller;
    double control_frequency;
    nav2_util::declare_parameter_if_not_declared(
      node, plugin_name_ + ".angular_dist_threshold", rclcpp::ParameterValue(0.785));  // 45 deg
    nav2_util::declare_parameter_if_not_declared(
      node, plugin_name_ + ".angular_disengage_threshold", rclcpp::ParameterValue(0.785));
    nav2_util::declare_parameter_if_not_declared(
      node, plugin_name_ + ".forward_sampling_distance", rclcpp::ParameterValue(0.5));
    nav2_util::declare_parameter_if_not_declared(
      node, plugin_name_ + ".rotate_to_heading_angular_vel", rclcpp::ParameterValue(1.8));
    nav2_util::declare_parameter_if_not_declared(
      node, plugin_name_ + ".max_angular_accel", rclcpp::ParameterValue(3.2));
    nav2_util::declare_parameter_if_not_declared(
      node, plugin_name_ + ".simulate_ahead_time", rclcpp::ParameterValue(1.0));
    nav2_util::declare_parameter_if_not_declared(
      node, plugin_name_ + ".primary_controller", rclcpp::PARAMETER_STRING);
    nav2_util::declare_parameter_if_not_declared(
      node, plugin_name_ + ".rotate_to_goal_heading", rclcpp::ParameterValue(false));
    nav2_util::declare_parameter_if_not_declared(
      node, plugin_name_ + ".closed_loop", rclcpp::ParameterValue(true));

    node->get_parameter(plugin_name_ + ".angular_dist_threshold", angular_dist_threshold_);
    node->get_parameter(plugin_name_ + ".angular_disengage_threshold", angular_disengage_threshold_);
    node->get_parameter(plugin_name_ + ".forward_sampling_distance", forward_sampling_distance_);
    node->get_parameter(
      plugin_name_ + ".rotate_to_heading_angular_vel",
      rotate_to_heading_angular_vel_);
    node->get_parameter(plugin_name_ + ".max_angular_accel", max_angular_accel_);
    node->get_parameter(plugin_name_ + ".simulate_ahead_time", simulate_ahead_time_);

    primary_controller = node->get_parameter(plugin_name_ + ".primary_controller").as_string();
    node->get_parameter("controller_frequency", control_frequency);
    control_duration_ = 1.0 / control_frequency;

    node->get_parameter(plugin_name_ + ".rotate_to_goal_heading", rotate_to_goal_heading_);
    node->get_parameter(plugin_name_ + ".closed_loop", closed_loop_);

    try {
      primary_controller_ = lp_loader_.createUniqueInstance(primary_controller);
      RCLCPP_INFO(
        logger_, "Created internal controller for rotation shimming: %s of type %s",
        plugin_name_.c_str(), primary_controller.c_str());
    } catch (const pluginlib::PluginlibException & ex) {
      RCLCPP_FATAL(
        logger_,
        "Failed to create internal controller for rotation shimming. Exception: %s", ex.what());
      return;
    }

    primary_controller_->configure(parent, name, tf, costmap_ros);

    // initialize collision checker and set costmap
    collision_checker_ = std::make_unique<nav2_costmap_2d::
        FootprintCollisionChecker<nav2_costmap_2d::Costmap2D *>>(costmap_ros->getCostmap());
  }
