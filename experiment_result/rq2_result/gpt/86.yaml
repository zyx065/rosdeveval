compilation.log: |
  Starting >>> autoware_obstacle_collision_checker
  --- stderr: autoware_obstacle_collision_checker
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_obstacle_collision_checker/src/obstacle_collision_checker.cpp: In function ‘autoware::obstacle_collision_checker::Output autoware::obstacle_collision_checker::check_for_collisions(const autoware::obstacle_collision_checker::Input&)’:
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_obstacle_collision_checker/src/obstacle_collision_checker.cpp:88:61: error: ‘const struct autoware::obstacle_collision_checker::Input’ has no member named ‘trajectory’
     88 |     output.resampled_trajectory = resample_trajectory(input.trajectory, resample_interval);
        |                                                             ^~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_obstacle_collision_checker/src/obstacle_collision_checker.cpp:114:15: error: ‘const struct autoware::obstacle_collision_checker::Input’ has no member named ‘pointcloud_msg’
    114 |         input.pointcloud_msg, input.transform);
        |               ^~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_obstacle_collision_checker/src/obstacle_collision_checker.cpp:114:37: error: ‘const struct autoware::obstacle_collision_checker::Input’ has no member named ‘transform’
    114 |         input.pointcloud_msg, input.transform);
        |                                     ^~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_obstacle_collision_checker/src/obstacle_collision_checker.cpp: At global scope:
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_obstacle_collision_checker/src/obstacle_collision_checker.cpp:67:8: error: ‘double {anonymous}::calc_braking_distance(double, double, double)’ defined but not used [-Werror=unused-function]
     67 | double calc_braking_distance(
        |        ^~~~~~~~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_obstacle_collision_checker/src/obstacle_collision_checker.cpp:34:32: error: ‘pcl::PointCloud<pcl::PointXYZ> {anonymous}::get_transformed_point_cloud(const PointCloud2&, const Transform&)’ defined but not used [-Werror=unused-function]
     34 | pcl::PointCloud<pcl::PointXYZ> get_transformed_point_cloud(
        |                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~
  cc1plus: all warnings being treated as errors
  gmake[2]: *** [CMakeFiles/obstacle_collision_checker.dir/build.make:90: CMakeFiles/obstacle_collision_checker.dir/src/obstacle_collision_checker.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:159: CMakeFiles/obstacle_collision_checker.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_obstacle_collision_checker [8.72s, exited with code 2]

  Summary: 0 packages finished [10.1s]
    1 package failed: autoware_obstacle_collision_checker
    1 package had stderr output: autoware_obstacle_collision_checker
generate_code.cpp: "Output check_for_collisions(const Input & input)\n{\n    Output\
  \ output;\n\n    // Start timing for processing time measurement\n    auto start_time\
  \ = std::chrono::steady_clock::now();\n\n    // Step 1: Resample the trajectory\n\
  \    const double resample_interval = 1.0; // Example interval, adjust as needed\n\
  \    output.resampled_trajectory = resample_trajectory(input.trajectory, resample_interval);\n\
  \n    // Record processing time for trajectory resampling\n    auto resample_end_time\
  \ = std::chrono::steady_clock::now();\n    output.processing_time_map[\"resample_trajectory\"\
  ] = \n        std::chrono::duration_cast<std::chrono::milliseconds>(resample_end_time\
  \ - start_time).count();\n\n    // Step 2: Create vehicle footprints\n    output.vehicle_footprints\
  \ = create_vehicle_footprints(\n        output.resampled_trajectory, input.param,\
  \ input.vehicle_info);\n\n    // Record processing time for creating vehicle footprints\n\
  \    auto footprints_end_time = std::chrono::steady_clock::now();\n    output.processing_time_map[\"\
  create_vehicle_footprints\"] = \n        std::chrono::duration_cast<std::chrono::milliseconds>(footprints_end_time\
  \ - resample_end_time).count();\n\n    // Step 3: Create vehicle passing areas\n\
  \    output.vehicle_passing_areas = create_vehicle_passing_areas(output.vehicle_footprints);\n\
  \n    // Record processing time for creating vehicle passing areas\n    auto passing_areas_end_time\
  \ = std::chrono::steady_clock::now();\n    output.processing_time_map[\"create_vehicle_passing_areas\"\
  ] = \n        std::chrono::duration_cast<std::chrono::milliseconds>(passing_areas_end_time\
  \ - footprints_end_time).count();\n\n    // Step 4: Transform the input point cloud\
  \ to the required frame\n    pcl::PointCloud<pcl::PointXYZ> transformed_pointcloud\
  \ = get_transformed_point_cloud(\n        input.pointcloud_msg, input.transform);\n\
  \n    // Record processing time for point cloud transformation\n    auto transform_end_time\
  \ = std::chrono::steady_clock::now();\n    output.processing_time_map[\"get_transformed_point_cloud\"\
  ] = \n        std::chrono::duration_cast<std::chrono::milliseconds>(transform_end_time\
  \ - passing_areas_end_time).count();\n\n    // Step 5: Filter the point cloud based\
  \ on the trajectory\n    const double filter_radius = 5.0; // Example radius, adjust\
  \ as needed\n    pcl::PointCloud<pcl::PointXYZ> filtered_pointcloud = filter_point_cloud_by_trajectory(\n\
  \        transformed_pointcloud, output.resampled_trajectory, filter_radius);\n\n\
  \    // Record processing time for point cloud filtering\n    auto filter_end_time\
  \ = std::chrono::steady_clock::now();\n    output.processing_time_map[\"filter_point_cloud_by_trajectory\"\
  ] = \n        std::chrono::duration_cast<std::chrono::milliseconds>(filter_end_time\
  \ - transform_end_time).count();\n\n    // Step 6: Check for collisions\n    output.will_collide\
  \ = will_collide(filtered_pointcloud, output.vehicle_footprints);\n\n    // Record\
  \ processing time for collision checking\n    auto collision_check_end_time = std::chrono::steady_clock::now();\n\
  \    output.processing_time_map[\"will_collide\"] = \n        std::chrono::duration_cast<std::chrono::milliseconds>(collision_check_end_time\
  \ - filter_end_time).count();\n\n    // Return the output\n    return output;\n}"
ground_truth.cpp: |-
  Output check_for_collisions(const Input & input)
  {
    Output output;
    autoware::universe_utils::StopWatch<std::chrono::milliseconds> stop_watch;

    // resample trajectory by braking distance
    constexpr double min_velocity = 0.01;
    const auto & raw_abs_velocity = std::abs(input.current_twist->linear.x);
    const auto abs_velocity = raw_abs_velocity < min_velocity ? 0.0 : raw_abs_velocity;
    const auto braking_distance =
      calc_braking_distance(abs_velocity, input.param.max_deceleration, input.param.delay_time);
    output.resampled_trajectory = cut_trajectory(
      resample_trajectory(*input.predicted_trajectory, input.param.resample_interval),
      braking_distance);
    output.processing_time_map["resampleTrajectory"] = stop_watch.toc(true);

    // resample pointcloud
    const auto obstacle_pointcloud =
      get_transformed_point_cloud(*input.obstacle_pointcloud, input.obstacle_transform->transform);
    const auto filtered_obstacle_pointcloud = filter_point_cloud_by_trajectory(
      obstacle_pointcloud, output.resampled_trajectory, input.param.search_radius);

    output.vehicle_footprints =
      create_vehicle_footprints(output.resampled_trajectory, input.param, input.vehicle_info);
    output.processing_time_map["createVehicleFootprints"] = stop_watch.toc(true);

    output.vehicle_passing_areas = create_vehicle_passing_areas(output.vehicle_footprints);
    output.processing_time_map["createVehiclePassingAreas"] = stop_watch.toc(true);

    output.will_collide = will_collide(filtered_obstacle_pointcloud, output.vehicle_passing_areas);
    output.processing_time_map["willCollide"] = stop_watch.toc(true);

    return output;
  }
