compilation.log: |
  Starting >>> autoware_pointcloud_preprocessor
  --- stderr: autoware_pointcloud_preprocessor
  /workspace/repos/autoware/src/universe/autoware.universe/sensing/autoware_pointcloud_preprocessor/src/utility/geometry.cpp: In function ‘void autoware::pointcloud_preprocessor::utils::remove_polygon_cgal_from_cloud(const PointCloud2&, const PolygonCgal&, sensor_msgs::msg::PointCloud2&, const std::optional<float>&)’:
  /workspace/repos/autoware/src/universe/autoware.universe/sensing/autoware_pointcloud_preprocessor/src/utility/geometry.cpp:56:50: error: binding reference of type ‘sensor_msgs::msg::PointCloud2&’ {aka ‘sensor_msgs::msg::PointCloud2_<std::allocator<void> >&’} to ‘const PointCloud2’ {aka ‘const sensor_msgs::msg::PointCloud2_<std::allocator<void> >’} discards qualifiers
     56 |   sensor_msgs::PointCloud2Iterator<float> iter_x(cloud_in, "x");
        |                                                  ^~~~~~~~
  In file included from /workspace/repos/autoware/src/universe/autoware.universe/sensing/autoware_pointcloud_preprocessor/include/autoware/pointcloud_preprocessor/utility/geometry.hpp:20,
                   from /workspace/repos/autoware/src/universe/autoware.universe/sensing/autoware_pointcloud_preprocessor/src/utility/geometry.cpp:15:
  /opt/ros/humble/include/sensor_msgs/sensor_msgs/point_cloud2_iterator.hpp:293:37: note:   initializing argument 1 of ‘sensor_msgs::PointCloud2Iterator<T>::PointCloud2Iterator(sensor_msgs::msg::PointCloud2&, const string&) [with T = float; sensor_msgs::msg::PointCloud2 = sensor_msgs::msg::PointCloud2_<std::allocator<void> >; std::string = std::__cxx11::basic_string<char>]’
    293 |     sensor_msgs::msg::PointCloud2 & cloud_msg,
        |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/sensing/autoware_pointcloud_preprocessor/src/utility/geometry.cpp:57:50: error: binding reference of type ‘sensor_msgs::msg::PointCloud2&’ {aka ‘sensor_msgs::msg::PointCloud2_<std::allocator<void> >&’} to ‘const PointCloud2’ {aka ‘const sensor_msgs::msg::PointCloud2_<std::allocator<void> >’} discards qualifiers
     57 |   sensor_msgs::PointCloud2Iterator<float> iter_y(cloud_in, "y");
        |                                                  ^~~~~~~~
  In file included from /workspace/repos/autoware/src/universe/autoware.universe/sensing/autoware_pointcloud_preprocessor/include/autoware/pointcloud_preprocessor/utility/geometry.hpp:20,
                   from /workspace/repos/autoware/src/universe/autoware.universe/sensing/autoware_pointcloud_preprocessor/src/utility/geometry.cpp:15:
  /opt/ros/humble/include/sensor_msgs/sensor_msgs/point_cloud2_iterator.hpp:293:37: note:   initializing argument 1 of ‘sensor_msgs::PointCloud2Iterator<T>::PointCloud2Iterator(sensor_msgs::msg::PointCloud2&, const string&) [with T = float; sensor_msgs::msg::PointCloud2 = sensor_msgs::msg::PointCloud2_<std::allocator<void> >; std::string = std::__cxx11::basic_string<char>]’
    293 |     sensor_msgs::msg::PointCloud2 & cloud_msg,
        |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/sensing/autoware_pointcloud_preprocessor/src/utility/geometry.cpp:58:50: error: binding reference of type ‘sensor_msgs::msg::PointCloud2&’ {aka ‘sensor_msgs::msg::PointCloud2_<std::allocator<void> >&’} to ‘const PointCloud2’ {aka ‘const sensor_msgs::msg::PointCloud2_<std::allocator<void> >’} discards qualifiers
     58 |   sensor_msgs::PointCloud2Iterator<float> iter_z(cloud_in, "z");
        |                                                  ^~~~~~~~
  In file included from /workspace/repos/autoware/src/universe/autoware.universe/sensing/autoware_pointcloud_preprocessor/include/autoware/pointcloud_preprocessor/utility/geometry.hpp:20,
                   from /workspace/repos/autoware/src/universe/autoware.universe/sensing/autoware_pointcloud_preprocessor/src/utility/geometry.cpp:15:
  /opt/ros/humble/include/sensor_msgs/sensor_msgs/point_cloud2_iterator.hpp:293:37: note:   initializing argument 1 of ‘sensor_msgs::PointCloud2Iterator<T>::PointCloud2Iterator(sensor_msgs::msg::PointCloud2&, const string&) [with T = float; sensor_msgs::msg::PointCloud2 = sensor_msgs::msg::PointCloud2_<std::allocator<void> >; std::string = std::__cxx11::basic_string<char>]’
    293 |     sensor_msgs::msg::PointCloud2 & cloud_msg,
        |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/sensing/autoware_pointcloud_preprocessor/src/utility/geometry.cpp:72:47: error: ‘const PolygonCgal’ {aka ‘const class std::vector<CGAL::Point_2<CGAL::Epick> >’} has no member named ‘has_on_bounded_side’
     72 |     bool is_inside_polygon = polyline_polygon.has_on_bounded_side(point);
        |                                               ^~~~~~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/sensing/autoware_pointcloud_preprocessor/src/utility/geometry.cpp:79:16: error: ‘class sensor_msgs::PointCloud2Modifier’ has no member named ‘addPoint’
     79 |       modifier.addPoint(x, y, z);
        |                ^~~~~~~~
  gmake[2]: *** [CMakeFiles/pointcloud_preprocessor_filter.dir/build.make:426: CMakeFiles/pointcloud_preprocessor_filter.dir/src/utility/geometry.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:258: CMakeFiles/pointcloud_preprocessor_filter.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_pointcloud_preprocessor [12.6s, exited with code 2]

  Summary: 0 packages finished [13.9s]
    1 package failed: autoware_pointcloud_preprocessor
    1 package had stderr output: autoware_pointcloud_preprocessor
generate_code.cpp: |-
  void remove_polygon_cgal_from_cloud(
    const sensor_msgs::msg::PointCloud2 & cloud_in, const PolygonCgal & polyline_polygon,
    sensor_msgs::msg::PointCloud2 & cloud_out, const std::optional<float> & max_z)
  {
    // Initialize the output cloud
    cloud_out = cloud_in;
    cloud_out.data.clear();

    // Extract the fields from the input cloud
    sensor_msgs::PointCloud2Iterator<float> iter_x(cloud_in, "x");
    sensor_msgs::PointCloud2Iterator<float> iter_y(cloud_in, "y");
    sensor_msgs::PointCloud2Iterator<float> iter_z(cloud_in, "z");

    // Prepare the output cloud fields
    sensor_msgs::PointCloud2Modifier modifier(cloud_out);
    modifier.setPointCloud2FieldsByString(1, "xyz");

    // Iterate through the input cloud points
    for (; iter_x != iter_x.end(); ++iter_x, ++iter_y, ++iter_z) {
      const float x = *iter_x;
      const float y = *iter_y;
      const float z = *iter_z;

      // Check if the point is inside the polygon
      PointCgal point(x, y);
      bool is_inside_polygon = polyline_polygon.has_on_bounded_side(point);

      // Check the Z threshold if max_z is provided
      bool is_below_max_z = max_z.has_value() && z <= max_z.value();

      // If the point is outside the polygon or above max_z, add it to the output cloud
      if (!is_inside_polygon || !is_below_max_z) {
        modifier.addPoint(x, y, z);
      }
    }
  }
ground_truth.cpp: |-
  void remove_polygon_cgal_from_cloud(
    const sensor_msgs::msg::PointCloud2 & cloud_in, const PolygonCgal & polyline_polygon,
    sensor_msgs::msg::PointCloud2 & cloud_out, const std::optional<float> & max_z)
  {
    pcl::PointCloud<pcl::PointXYZ> pcl_output;

    for (sensor_msgs::PointCloud2ConstIterator<float> iter_x(cloud_in, "x"), iter_y(cloud_in, "y"),
         iter_z(cloud_in, "z");
         iter_x != iter_x.end(); ++iter_x, ++iter_y, ++iter_z) {
      const bool within_max_z = max_z ? *iter_z <= *max_z : true;
      const bool within_polygon = CGAL::bounded_side_2(
                                    polyline_polygon.begin(), polyline_polygon.end(),
                                    PointCgal(*iter_x, *iter_y), K()) == CGAL::ON_BOUNDED_SIDE;
      // remove points within the polygon and max_z
      if (!(within_max_z && within_polygon)) {
        pcl::PointXYZ p;
        p.x = *iter_x;
        p.y = *iter_y;
        p.z = *iter_z;
        pcl_output.emplace_back(p);
      }
    }

    pcl::toROSMsg(pcl_output, cloud_out);
    cloud_out.header = cloud_in.header;
  }
