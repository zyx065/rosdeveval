compilation.log: |
  Starting >>> nav2_collision_monitor
  Finished <<< nav2_collision_monitor [0.47s]

  Summary: 1 package finished [0.75s]
generate_code.cpp: |-
  double Polygon::getCollisionTime(
    const std::vector<Point> & collision_points,
    const Velocity & velocity) const
  {
    // Check if the polygon is enabled
    if (!enabled_) {
      return -1.0;
    }

    // Initialize variables
    double time_elapsed = 0.0;
    Pose current_pose;  // Assume the current pose is initialized elsewhere
    Velocity current_velocity = velocity;

    // Simulate movement of the polygon over time
    while (time_elapsed <= time_before_collision_) {
      // Transform the collision points to the current pose
      std::vector<Point> transformed_points = collision_points;
      transformPoints(current_pose, transformed_points);

      // Check for collisions
      int points_inside = getPointsInside(transformed_points);
      if (points_inside > max_points_) {
        return time_elapsed;  // Collision detected
      }

      // Project the state forward in time
      projectState(simulation_time_step_, current_pose, current_velocity);

      // Increment the elapsed time
      time_elapsed += simulation_time_step_;
    }

    // No collision detected within the time horizon
    return -1.0;
  }
ground_truth.cpp: |-
  double Polygon::getCollisionTime(
    const std::vector<Point> & collision_points,
    const Velocity & velocity) const
  {
    // Initial robot pose is {0,0} in base_footprint coordinates
    Pose pose = {0.0, 0.0, 0.0};
    Velocity vel = velocity;

    // Array of points transformed to the frame concerned with pose on each simulation step
    std::vector<Point> points_transformed = collision_points;

    // Check static polygon
    if (getPointsInside(points_transformed) >= max_points_) {
      return 0.0;
    }

    // Robot movement simulation
    for (double time = 0.0; time <= time_before_collision_; time += simulation_time_step_) {
      // Shift the robot pose towards to the vel during simulation_time_step_ time interval
      // NOTE: vel is changing during the simulation
      projectState(simulation_time_step_, pose, vel);
      // Transform collision_points to the frame concerned with current robot pose
      points_transformed = collision_points;
      transformPoints(pose, points_transformed);
      // If the collision occurred on this stage, return the actual time before a collision
      // as if robot was moved with given velocity
      if (getPointsInside(points_transformed) > max_points_) {
        return time;
      }
    }

    // There is no collision
    return -1.0;
  }
