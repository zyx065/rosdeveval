repository: moveit2
language: C++
ros_package_file: moveit_planners/pilz_industrial_motion_planner
ros_package: pilz_industrial_motion_planner
file_path: src/trajectory_functions.cpp
method_name: pilz_industrial_motion_planner::isStateColliding
requirement: |
  /**
  * Calculates the derivative of the maximum path velocity with respect to path position.
  * 
  * @param path_pos The path position at which to evaluate the derivative.
  * @return The derivative of maximum path velocity with respect to path position.
  */
category: utilities
type: []
signature: |
  bool pilz_industrial_motion_planner::isStateColliding(const planning_scene::PlanningSceneConstPtr& scene,
                                                        moveit::core::RobotState* rstate,
                                                        const moveit::core::JointModelGroup* const group,
                                                        const double* const ik_solution)

additional_information: 
  function_related_variable:
    Path path_;
    unsigned int joint_num_;
    Eigen::VectorXd max_velocity_;
  function_related_function: |
    void planning_scene::PlanningScene::checkSelfCollision(const collision_detection::CollisionRequest& req, collision_detection::CollisionResult& res)
    void RobotState::setJointGroupPositions(const JointModelGroup* group, const double* gstate)
  function_related_class: |
    struct CollisionResult
    {
      EIGEN_MAKE_ALIGNED_OPERATOR_NEW

      /** \brief Clear a previously stored result */
      void clear()
      {
        collision = false;
        distance = std::numeric_limits<double>::max();
        distance_result.clear();
        contact_count = 0;
        contacts.clear();
        cost_sources.clear();
      }

      /** \brief Throttled warning printing the first collision pair, if any. All collisions are logged at DEBUG level */
      void print() const;

      /** \brief True if collision was found, false otherwise */
      bool collision = false;

      /** \brief Closest distance between two bodies */
      double distance = std::numeric_limits<double>::max();

      /** \brief Distance data for each link */
      DistanceResult distance_result;

      /** \brief Number of contacts returned */
      std::size_t contact_count = 0;

      /** \brief A map returning the pairs of body ids in contact, plus their contact details */
      using ContactMap = std::map<std::pair<std::string, std::string>, std::vector<Contact> >;
      ContactMap contacts;

      /** \brief These are the individual cost sources when costs are computed */
      std::set<CostSource> cost_sources;
    };

    /** \brief Representation of a collision checking request */
    struct CollisionRequest
    {
      CollisionRequest()
        : distance(false)
        , cost(false)
        , contacts(false)
        , max_contacts(1)
        , max_contacts_per_pair(1)
        , max_cost_sources(1)
        , verbose(false)
      {
      }
      virtual ~CollisionRequest()
      {
      }

      /** \brief The group name to check collisions for (optional; if empty, assume the complete robot) */
      std::string group_name;

      /** \brief If true, compute proximity distance */
      bool distance;

      /** \brief If true, return detailed distance information. Distance must be set to true as well */
      bool detailed_distance = false;

      /** \brief If true, a collision cost is computed */
      bool cost;

      /** \brief If true, compute contacts. Otherwise only a binary collision yes/no is reported. */
      bool contacts;

      /** \brief Overall maximum number of contacts to compute */
      std::size_t max_contacts;

      /** \brief Maximum number of contacts to compute per pair of bodies (multiple bodies may be in contact at different
      * configurations) */
      std::size_t max_contacts_per_pair;

      /** \brief When costs are computed, this value defines how many of the top cost sources should be returned */
      std::size_t max_cost_sources;

      /** \brief Function call that decides whether collision detection should stop. */
      std::function<bool(const CollisionResult&)> is_done;

      /** \brief Flag indicating whether information about detected collisions should be reported */
      bool verbose;
    };
test: test_planning_scene
test_cases: 
- isStateValid
- switchCollisionDetectorType