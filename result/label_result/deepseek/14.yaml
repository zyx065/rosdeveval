compilation.log: |
  Starting >>> autoware_detected_object_validation
  [Processing: autoware_detected_object_validation]
  Finished <<< autoware_detected_object_validation [40.1s]

  Summary: 1 package finished [41.6s]
generate_code.cpp: "ObjectLaneletFilterNode::ObjectLaneletFilterNode(const rclcpp::NodeOptions\
  \ & node_options)\n: Node(\"object_lanelet_filter_node\", node_options),\n  tf_buffer_(this->get_clock()),\n\
  \  tf_listener_(tf_buffer_)\n{\n  // Initialize parameters\n  filter_target_.UNKNOWN\
  \ = declare_parameter<bool>(\"filter_target.UNKNOWN\", true);\n  filter_target_.CAR\
  \ = declare_parameter<bool>(\"filter_target.CAR\", true);\n  filter_target_.TRUCK\
  \ = declare_parameter<bool>(\"filter_target.TRUCK\", true);\n  filter_target_.BUS\
  \ = declare_parameter<bool>(\"filter_target.BUS\", true);\n  filter_target_.TRAILER\
  \ = declare_parameter<bool>(\"filter_target.TRAILER\", true);\n  filter_target_.MOTORCYCLE\
  \ = declare_parameter<bool>(\"filter_target.MOTORCYCLE\", true);\n  filter_target_.BICYCLE\
  \ = declare_parameter<bool>(\"filter_target.BICYCLE\", true);\n  filter_target_.PEDESTRIAN\
  \ = declare_parameter<bool>(\"filter_target.PEDESTRIAN\", true);\n\n  filter_settings_.polygon_overlap_filter\
  \ = declare_parameter<bool>(\"filter_settings.polygon_overlap_filter\", true);\n\
  \  filter_settings_.lanelet_direction_filter = declare_parameter<bool>(\"filter_settings.lanelet_direction_filter\"\
  , true);\n  filter_settings_.lanelet_direction_filter_velocity_yaw_threshold = declare_parameter<double>(\"\
  filter_settings.lanelet_direction_filter_velocity_yaw_threshold\", M_PI_4);\n  filter_settings_.lanelet_direction_filter_object_speed_threshold\
  \ = declare_parameter<double>(\"filter_settings.lanelet_direction_filter_object_speed_threshold\"\
  , 1.0);\n  filter_settings_.debug = declare_parameter<bool>(\"filter_settings.debug\"\
  , false);\n  filter_settings_.lanelet_extra_margin = declare_parameter<double>(\"\
  filter_settings.lanelet_extra_margin\", 0.0);\n  filter_settings_.use_height_threshold\
  \ = declare_parameter<bool>(\"filter_settings.use_height_threshold\", false);\n\
  \  filter_settings_.max_height_threshold = declare_parameter<double>(\"filter_settings.max_height_threshold\"\
  , std::numeric_limits<double>::infinity());\n  filter_settings_.min_height_threshold\
  \ = declare_parameter<double>(\"filter_settings.min_height_threshold\", -std::numeric_limits<double>::infinity());\n\
  \n  // Initialize publishers and subscribers\n  map_sub_ = create_subscription<autoware_map_msgs::msg::LaneletMapBin>(\n\
  \    \"input/lanelet_map\", rclcpp::QoS{1}.transient_local(),\n    std::bind(&ObjectLaneletFilterNode::mapCallback,\
  \ this, std::placeholders::_1));\n  \n  object_sub_ = create_subscription<autoware_perception_msgs::msg::DetectedObjects>(\n\
  \    \"input/objects\", rclcpp::QoS{1},\n    std::bind(&ObjectLaneletFilterNode::objectCallback,\
  \ this, std::placeholders::_1));\n\n  object_pub_ = create_publisher<autoware_perception_msgs::msg::DetectedObjects>(\n\
  \    \"output/objects\", rclcpp::QoS{1});\n\n  if (filter_settings_.debug) {\n \
  \   debug_publisher_ = std::make_unique<autoware::universe_utils::DebugPublisher>(this,\
  \ \"object_lanelet_filter\");\n    stop_watch_ptr_ = std::make_unique<autoware::universe_utils::StopWatch<std::chrono::milliseconds>>();\n\
  \    stop_watch_ptr_->tic(\"cyclic_time\");\n    stop_watch_ptr_->tic(\"processing_time\"\
  );\n    published_time_publisher_ = std::make_unique<autoware::universe_utils::PublishedTimePublisher>(this);\n\
  \    viz_pub_ = create_publisher<visualization_msgs::msg::MarkerArray>(\"debug/markers\"\
  , 1);\n  }\n}"
ground_truth.cpp: |-
  ObjectLaneletFilterNode::ObjectLaneletFilterNode(const rclcpp::NodeOptions & node_options)
  : Node("object_lanelet_filter_node", node_options),
    tf_buffer_(this->get_clock()),
    tf_listener_(tf_buffer_)
  {
    using std::placeholders::_1;

    // Set parameters
    filter_target_.UNKNOWN = declare_parameter<bool>("filter_target_label.UNKNOWN");
    filter_target_.CAR = declare_parameter<bool>("filter_target_label.CAR");
    filter_target_.TRUCK = declare_parameter<bool>("filter_target_label.TRUCK");
    filter_target_.BUS = declare_parameter<bool>("filter_target_label.BUS");
    filter_target_.TRAILER = declare_parameter<bool>("filter_target_label.TRAILER");
    filter_target_.MOTORCYCLE = declare_parameter<bool>("filter_target_label.MOTORCYCLE");
    filter_target_.BICYCLE = declare_parameter<bool>("filter_target_label.BICYCLE");
    filter_target_.PEDESTRIAN = declare_parameter<bool>("filter_target_label.PEDESTRIAN");
    // Set filter settings
    filter_settings_.polygon_overlap_filter =
      declare_parameter<bool>("filter_settings.polygon_overlap_filter.enabled");
    filter_settings_.lanelet_direction_filter =
      declare_parameter<bool>("filter_settings.lanelet_direction_filter.enabled");
    filter_settings_.lanelet_direction_filter_velocity_yaw_threshold =
      declare_parameter<double>("filter_settings.lanelet_direction_filter.velocity_yaw_threshold");
    filter_settings_.lanelet_direction_filter_object_speed_threshold =
      declare_parameter<double>("filter_settings.lanelet_direction_filter.object_speed_threshold");
    filter_settings_.debug = declare_parameter<bool>("filter_settings.debug");
    filter_settings_.lanelet_extra_margin =
      declare_parameter<double>("filter_settings.lanelet_extra_margin");
    filter_settings_.use_height_threshold =
      declare_parameter<bool>("filter_settings.use_height_threshold");
    filter_settings_.max_height_threshold =
      declare_parameter<double>("filter_settings.max_height_threshold");
    filter_settings_.min_height_threshold =
      declare_parameter<double>("filter_settings.min_height_threshold");

    // Set publisher/subscriber
    map_sub_ = this->create_subscription<autoware_map_msgs::msg::LaneletMapBin>(
      "input/vector_map", rclcpp::QoS{1}.transient_local(),
      std::bind(&ObjectLaneletFilterNode::mapCallback, this, _1));
    object_sub_ = this->create_subscription<autoware_perception_msgs::msg::DetectedObjects>(
      "input/object", rclcpp::QoS{1}, std::bind(&ObjectLaneletFilterNode::objectCallback, this, _1));
    object_pub_ = this->create_publisher<autoware_perception_msgs::msg::DetectedObjects>(
      "output/object", rclcpp::QoS{1});

    debug_publisher_ =
      std::make_unique<autoware::universe_utils::DebugPublisher>(this, "object_lanelet_filter");
    published_time_publisher_ =
      std::make_unique<autoware::universe_utils::PublishedTimePublisher>(this);
    stop_watch_ptr_ =
      std::make_unique<autoware::universe_utils::StopWatch<std::chrono::milliseconds>>();
    if (filter_settings_.debug) {
      viz_pub_ = this->create_publisher<visualization_msgs::msg::MarkerArray>(
        "~/debug/marker", rclcpp::QoS{1});
    }
  }
architecture-codes:
  - ROS Parameter Issue - Use Non-existent Parameter Issue
  - ROS Parameter Issue - Insufficient Parameter Design Issue
  - ROS Parameter Issue - Naming Convention Violations Issue
  - Topic/Service Issue - Topic/Service Name Mismatch Issue

functionality-codes:
  - Condition Issue - Condition Check Logic Misapplication Issue
  - Incomplete Code Issue - Missing Multiple Steps Issue

root-cause-codes:
  - Solving Robotic Tasks Issue - Inadequate Understanding of System Requirements
  - Framework Integration Issue - Lack of ROS development best practices
  - Solving Robotic Tasks Issue - Inadequate Understanding of Existing Codebase 