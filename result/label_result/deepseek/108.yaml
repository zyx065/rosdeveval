compilation.log: |
  Starting >>> autoware_planning_validator
  --- stderr: autoware_planning_validator
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_planning_validator/src/planning_validator.cpp: In member function ‘bool autoware::planning_validator::PlanningValidator::checkValidInterval(const Trajectory&)’:
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_planning_validator/src/planning_validator.cpp:362:26: error: ‘using PlanningValidatorStatus = struct autoware_planning_validator::msg::PlanningValidatorStatus_<std::allocator<void> >’ {aka ‘struct autoware_planning_validator::msg::PlanningValidatorStatus_<std::allocator<void> >’} has no member named ‘invalid_point_interval’; did you mean ‘is_valid_interval’?
    362 |       validation_status_.invalid_point_interval = true;
        |                          ^~~~~~~~~~~~~~~~~~~~~~
        |                          is_valid_interval
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_planning_validator/src/planning_validator.cpp:367:22: error: ‘using PlanningValidatorStatus = struct autoware_planning_validator::msg::PlanningValidatorStatus_<std::allocator<void> >’ {aka ‘struct autoware_planning_validator::msg::PlanningValidatorStatus_<std::allocator<void> >’} has no member named ‘invalid_point_interval’; did you mean ‘is_valid_interval’?
    367 |   validation_status_.invalid_point_interval = false;
        |                      ^~~~~~~~~~~~~~~~~~~~~~
        |                      is_valid_interval
  gmake[2]: *** [CMakeFiles/autoware_planning_validator_component.dir/build.make:76: CMakeFiles/autoware_planning_validator_component.dir/src/planning_validator.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:239: CMakeFiles/autoware_planning_validator_component.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_planning_validator [8.39s, exited with code 2]

  Summary: 0 packages finished [9.77s]
    1 package failed: autoware_planning_validator
    1 package had stderr output: autoware_planning_validator
generate_code.cpp: |-
  bool PlanningValidator::checkValidInterval(const Trajectory & trajectory)
  {
    if (trajectory.points.size() < 2) {
      return true;  // single point or empty trajectory is considered valid
    }

    for (size_t i = 0; i < trajectory.points.size() - 1; ++i) {
      const auto & p1 = trajectory.points.at(i);
      const auto & p2 = trajectory.points.at(i + 1);

      const double dx = p1.pose.position.x - p2.pose.position.x;
      const double dy = p1.pose.position.y - p2.pose.position.y;
      const double dz = p1.pose.position.z - p2.pose.position.z;
      const double dist = std::hypot(dx, dy, dz);

      if (dist > validation_params_.interval_threshold) {
        if (debug_pose_publisher_) {
          debug_pose_publisher_->pushPoseMarker(p1.pose, "invalid_interval");
          debug_pose_publisher_->pushPoseMarker(p2.pose, "invalid_interval");
          debug_pose_publisher_->publish();
        }
        validation_status_.invalid_point_interval = true;
        return false;
      }
    }

    validation_status_.invalid_point_interval = false;
    return true;
  }
ground_truth.cpp: |-
  bool PlanningValidator::checkValidInterval(const Trajectory & trajectory)
  {
    const auto [max_interval_distance, i] = calcMaxIntervalDistance(trajectory);
    validation_status_.max_interval_distance = max_interval_distance;

    if (max_interval_distance > validation_params_.interval_threshold) {
      if (i > 0) {
        const auto & p = trajectory.points;
        debug_pose_publisher_->pushPoseMarker(p.at(i - 1), "trajectory_interval");
        debug_pose_publisher_->pushPoseMarker(p.at(i), "trajectory_interval");
      }
      return false;
    }

    return true;
  }
architecture-codes:
  - ROS Message Issue - Incorrect Message Member Access Issue
  - ROS Diagnostic Issue - Incomplete Diagnostic Lifecycle Implementation Issue

functionality-codes:
  - Incomplete Code Issue - Missing Multiple Steps Issue
  - Domain Library Issue - Lack of Domain Library Utilization Issue
  - Condition Issue - Condition Check Logic Misapplication Issue
  - Operation/Calculation Issue - Algorithmic State and Initialization Issue

root-cause-codes:
  - Solving Robotic Tasks Issue - Inadequate Understanding of Task Logic
  - Framework Integration Issue - Insufficient understanding of ROS Integration
  - Solving Robotic Tasks Issue - Inadequate Understanding of Existing Codebase 