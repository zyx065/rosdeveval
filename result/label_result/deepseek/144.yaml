compilation.log: |
  Starting >>> moveit_core
  --- stderr: moveit_core
  gmake[2]: Warning: File 'constraint_samplers/CMakeFiles/test_constraint_samplers.dir/compiler_depend.make' has modification time 0.29 s in the future
  /root/repos/moveit_ws/src/moveit2/moveit_core/distance_field/src/find_internal_points.cpp: In function ‘void distance_field::findInternalPointsConvex(const bodies::Body&, double, EigenSTL::vector_Vector3d&)’:
  /root/repos/moveit_ws/src/moveit2/moveit_core/distance_field/src/find_internal_points.cpp:47:31: error: no matching function for call to ‘bodies::Body::computeBoundingSphere(Eigen::Vector3d&, double&) const’
     47 |     body.computeBoundingSphere(center, radius);
        |     ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~
  In file included from /root/repos/moveit_ws/src/moveit2/moveit_core/distance_field/include/moveit/distance_field/find_internal_points.h:40,
                   from /root/repos/moveit_ws/src/moveit2/moveit_core/distance_field/src/find_internal_points.cpp:37:
  /opt/ros/humble/include/geometric_shapes/geometric_shapes/bodies.h:234:16: note: candidate: ‘virtual void bodies::Body::computeBoundingSphere(bodies::BoundingSphere&) const’
    234 |   virtual void computeBoundingSphere(BoundingSphere& sphere) const = 0;
        |                ^~~~~~~~~~~~~~~~~~~~~
  /opt/ros/humble/include/geometric_shapes/geometric_shapes/bodies.h:234:16: note:   candidate expects 1 argument, 2 provided
  gmake[2]: *** [distance_field/CMakeFiles/moveit_distance_field.dir/build.make:93: distance_field/CMakeFiles/moveit_distance_field.dir/src/find_internal_points.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:955: distance_field/CMakeFiles/moveit_distance_field.dir/all] Error 2
  gmake[1]: *** Waiting for unfinished jobs....
  gmake[2]: warning:  Clock skew detected.  Your build may be incomplete.
  gmake: *** [Makefile:149: all] Error 2
  ---
  Failed   <<< moveit_core [16.5s, exited with code 2]

  Summary: 0 packages finished [17.0s]
    1 package failed: moveit_core
    1 package had stderr output: moveit_core
generate_code.cpp: "void distance_field::findInternalPointsConvex(const bodies::Body&\
  \ body, double resolution,\n                                              EigenSTL::vector_Vector3d&\
  \ points)\n{\n    points.clear();\n    \n    // Get the bounding sphere of the body\n\
  \    Eigen::Vector3d center;\n    double radius;\n    body.computeBoundingSphere(center,\
  \ radius);\n    \n    // Calculate the bounding box dimensions\n    double diameter\
  \ = 2.0 * radius;\n    int steps = static_cast<int>(std::ceil(diameter / resolution));\n\
  \    \n    // Generate points in a grid within the bounding sphere\n    for (int\
  \ x = 0; x < steps; ++x) {\n        for (int y = 0; y < steps; ++y) {\n        \
  \    for (int z = 0; z < steps; ++z) {\n                Eigen::Vector3d point;\n\
  \                point.x() = center.x() - radius + x * resolution;\n           \
  \     point.y() = center.y() - radius + y * resolution;\n                point.z()\
  \ = center.z() - radius + z * resolution;\n                \n                //\
  \ Check if point is inside the body\n                if (body.containsPoint(point))\
  \ {\n                    points.push_back(point);\n                }\n         \
  \   }\n        }\n    }\n}"
ground_truth.cpp: |-
  void distance_field::findInternalPointsConvex(const bodies::Body& body, double resolution,
                                                EigenSTL::vector_Vector3d& points)
  {
    bodies::BoundingSphere sphere;
    body.computeBoundingSphere(sphere);
    double xval_s = std::floor((sphere.center.x() - sphere.radius - resolution) / resolution) * resolution;
    double yval_s = std::floor((sphere.center.y() - sphere.radius - resolution) / resolution) * resolution;
    double zval_s = std::floor((sphere.center.z() - sphere.radius - resolution) / resolution) * resolution;
    double xval_e = sphere.center.x() + sphere.radius + resolution;
    double yval_e = sphere.center.y() + sphere.radius + resolution;
    double zval_e = sphere.center.z() + sphere.radius + resolution;
    Eigen::Vector3d pt;
    for (pt.x() = xval_s; pt.x() <= xval_e; pt.x() += resolution)
    {
      for (pt.y() = yval_s; pt.y() <= yval_e; pt.y() += resolution)
      {
        for (pt.z() = zval_s; pt.z() <= zval_e; pt.z() += resolution)
        {
          if (body.containsPoint(pt))
          {
            points.push_back(pt);
          }
        }
      }
    }
  }
architecture-codes: []

functionality-codes:
  - Domain Library Issue - Domain Specific Library Utilization Error
  - Operation/Calculation Issue - Algorithmic State and Initialization Issue

root-cause-codes:
  - Solving Robotic Tasks Issue - Inadequate Understanding in Domain Knowledge
  - Framework Integration Issue - Insufficient understanding of ROS Integration