compilation.log: |
  Starting >>> autoware_velocity_smoother
  --- stderr: autoware_velocity_smoother
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_velocity_smoother/src/trajectory_utils.cpp: In function ‘std::vector<double> autoware::velocity_smoother::trajectory_utils::calcTrajectoryCurvatureFrom3Points(const TrajectoryPoints&, size_t)’:
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_velocity_smoother/src/trajectory_utils.cpp:197:31: error: ‘getPoint’ was not declared in this scope; did you mean ‘autoware::universe_utils::getPoint’?
    197 |     const auto & prev_point = getPoint(trajectory.at(i - idx_dist));
        |                               ^~~~~~~~
        |                               autoware::universe_utils::getPoint
  In file included from /workspace/repos/autoware/install/autoware_motion_utils/include/autoware/motion_utils/trajectory/trajectory.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_velocity_smoother/src/trajectory_utils.cpp:18:
  /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/geometry/geometry.hpp:102:27: note: ‘autoware::universe_utils::getPoint’ declared here
    102 | geometry_msgs::msg::Point getPoint(const T & p)
        |                           ^~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_velocity_smoother/src/trajectory_utils.cpp:201:21: error: ‘calcCurvature’ was not declared in this scope
    201 |     curvatures[i] = calcCurvature(prev_point, curr_point, next_point);
        |                     ^~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_velocity_smoother/src/trajectory_utils.cpp:201:21: note: suggested alternatives:
  In file included from /workspace/repos/autoware/install/autoware_motion_utils/include/autoware/motion_utils/trajectory/trajectory.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_velocity_smoother/src/trajectory_utils.cpp:18:
  /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/geometry/geometry.hpp:443:8: note:   ‘autoware::universe_utils::calcCurvature’
    443 | double calcCurvature(
        |        ^~~~~~~~~~~~~
  In file included from /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_velocity_smoother/src/trajectory_utils.cpp:18:
  /workspace/repos/autoware/install/autoware_motion_utils/include/autoware/motion_utils/trajectory/trajectory.hpp:954:21: note:   ‘autoware::motion_utils::calcCurvature’
    954 | std::vector<double> calcCurvature(const T & points)
        |                     ^~~~~~~~~~~~~
  gmake[2]: *** [CMakeFiles/smoother.dir/build.make:160: CMakeFiles/smoother.dir/src/trajectory_utils.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:182: CMakeFiles/smoother.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_velocity_smoother [5.25s, exited with code 2]

  Summary: 0 packages finished [6.62s]
    1 package failed: autoware_velocity_smoother
    1 package had stderr output: autoware_velocity_smoother
generate_code.cpp: |-
  std::vector<double> calcTrajectoryCurvatureFrom3Points(
    const TrajectoryPoints & trajectory, size_t idx_dist)
  {
    std::vector<double> curvatures;
    if (trajectory.empty()) {
      return curvatures;
    }

    // Initialize with zeros
    curvatures.resize(trajectory.size(), 0.0);

    // Need at least 3 points to calculate curvature
    if (trajectory.size() < 3) {
      return curvatures;
    }

    // Ensure idx_dist is valid (at least 1 and not too large)
    const size_t max_idx_dist = (trajectory.size() - 1) / 2;
    idx_dist = std::min(std::max<size_t>(idx_dist, 1), max_idx_dist);
    if (idx_dist < 1) {
      throw std::logic_error("idx_dist must be at least 1 after adjustment");
    }

    for (size_t i = idx_dist; i < trajectory.size() - idx_dist; ++i) {
      const auto & prev_point = getPoint(trajectory.at(i - idx_dist));
      const auto & curr_point = getPoint(trajectory.at(i));
      const auto & next_point = getPoint(trajectory.at(i + idx_dist));

      curvatures[i] = calcCurvature(prev_point, curr_point, next_point);
    }

    // Handle edge cases by copying nearest valid curvature
    for (size_t i = 0; i < idx_dist; ++i) {
      curvatures[i] = curvatures[idx_dist];
    }
    for (size_t i = trajectory.size() - idx_dist; i < trajectory.size(); ++i) {
      curvatures[i] = curvatures[trajectory.size() - idx_dist - 1];
    }

    return curvatures;
  }
ground_truth.cpp: |-
  std::vector<double> calcTrajectoryCurvatureFrom3Points(
    const TrajectoryPoints & trajectory, size_t idx_dist)
  {
    using autoware::universe_utils::calcCurvature;
    using autoware::universe_utils::getPoint;

    if (trajectory.size() < 3) {
      const std::vector<double> k_arr(trajectory.size(), 0.0);
      return k_arr;
    }

    // if the idx size is not enough, change the idx_dist
    const auto max_idx_dist = static_cast<size_t>(std::floor((trajectory.size() - 1) / 2.0));
    idx_dist = std::max(1ul, std::min(idx_dist, max_idx_dist));

    if (idx_dist < 1) {
      throw std::logic_error("idx_dist less than 1 is not expected");
    }

    // calculate curvature by circle fitting from three points
    std::vector<double> k_arr(trajectory.size(), 0.0);

    for (size_t i = 1; i + 1 < trajectory.size(); i++) {
      double curvature = 0.0;
      const auto p0 = getPoint(trajectory.at(i - std::min(idx_dist, i)));
      const auto p1 = getPoint(trajectory.at(i));
      const auto p2 = getPoint(trajectory.at(i + std::min(idx_dist, trajectory.size() - 1 - i)));
      try {
        curvature = calcCurvature(p0, p1, p2);
      } catch (std::exception const & e) {
        // ...code that handles the error...
        RCLCPP_WARN(
          rclcpp::get_logger("autoware_velocity_smoother").get_child("trajectory_utils"), "%s",
          e.what());
        if (i > 1) {
          curvature = k_arr.at(i - 1);  // previous curvature
        } else {
          curvature = 0.0;
        }
      }
      k_arr.at(i) = curvature;
    }
    // copy curvatures for the last and first points;
    k_arr.at(0) = k_arr.at(1);
    k_arr.back() = k_arr.at((trajectory.size() - 2));

    return k_arr;
  }
architecture-codes:
  - ROS Logger Issue - ROS Logger Missing Issue

functionality-codes:
  - Incomplete Code Issue - Missing Multiple Steps Issue
  - Condition Issue - Condition Check Logic Misapplication Issue
  - Operation/Calculation Issue - Algorithmic State and Initialization Issue

root-cause-codes:
  - Framework Integration Issue - Insufficient understanding of ROS Integration
  - Framework Integration Issue - Lack of ROS development best practices
  - Solving Robotic Tasks Issue - Inadequate Understanding of Task Logic