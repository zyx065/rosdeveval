compilation.log: |
  Starting >>> autoware_pid_longitudinal_controller
  Finished <<< autoware_pid_longitudinal_controller [12.9s]

  Summary: 1 package finished [14.3s]
generate_code.cpp: |-
  double getPitchByTraj(
    const Trajectory & trajectory, const size_t start_idx, const double wheel_base)
  {
    if (trajectory.points.empty() || start_idx >= trajectory.points.size()) {
      return 0.0;
    }

    // Start from the given index and find the point that is approximately wheel_base distance away
    size_t end_idx = start_idx;
    double accumulated_distance = 0.0;
    const auto & start_point = trajectory.points[start_idx].pose.position;

    for (size_t i = start_idx + 1; i < trajectory.points.size(); ++i) {
      const auto & current_point = trajectory.points[i].pose.position;
      accumulated_distance += autoware::universe_utils::calcDistance3d(start_point, current_point);

      if (accumulated_distance >= wheel_base) {
        end_idx = i;
        break;
      }
    }

    // If we couldn't find a point wheel_base distance away, return 0
    if (end_idx == start_idx) {
      return 0.0;
    }

    const auto & end_point = trajectory.points[end_idx].pose.position;
    return autoware::universe_utils::calcElevationAngle(start_point, end_point);
  }
ground_truth.cpp: |-
  double getPitchByTraj(
    const Trajectory & trajectory, const size_t start_idx, const double wheel_base)
  {
    // cannot calculate pitch
    if (trajectory.points.size() <= 1) {
      return 0.0;
    }

    const auto [prev_idx, next_idx] = [&]() {
      for (size_t i = start_idx + 1; i < trajectory.points.size(); ++i) {
        const double dist = autoware::universe_utils::calcDistance3d(
          trajectory.points.at(start_idx), trajectory.points.at(i));
        if (dist > wheel_base) {
          // calculate pitch from trajectory between rear wheel (nearest) and front center (i)
          return std::make_pair(start_idx, i);
        }
      }
      // NOTE: The ego pose is close to the goal.
      return std::make_pair(
        std::min(start_idx, trajectory.points.size() - 2), trajectory.points.size() - 1);
    }();

    return autoware::universe_utils::calcElevationAngle(
      trajectory.points.at(prev_idx).pose.position, trajectory.points.at(next_idx).pose.position);
  }
architecture-codes: []

functionality-codes:
    - Operation/Calculation Issue - Data Structure Semantic Misinterpretation Issue
    - Incomplete Code Issue - Missing One Step Issue
    - Condition Issue - Conditional Check Missing Issue

root-cause-codes:
    - Solving Robotic Tasks Issue - Inadequate Understanding of Task Logic
    - Solving Robotic Tasks Issue - Inadequate Understanding of System Requirements