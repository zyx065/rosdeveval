compilation.log: |
  Starting >>> nav2_collision_monitor
  Finished <<< nav2_collision_monitor [0.56s]

  Summary: 1 package finished [0.81s]
generate_code.cpp: |-
  void PointCloud::getData(
    const rclcpp::Time & curr_time,
    std::vector<Point> & data) const
  {
    data.clear();

    if (!data_) {
      return;
    }

    if (!sourceValid(data_->header.stamp, curr_time)) {
      return;
    }

    tf2::Transform tf_transform;
    if (!nav2_util::getTransform(
        data_->header.frame_id, data_->header.stamp,
        "base_footprint", curr_time, "odom",
        tf2::durationFromSec(0.1), tf_buffer_, tf_transform))
    {
      return;
    }

    sensor_msgs::PointCloud2ConstIterator<float> iter_x(*data_, "x");
    sensor_msgs::PointCloud2ConstIterator<float> iter_y(*data_, "y");
    sensor_msgs::PointCloud2ConstIterator<float> iter_z(*data_, "z");

    for (; iter_x != iter_x.end(); ++iter_x, ++iter_y, ++iter_z) {
      if (*iter_z < min_height_ || *iter_z > max_height_) {
        continue;
      }

      tf2::Vector3 point_in(*iter_x, *iter_y, *iter_z);
      tf2::Vector3 point_out = tf_transform * point_in;

      Point p;
      p.x = point_out.getX();
      p.y = point_out.getY();
      data.push_back(p);
    }
  }
ground_truth.cpp: |-
  void PointCloud::getData(
    const rclcpp::Time & curr_time,
    std::vector<Point> & data) const
  {
    // Ignore data from the source if it is not being published yet or
    // not published for a long time
    if (data_ == nullptr) {
      return;
    }
    if (!sourceValid(data_->header.stamp, curr_time)) {
      return;
    }

    tf2::Transform tf_transform;
    if (base_shift_correction_) {
      // Obtaining the transform to get data from source frame and time where it was received
      // to the base frame and current time
      if (
        !nav2_util::getTransform(
          data_->header.frame_id, data_->header.stamp,
          base_frame_id_, curr_time, global_frame_id_,
          transform_tolerance_, tf_buffer_, tf_transform))
      {
        return;
      }
    } else {
      // Obtaining the transform to get data from source frame to base frame without time shift
      // considered. Less accurate but much more faster option not dependent on state estimation
      // frames.
      if (
        !nav2_util::getTransform(
          data_->header.frame_id, base_frame_id_,
          transform_tolerance_, tf_buffer_, tf_transform))
      {
        return;
      }
    }

    sensor_msgs::PointCloud2ConstIterator<float> iter_x(*data_, "x");
    sensor_msgs::PointCloud2ConstIterator<float> iter_y(*data_, "y");
    sensor_msgs::PointCloud2ConstIterator<float> iter_z(*data_, "z");

    // Refill data array with PointCloud points in base frame
    for (; iter_x != iter_x.end(); ++iter_x, ++iter_y, ++iter_z) {
      // Transform point coordinates from source frame -> to base frame
      tf2::Vector3 p_v3_s(*iter_x, *iter_y, *iter_z);
      tf2::Vector3 p_v3_b = tf_transform * p_v3_s;

      // Refill data array
      if (p_v3_b.z() >= min_height_ && p_v3_b.z() <= max_height_) {
        data.push_back({p_v3_b.x(), p_v3_b.y()});
      }
    }
  }
architecture-codes:
  - Topic/Service Issue - Topic/Service Name Mismatch Issue
  - ROS Parameter Issue - Insufficient Parameter Design Issue

functionality-codes:
  - Condition Issue - Conditional Check Missing Issue 
  - Incomplete Code Issue - Missing Multiple Steps Issue 
  - Operation/Calculation Issue - Data Structure Semantic Misinterpretation Issue 
  - Operation/Calculation Issue - Algorithmic State and Initialization Issue 
  - Constant Value Issue

root-cause-codes:
  - Solving Robotic Tasks Issue - Inadequate Understanding of System Requirements 
  - Framework Integration Issue - Insufficient understanding of ROS Integration 
  - Framework Integration Issue - Lack of ROS development best practices 
  - Solving Robotic Tasks Issue - Inadequate Understanding of Existing Codebase  