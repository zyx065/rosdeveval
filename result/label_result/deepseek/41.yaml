compilation.log: |
  Starting >>> autoware_traffic_light_arbiter
  --- stderr: autoware_traffic_light_arbiter
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_traffic_light_arbiter/src/traffic_light_arbiter.cpp: In member function ‘void autoware::TrafficLightArbiter::onMap(autoware_map_msgs::msg::LaneletMapBin_<std::allocator<void> >::ConstSharedPtr)’:
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_traffic_light_arbiter/src/traffic_light_arbiter.cpp:110:68: error: invalid initialization of reference of type ‘const ConstLanelets&’ {aka ‘const std::vector<lanelet::ConstLanelet>&’} from expression of type ‘lanelet::LaneletMapPtr’ {aka ‘std::shared_ptr<lanelet::LaneletMap>’}
    110 |   const auto traffic_lights = lanelet::utils::query::trafficLights(lanelet_map);
        |                                                                    ^~~~~~~~~~~
  In file included from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_traffic_light_arbiter/include/autoware/traffic_light_arbiter/signal_match_validator.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_traffic_light_arbiter/include/autoware/traffic_light_arbiter/traffic_light_arbiter.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_traffic_light_arbiter/src/traffic_light_arbiter.cpp:15:
  /workspace/repos/autoware/install/autoware_lanelet2_extension/include/autoware_lanelet2_extension/utility/query.hpp:72:89: note: in passing argument 1 of ‘std::vector<std::shared_ptr<const lanelet::TrafficLight> > lanelet::utils::query::format_v2::trafficLights(const ConstLanelets&)’
     72 | std::vector<lanelet::TrafficLightConstPtr> trafficLights(const lanelet::ConstLanelets & lanelets);
        |                                                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_traffic_light_arbiter/src/traffic_light_arbiter.cpp:111:65: error: ‘pedestrianTrafficLights’ is not a member of ‘lanelet::utils::query’
    111 |   const auto pedestrian_traffic_lights = lanelet::utils::query::pedestrianTrafficLights(lanelet_map);
        |                                                                 ^~~~~~~~~~~~~~~~~~~~~~~
  gmake[2]: *** [CMakeFiles/autoware_traffic_light_arbiter.dir/build.make:76: CMakeFiles/autoware_traffic_light_arbiter.dir/src/traffic_light_arbiter.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:157: CMakeFiles/autoware_traffic_light_arbiter.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_traffic_light_arbiter [7.89s, exited with code 2]

  Summary: 0 packages finished [9.29s]
    1 package failed: autoware_traffic_light_arbiter
    1 package had stderr output: autoware_traffic_light_arbiter
generate_code.cpp: |-
  void TrafficLightArbiter::onMap(const LaneletMapBin::ConstSharedPtr msg)
  {
    // Load the lanelet map from the message
    lanelet::LaneletMapPtr lanelet_map(new lanelet::LaneletMap);
    lanelet::utils::conversion::fromBinMsg(*msg, lanelet_map);

    // Clear existing regulatory elements
    map_regulatory_elements_set_ = std::make_unique<std::unordered_set<lanelet::Id>>();

    // Extract all traffic light regulatory elements from the map
    const auto traffic_lights = lanelet::utils::query::trafficLights(lanelet_map);
    const auto pedestrian_traffic_lights = lanelet::utils::query::pedestrianTrafficLights(lanelet_map);

    // Store the IDs of all regulatory elements
    for (const auto& tl : traffic_lights) {
      map_regulatory_elements_set_->insert(tl->id());
    }
    for (const auto& ptl : pedestrian_traffic_lights) {
      map_regulatory_elements_set_->insert(ptl->id());
    }

    // If signal matching is enabled, update the validator with pedestrian signals
    if (enable_signal_matching_ && signal_match_validator_) {
      signal_match_validator_->setPedestrianSignals(pedestrian_traffic_lights);
    }
  }
ground_truth.cpp: |-
  void TrafficLightArbiter::onMap(const LaneletMapBin::ConstSharedPtr msg)
  {
    const auto map = std::make_shared<lanelet::LaneletMap>();
    lanelet::utils::conversion::fromBinMsg(*msg, map);

    const auto signals = lanelet::filter_traffic_signals(map);
    map_regulatory_elements_set_ = std::make_unique<std::unordered_set<lanelet::Id>>();

    for (const auto & signal : signals) {
      map_regulatory_elements_set_->emplace(signal->id());
    }

    if (enable_signal_matching_) {
      // Filter only pedestrian signals to distinguish them in signal matching
      const auto pedestrian_signals = lanelet::filter_pedestrian_signals(map);
      signal_match_validator_->setPedestrianSignals(pedestrian_signals);
    }
  }
architecture-codes: []

functionality-codes:
    - Domain Library Issue - Domain Specific Library Utilization Error
    - Domain Library Issue - Lack of Domain Library Utilization Issue
    - Condition Issue - Condition Check Logic Misapplication Issue

root-cause-codes:
    - Solving Robotic Tasks Issue - Inadequate Understanding in Domain Knowledge
    - Framework Integration Issue - Insufficient understanding of ROS Integration
    - Solving Robotic Tasks Issue - Inadequate Understanding of Existing Codebase 