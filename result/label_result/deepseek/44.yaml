compilation.log: |
  Starting >>> autoware_obstacle_cruise_planner
  --- stderr: autoware_obstacle_cruise_planner
  /workspace/repos/autoware/src/universe/autoware.universe/planning/autoware_obstacle_cruise_planner/src/node.cpp:233:18: error: ‘std::vector<int> {anonymous}::getTargetObjectType(rclcpp::Node&, const string&)’ defined but not used [-Werror=unused-function]
    233 | std::vector<int> getTargetObjectType(rclcpp::Node & node, const std::string & param_prefix)
        |                  ^~~~~~~~~~~~~~~~~~~
  cc1plus: all warnings being treated as errors
  gmake[2]: *** [CMakeFiles/autoware_obstacle_cruise_planner_core.dir/build.make:76: CMakeFiles/autoware_obstacle_cruise_planner_core.dir/src/node.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:159: CMakeFiles/autoware_obstacle_cruise_planner_core.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_obstacle_cruise_planner [32.8s, exited with code 2]
  [Processing: autoware_obstacle_cruise_planner]

  Summary: 0 packages finished [34.3s]
    1 package failed: autoware_obstacle_cruise_planner
    1 package had stderr output: autoware_obstacle_cruise_planner
generate_code.cpp: "ObstacleCruisePlannerNode::ObstacleCruisePlannerNode(const rclcpp::NodeOptions\
  \ & node_options)\n: Node(\"obstacle_cruise_planner\", node_options),\n  vehicle_info_(autoware::vehicle_info_utils::VehicleInfoUtils(*this).getVehicleInfo()),\n\
  \  debug_data_ptr_(std::make_shared<DebugData>())\n{\n  // Subscribers\n  traj_sub_\
  \ = create_subscription<Trajectory>(\n    \"~/input/trajectory\", rclcpp::QoS{1},\n\
  \    std::bind(&ObstacleCruisePlannerNode::onTrajectory, this, std::placeholders::_1));\n\
  \  \n  // Publishers\n  trajectory_pub_ = create_publisher<Trajectory>(\"~/output/trajectory\"\
  , 1);\n  vel_limit_pub_ = create_publisher<VelocityLimit>(\"~/output/velocity_limit\"\
  , 1);\n  clear_vel_limit_pub_ = create_publisher<VelocityLimitClearCommand>(\"~/output/clear_velocity_limit\"\
  , 1);\n  \n  // Debug Publishers\n  debug_marker_pub_ = create_publisher<MarkerArray>(\"\
  ~/debug/marker\", 1);\n  debug_cruise_wall_marker_pub_ = create_publisher<MarkerArray>(\"\
  ~/debug/cruise_wall_marker\", 1);\n  debug_stop_wall_marker_pub_ = create_publisher<MarkerArray>(\"\
  ~/debug/stop_wall_marker\", 1);\n  debug_slow_down_wall_marker_pub_ = create_publisher<MarkerArray>(\"\
  ~/debug/slow_down_wall_marker\", 1);\n  debug_stop_planning_info_pub_ = create_publisher<Float32MultiArrayStamped>(\"\
  ~/debug/stop_planning_info\", 1);\n  debug_cruise_planning_info_pub_ = create_publisher<Float32MultiArrayStamped>(\"\
  ~/debug/cruise_planning_info\", 1);\n  debug_slow_down_planning_info_pub_ = create_publisher<Float32MultiArrayStamped>(\"\
  ~/debug/slow_down_planning_info\", 1);\n  debug_calculation_time_pub_ = create_publisher<Float64Stamped>(\"\
  ~/debug/calculation_time\", 1);\n\n  // TF\n  tf_buffer_ = std::make_unique<tf2_ros::Buffer>(get_clock());\n\
  \  tf_listener_ = std::make_shared<tf2_ros::TransformListener>(*tf_buffer_);\n\n\
  \  // Parameters\n  ego_nearest_param_.dist_threshold = declare_parameter<double>(\"\
  ego_nearest.dist_threshold\");\n  ego_nearest_param_.yaw_threshold = declare_parameter<double>(\"\
  ego_nearest.yaw_threshold\");\n  enable_debug_info_ = declare_parameter<bool>(\"\
  enable_debug_info\");\n  enable_calculation_time_info_ = declare_parameter<bool>(\"\
  enable_calculation_time_info\");\n  use_pointcloud_for_stop_ = declare_parameter<bool>(\"\
  use_pointcloud_for_stop\");\n  use_pointcloud_for_slow_down_ = declare_parameter<bool>(\"\
  use_pointcloud_for_slow_down\");\n  min_behavior_stop_margin_ = declare_parameter<double>(\"\
  min_behavior_stop_margin\");\n  enable_approaching_on_curve_ = declare_parameter<bool>(\"\
  enable_approaching_on_curve\");\n  additional_safe_distance_margin_on_curve_ = declare_parameter<double>(\"\
  additional_safe_distance_margin_on_curve\");\n  min_safe_distance_margin_on_curve_\
  \ = declare_parameter<double>(\"min_safe_distance_margin_on_curve\");\n  suppress_sudden_obstacle_stop_\
  \ = declare_parameter<bool>(\"suppress_sudden_obstacle_stop\");\n\n  // Parameter\
  \ callback\n  set_param_res_ = add_on_set_parameters_callback(\n    std::bind(&ObstacleCruisePlannerNode::onParam,\
  \ this, std::placeholders::_1));\n\n  // Logger\n  logger_configure_ = std::make_unique<autoware::universe_utils::LoggerLevelConfigure>(this);\n\
  \  published_time_publisher_ = std::make_unique<autoware::universe_utils::PublishedTimePublisher>(this);\n\
  }"
ground_truth.cpp: |-
  ObstacleCruisePlannerNode::ObstacleCruisePlannerNode(const rclcpp::NodeOptions & node_options)
  : Node("obstacle_cruise_planner", node_options),
    vehicle_info_(autoware::vehicle_info_utils::VehicleInfoUtils(*this).getVehicleInfo()),
    debug_data_ptr_(std::make_shared<DebugData>())
  {
    using std::placeholders::_1;

    // subscriber
    traj_sub_ = create_subscription<Trajectory>(
      "~/input/trajectory", rclcpp::QoS{1},
      std::bind(&ObstacleCruisePlannerNode::onTrajectory, this, _1));

    // publisher
    trajectory_pub_ = create_publisher<Trajectory>("~/output/trajectory", 1);
    vel_limit_pub_ =
      create_publisher<VelocityLimit>("~/output/velocity_limit", rclcpp::QoS{1}.transient_local());
    clear_vel_limit_pub_ = create_publisher<VelocityLimitClearCommand>(
      "~/output/clear_velocity_limit", rclcpp::QoS{1}.transient_local());

    // debug publisher
    debug_calculation_time_pub_ = create_publisher<Float64Stamped>("~/debug/processing_time_ms", 1);
    debug_cruise_wall_marker_pub_ = create_publisher<MarkerArray>("~/virtual_wall/cruise", 1);
    debug_stop_wall_marker_pub_ = create_publisher<MarkerArray>("~/virtual_wall/stop", 1);
    debug_slow_down_wall_marker_pub_ = create_publisher<MarkerArray>("~/virtual_wall/slow_down", 1);
    debug_marker_pub_ = create_publisher<MarkerArray>("~/debug/marker", 1);
    debug_stop_planning_info_pub_ =
      create_publisher<Float32MultiArrayStamped>("~/debug/stop_planning_info", 1);
    debug_cruise_planning_info_pub_ =
      create_publisher<Float32MultiArrayStamped>("~/debug/cruise_planning_info", 1);
    debug_slow_down_planning_info_pub_ =
      create_publisher<Float32MultiArrayStamped>("~/debug/slow_down_planning_info", 1);

    // tf listener
    tf_buffer_ = std::make_unique<tf2_ros::Buffer>(get_clock());
    tf_listener_ = std::make_shared<tf2_ros::TransformListener>(*tf_buffer_);

    const auto longitudinal_info = LongitudinalInfo(*this);

    ego_nearest_param_ = EgoNearestParam(*this);

    enable_debug_info_ = declare_parameter<bool>("common.enable_debug_info");
    enable_calculation_time_info_ = declare_parameter<bool>("common.enable_calculation_time_info");
    enable_slow_down_planning_ = declare_parameter<bool>("common.enable_slow_down_planning");

    use_pointcloud_for_stop_ = declare_parameter<bool>("common.stop_obstacle_type.pointcloud");
    use_pointcloud_for_slow_down_ =
      declare_parameter<bool>("common.slow_down_obstacle_type.pointcloud");
    use_pointcloud_ = use_pointcloud_for_stop_ || use_pointcloud_for_slow_down_;

    behavior_determination_param_ = BehaviorDeterminationParam(*this);

    {  // planning algorithm
      const std::string planning_algorithm_param =
        declare_parameter<std::string>("common.planning_algorithm");
      planning_algorithm_ = getPlanningAlgorithmType(planning_algorithm_param);

      if (planning_algorithm_ == PlanningAlgorithm::OPTIMIZATION_BASE) {
        planner_ptr_ = std::make_unique<OptimizationBasedPlanner>(
          *this, longitudinal_info, vehicle_info_, ego_nearest_param_, debug_data_ptr_);
      } else if (planning_algorithm_ == PlanningAlgorithm::PID_BASE) {
        planner_ptr_ = std::make_unique<PIDBasedPlanner>(
          *this, longitudinal_info, vehicle_info_, ego_nearest_param_, debug_data_ptr_);
      } else {
        throw std::logic_error("Designated algorithm is not supported.");
      }

      min_behavior_stop_margin_ = declare_parameter<double>("common.min_behavior_stop_margin");
      additional_safe_distance_margin_on_curve_ =
        declare_parameter<double>("common.stop_on_curve.additional_safe_distance_margin");
      enable_approaching_on_curve_ =
        declare_parameter<bool>("common.stop_on_curve.enable_approaching");
      min_safe_distance_margin_on_curve_ =
        declare_parameter<double>("common.stop_on_curve.min_safe_distance_margin");
      suppress_sudden_obstacle_stop_ =
        declare_parameter<bool>("common.suppress_sudden_obstacle_stop");
      planner_ptr_->setParam(
        enable_debug_info_, enable_calculation_time_info_, use_pointcloud_, min_behavior_stop_margin_,
        enable_approaching_on_curve_, additional_safe_distance_margin_on_curve_,
        min_safe_distance_margin_on_curve_, suppress_sudden_obstacle_stop_);
    }

    {  // stop/cruise/slow down obstacle type
      inside_stop_obstacle_types_ = getTargetObjectType(*this, "common.stop_obstacle_type.inside.");
      outside_stop_obstacle_types_ = getTargetObjectType(*this, "common.stop_obstacle_type.outside.");
      inside_cruise_obstacle_types_ =
        getTargetObjectType(*this, "common.cruise_obstacle_type.inside.");
      outside_cruise_obstacle_types_ =
        getTargetObjectType(*this, "common.cruise_obstacle_type.outside.");
      slow_down_obstacle_types_ = getTargetObjectType(*this, "common.slow_down_obstacle_type.");
    }

    // set parameter callback
    set_param_res_ = this->add_on_set_parameters_callback(
      std::bind(&ObstacleCruisePlannerNode::onParam, this, std::placeholders::_1));

    logger_configure_ = std::make_unique<autoware::universe_utils::LoggerLevelConfigure>(this);
    published_time_publisher_ =
      std::make_unique<autoware::universe_utils::PublishedTimePublisher>(this);
  }
architecture-codes:
  - Topic/Service Issue - QoS Policy Incompatibility Issue
  - Topic/Service Issue - Topic/Service Name Mismatch Issue
  - ROS Parameter Issue - Naming Convention Violations Issue
  - ROS Parameter Issue - Insufficient Parameter Design Issue
  - ROS Parameter Issue - Use Non-existent Parameter Issue

functionality-codes:
  - Incomplete Code Issue - Missing Multiple Steps Issue
  - Condition Issue - Conditional Check Missing Issue

root-cause-codes:
  - Solving Robotic Tasks Issue - Inadequate Understanding of Task Logic
  - Framework Integration Issue - Insufficient understanding of ROS Integration
  - Framework Integration Issue - Lack of ROS development best practices
  - Solving Robotic Tasks Issue - Inadequate Understanding of Existing Codebase 