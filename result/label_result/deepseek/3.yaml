compilation.log: |
  Starting >>> autoware_localization_evaluator
  --- stderr: autoware_localization_evaluator
  /workspace/repos/autoware/src/universe/autoware.universe/evaluator/autoware_localization_evaluator/src/localization_evaluator_node.cpp: In member function ‘void autoware::localization_diagnostics::LocalizationEvaluatorNode::syncCallback(const ConstSharedPtr&, const ConstSharedPtr&)’:
  /workspace/repos/autoware/src/universe/autoware.universe/evaluator/autoware_localization_evaluator/src/localization_evaluator_node.cpp:131:25: error: ‘POSITION_ERROR’ is not a member of ‘autoware::localization_diagnostics::Metric’
    131 |   metrics_dict_[Metric::POSITION_ERROR](position_error);
        |                         ^~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/evaluator/autoware_localization_evaluator/src/localization_evaluator_node.cpp:132:25: error: ‘ORIENTATION_ERROR’ is not a member of ‘autoware::localization_diagnostics::Metric’
    132 |   metrics_dict_[Metric::ORIENTATION_ERROR](orientation_error);
        |                         ^~~~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/evaluator/autoware_localization_evaluator/src/localization_evaluator_node.cpp:143:5: error: ‘diagnostic_pub_’ was not declared in this scope; did you mean ‘diagnostic_msgs’?
    143 |     diagnostic_pub_->publish(diagnostic_status);
        |     ^~~~~~~~~~~~~~~
        |     diagnostic_msgs
  gmake[2]: *** [CMakeFiles/autoware_localization_evaluator.dir/build.make:90: CMakeFiles/autoware_localization_evaluator.dir/src/localization_evaluator_node.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:159: CMakeFiles/autoware_localization_evaluator.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_localization_evaluator [6.70s, exited with code 2]

  Summary: 0 packages finished [8.32s]
    1 package failed: autoware_localization_evaluator
    1 package had stderr output: autoware_localization_evaluator
generate_code.cpp: |-
  void LocalizationEvaluatorNode::syncCallback(
    const Odometry::ConstSharedPtr & msg, const PoseWithCovarianceStamped::ConstSharedPtr & msg_ref)
  {
    // Skip evaluation if either message contains zero-position pose
    if (msg->pose.pose.position.x == 0.0 && msg->pose.pose.position.y == 0.0 && msg->pose.pose.position.z == 0.0) {
      return;
    }
    if (msg_ref->pose.pose.position.x == 0.0 && msg_ref->pose.pose.position.y == 0.0 && msg_ref->pose.pose.position.z == 0.0) {
      return;
    }

    // Calculate position error
    const double dx = msg->pose.pose.position.x - msg_ref->pose.pose.position.x;
    const double dy = msg->pose.pose.position.y - msg_ref->pose.pose.position.y;
    const double dz = msg->pose.pose.position.z - msg_ref->pose.pose.position.z;
    const double position_error = std::sqrt(dx*dx + dy*dy + dz*dz);

    // Calculate orientation error (using quaternion difference)
    tf2::Quaternion q_est, q_ref;
    tf2::fromMsg(msg->pose.pose.orientation, q_est);
    tf2::fromMsg(msg_ref->pose.pose.orientation, q_ref);
    const double orientation_error = q_est.angleShortestPath(q_ref);

    // Update metrics
    metrics_dict_[Metric::POSITION_ERROR](position_error);
    metrics_dict_[Metric::ORIENTATION_ERROR](orientation_error);

    // Store metrics in stats
    for (const auto& metric : metrics_) {
      metric_stats_[static_cast<size_t>(metric)].push_back(metrics_dict_[metric]);
    }
    stamps_.push_back(msg->header.stamp);

    // Publish diagnostic status for each metric
    for (const auto& metric : metrics_) {
      const auto diagnostic_status = generateDiagnosticStatus(metric, metrics_dict_[metric]);
      diagnostic_pub_->publish(diagnostic_status);
    }
  }
ground_truth.cpp: |-
  void LocalizationEvaluatorNode::syncCallback(
    const Odometry::ConstSharedPtr & msg, const PoseWithCovarianceStamped::ConstSharedPtr & msg_ref)
  {
    RCLCPP_DEBUG(
      get_logger(), "Received two messages at time stamps: %d.%d and %d.%d", msg->header.stamp.sec,
      msg->header.stamp.nanosec, msg_ref->header.stamp.sec, msg_ref->header.stamp.nanosec);

    DiagnosticArray metrics_msg;
    metrics_msg.header.stamp = now();

    geometry_msgs::msg::Point p_lc, p_gt;
    p_lc = msg->pose.pose.position;
    p_gt = msg_ref->pose.pose.position;
    if ((p_lc.x == 0 && p_lc.y == 0 && p_lc.z == 0) || (p_gt.x == 0 && p_gt.y == 0 && p_gt.z == 0)) {
      RCLCPP_INFO(get_logger(), "Received position equals zero, waiting for valid data.");
      return;
    }
    for (Metric metric : metrics_) {
      metrics_dict_[metric] = metrics_calculator_.updateStat(
        metrics_dict_[metric], metric, msg->pose.pose.position, msg_ref->pose.pose.position);
      metric_stats_[static_cast<size_t>(metric)].push_back(metrics_dict_[metric]);
      stamps_.push_back(metrics_msg.header.stamp);
      if (metrics_dict_[metric].count() > 0) {
        metrics_msg.status.push_back(generateDiagnosticStatus(metric, metrics_dict_[metric]));
      }
    }
    if (!metrics_msg.status.empty()) {
      metrics_pub_->publish(metrics_msg);
    }
  }
architecture-codes:
  - Topic/Service Issue - Topic/Service Not Used Issue
  - ROS Message Issue - Incorrect Message Member Access Issue
  - ROS Logger Issue - ROS Logger Missing Issue
  - ROS Message Issue - Message Initialization Issue
functionality-codes:
  - Domain Library Issue - Lack of Domain Library Utilization Issue
  - Incomplete Code Issue - Missing Multiple Steps Issue
  - Condition Issue - Condition Check Logic Misapplication Issue
root-cause-codes:
  - Solving Robotic Tasks Issue - Inadequate Understanding of System Requirements
  - Framework Integration Issue - Insufficient understanding of ROS Integration
  - Framework Integration Issue - Lack of ROS development best practices
  - Solving Robotic Tasks Issue - Inadequate Understanding of Existing Codebase 