compilation.log: |
  Starting >>> autoware_pid_longitudinal_controller
  --- stderr: autoware_pid_longitudinal_controller
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp: In member function ‘double autoware::motion::control::pid_longitudinal_controller::SmoothStop::calculate(double, double, double, const std::vector<std::pair<rclcpp::Time, double> >&, double, autoware::motion::control::pid_longitudinal_controller::DebugValues&)’:
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp:122:7: error: no match for ‘operator!’ (operand type is ‘autoware::motion::control::pid_longitudinal_controller::SmoothStop::Params’)
    122 |   if (!m_params) {
        |       ^~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp:122:7: note: candidate: ‘operator!(bool)’ (built-in)
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp:122:7: note:   no known conversion for argument 1 from ‘autoware::motion::control::pid_longitudinal_controller::SmoothStop::Params’ to ‘bool’
  In file included from /opt/ros/humble/include/libstatistics_collector/libstatistics_collector/moving_average_statistics/moving_average.hpp:30,
                   from /opt/ros/humble/include/libstatistics_collector/libstatistics_collector/collector/collector.hpp:22,
                   from /opt/ros/humble/include/libstatistics_collector/libstatistics_collector/topic_statistics_collector/topic_statistics_collector.hpp:24,
                   from /opt/ros/humble/include/libstatistics_collector/libstatistics_collector/topic_statistics_collector/received_message_age.hpp:26,
                   from /opt/ros/humble/include/rclcpp/rclcpp/topic_statistics/subscription_topic_statistics.hpp:26,
                   from /opt/ros/humble/include/rclcpp/rclcpp/subscription.hpp:50,
                   from /opt/ros/humble/include/rclcpp/rclcpp/any_executable.hpp:25,
                   from /opt/ros/humble/include/rclcpp/rclcpp/memory_strategy.hpp:25,
                   from /opt/ros/humble/include/rclcpp/rclcpp/memory_strategies.hpp:18,
                   from /opt/ros/humble/include/rclcpp/rclcpp/executor_options.hpp:20,
                   from /opt/ros/humble/include/rclcpp/rclcpp/executor.hpp:37,
                   from /opt/ros/humble/include/rclcpp/rclcpp/executors/multi_threaded_executor.hpp:25,
                   from /opt/ros/humble/include/rclcpp/rclcpp/executors.hpp:21,
                   from /opt/ros/humble/include/rclcpp/rclcpp/rclcpp.hpp:155,
                   from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/include/autoware/pid_longitudinal_controller/smooth_stop.hpp:19,
                   from /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp:15:
  /opt/ros/humble/include/rcpputils/rcpputils/thread_safety_annotations.hpp:55:27: note: candidate: ‘const std::mutex& operator!(const std::mutex&)’
     55 | inline const std::mutex & operator!(const std::mutex & a)
        |                           ^~~~~~~~
  /opt/ros/humble/include/rcpputils/rcpputils/thread_safety_annotations.hpp:55:56: note:   no known conversion for argument 1 from ‘autoware::motion::control::pid_longitudinal_controller::SmoothStop::Params’ to ‘const std::mutex&’
     55 | inline const std::mutex & operator!(const std::mutex & a)
        |                                     ~~~~~~~~~~~~~~~~~~~^
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp:133:29: error: base operand of ‘->’ has non-pointer type ‘autoware::motion::control::pid_longitudinal_controller::SmoothStop::Params’
    133 |   if (current_vel < m_params->min_running_vel && std::abs(current_acc) < m_params->min_running_acc) {
        |                             ^~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp:133:82: error: base operand of ‘->’ has non-pointer type ‘autoware::motion::control::pid_longitudinal_controller::SmoothStop::Params’
    133 |   if (current_vel < m_params->min_running_vel && std::abs(current_acc) < m_params->min_running_acc) {
        |                                                                                  ^~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp:138:32: error: base operand of ‘->’ has non-pointer type ‘autoware::motion::control::pid_longitudinal_controller::SmoothStop::Params’
    138 |   if (pred_stop_dist < m_params->strong_stop_dist) {
        |                                ^~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp:139:20: error: base operand of ‘->’ has non-pointer type ‘autoware::motion::control::pid_longitudinal_controller::SmoothStop::Params’
    139 |     return m_params->strong_stop_acc;
        |                    ^~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp:143:32: error: base operand of ‘->’ has non-pointer type ‘autoware::motion::control::pid_longitudinal_controller::SmoothStop::Params’
    143 |   if (pred_stop_dist < m_params->weak_stop_dist || time_to_stop < m_params->weak_stop_time) {
        |                                ^~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp:143:75: error: base operand of ‘->’ has non-pointer type ‘autoware::motion::control::pid_longitudinal_controller::SmoothStop::Params’
    143 |   if (pred_stop_dist < m_params->weak_stop_dist || time_to_stop < m_params->weak_stop_time) {
        |                                                                           ^~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp:144:20: error: base operand of ‘->’ has non-pointer type ‘autoware::motion::control::pid_longitudinal_controller::SmoothStop::Params’
    144 |     return m_params->weak_stop_acc;
        |                    ^~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp:148:29: error: base operand of ‘->’ has non-pointer type ‘autoware::motion::control::pid_longitudinal_controller::SmoothStop::Params’
    148 |   if (current_vel > m_params->min_fast_vel) {
        |                             ^~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp:149:20: error: base operand of ‘->’ has non-pointer type ‘autoware::motion::control::pid_longitudinal_controller::SmoothStop::Params’
    149 |     return m_params->max_strong_acc;
        |                    ^~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp:151:20: error: base operand of ‘->’ has non-pointer type ‘autoware::motion::control::pid_longitudinal_controller::SmoothStop::Params’
    151 |     return m_params->min_strong_acc;
        |                    ^~
  /workspace/repos/autoware/src/universe/autoware.universe/control/autoware_pid_longitudinal_controller/src/smooth_stop.cpp:120:17: error: unused parameter ‘debug_values’ [-Werror=unused-parameter]
    120 |   DebugValues & debug_values)
        |   ~~~~~~~~~~~~~~^~~~~~~~~~~~
  cc1plus: all warnings being treated as errors
  gmake[2]: *** [CMakeFiles/autoware_pid_longitudinal_controller_lib.dir/build.make:118: CMakeFiles/autoware_pid_longitudinal_controller_lib.dir/src/smooth_stop.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:157: CMakeFiles/autoware_pid_longitudinal_controller_lib.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_pid_longitudinal_controller [2.71s, exited with code 2]

  Summary: 0 packages finished [4.15s]
    1 package failed: autoware_pid_longitudinal_controller
    1 package had stderr output: autoware_pid_longitudinal_controller
generate_code.cpp: |-
  double SmoothStop::calculate(
    const double stop_dist, const double current_vel, const double current_acc,
    const std::vector<std::pair<rclcpp::Time, double>> & vel_hist, const double delay_time,
    DebugValues & debug_values)
  {
    if (!m_params) {
      throw std::runtime_error("Parameters have not been initialized.");
    }

    const auto time_to_stop_opt = calcTimeToStop(vel_hist);
    const double time_to_stop = time_to_stop_opt ? *time_to_stop_opt : 0.0;

    // Calculate predicted stop distance considering delay
    const double pred_stop_dist = stop_dist - current_vel * delay_time;

    // Check if we're already stopped or past the stop line
    if (current_vel < m_params->min_running_vel && std::abs(current_acc) < m_params->min_running_acc) {
      return 0.0;
    }

    // Strong stop condition (urgent stopping required)
    if (pred_stop_dist < m_params->strong_stop_dist) {
      return m_params->strong_stop_acc;
    }

    // Weak stop condition (gradual stopping)
    if (pred_stop_dist < m_params->weak_stop_dist || time_to_stop < m_params->weak_stop_time) {
      return m_params->weak_stop_acc;
    }

    // Normal deceleration based on velocity
    if (current_vel > m_params->min_fast_vel) {
      return m_params->max_strong_acc;
    } else {
      return m_params->min_strong_acc;
    }
  }
ground_truth.cpp: |-
  double SmoothStop::calculate(
    const double stop_dist, const double current_vel, const double current_acc,
    const std::vector<std::pair<rclcpp::Time, double>> & vel_hist, const double delay_time,
    DebugValues & debug_values)
  {
    if (!m_is_set_params) {
      throw std::runtime_error("Trying to calculate uninitialized SmoothStop");
    }

    // predict time to stop
    const auto time_to_stop = calcTimeToStop(vel_hist);

    // calculate some flags
    const bool is_fast_vel = std::abs(current_vel) > m_params.min_fast_vel;
    const bool is_running = std::abs(current_vel) > m_params.min_running_vel ||
                            std::abs(current_acc) > m_params.min_running_acc;

    // when exceeding the stopline (stop_dist is negative in these cases.)
    if (stop_dist < m_params.strong_stop_dist) {  // when exceeding the stopline much
      debug_values.setValues(
        DebugValues::TYPE::SMOOTH_STOP_MODE, static_cast<int>(Mode::STRONG_STOP));
      return m_params.strong_stop_acc;
    } else if (stop_dist < m_params.weak_stop_dist) {  // when exceeding the stopline a bit
      debug_values.setValues(DebugValues::TYPE::SMOOTH_STOP_MODE, static_cast<int>(Mode::WEAK_STOP));
      return m_params.weak_stop_acc;
    }

    // when the car is running
    if (is_running) {
      // when the car will not stop in a certain time
      if (
        (time_to_stop && *time_to_stop > m_params.weak_stop_time + delay_time) ||
        (!time_to_stop && is_fast_vel)) {
        debug_values.setValues(DebugValues::TYPE::SMOOTH_STOP_MODE, static_cast<int>(Mode::STRONG));
        return m_strong_acc;
      }

      m_weak_acc_time = rclcpp::Clock{RCL_ROS_TIME}.now();
      debug_values.setValues(DebugValues::TYPE::SMOOTH_STOP_MODE, static_cast<int>(Mode::WEAK));
      return m_params.weak_acc;
    }

    // for 0.5 seconds after the car stopped
    if ((rclcpp::Clock{RCL_ROS_TIME}.now() - m_weak_acc_time).seconds() < 0.5) {
      debug_values.setValues(DebugValues::TYPE::SMOOTH_STOP_MODE, static_cast<int>(Mode::WEAK));
      return m_params.weak_acc;
    }

    // when the car is not running
    debug_values.setValues(DebugValues::TYPE::SMOOTH_STOP_MODE, static_cast<int>(Mode::STRONG_STOP));
    return m_params.strong_stop_acc;
  }
architecture-codes:
  - ROS Diagnostic Issue - ROS Diagnostic API Misuse Issue
  - ROS Timer Issue - Clock Source Instantiation and Synchronization Issue
  - ROS Timer Issue - Clock Source Usage Issue

functionality-codes:
  - Condition Issue - Condition Check Logic Misapplication Issue
  - Incomplete Code Issue - Missing Multiple Steps Issue
  - Operation/Calculation Issue - Algorithmic State and Initialization Issue
  - Domain Library Issue - Domain Specific Library Utilization Error

root-cause-codes:
  - Solving Robotic Tasks Issue - Inadequate Understanding of Task Logic
  - Framework Integration Issue - Insufficient understanding of ROS Integration
  - Framework Integration Issue - Lack of ROS development best practices
  - Solving Robotic Tasks Issue - Inadequate Understanding of Existing Codebase 