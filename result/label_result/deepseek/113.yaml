compilation.log: |
  Starting >>> autoware_motion_velocity_dynamic_obstacle_stop_module
  --- stderr: autoware_motion_velocity_dynamic_obstacle_stop_module
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp: In function ‘bool autoware::motion_velocity_planner::dynamic_obstacle_stop::is_in_range(const PredictedObject&, const TrajectoryPoints&, const autoware::motion_velocity_planner::dynamic_obstacle_stop::PlannerParam&, double)’:
  /workspace/repos/autoware/src/universe/autoware.universe/planning/motion_velocity_planner/autoware_motion_velocity_dynamic_obstacle_stop_module/src/object_filtering.cpp:55:38: error: ‘const struct autoware::motion_velocity_planner::dynamic_obstacle_stop::PlannerParam’ has no member named ‘lateral_distance_max_threshold’
     55 |   const double safety_range = params.lateral_distance_max_threshold + hysteresis;
        |                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  gmake[2]: *** [CMakeFiles/autoware_motion_velocity_dynamic_obstacle_stop_module.dir/build.make:132: CMakeFiles/autoware_motion_velocity_dynamic_obstacle_stop_module.dir/src/object_filtering.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:157: CMakeFiles/autoware_motion_velocity_dynamic_obstacle_stop_module.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_motion_velocity_dynamic_obstacle_stop_module [9.93s, exited with code 2]

  Summary: 0 packages finished [11.3s]
    1 package failed: autoware_motion_velocity_dynamic_obstacle_stop_module
    1 package had stderr output: autoware_motion_velocity_dynamic_obstacle_stop_module
generate_code.cpp: |-
  bool is_in_range(
    const autoware_perception_msgs::msg::PredictedObject & object,
    const TrajectoryPoints & ego_trajectory, const PlannerParam & params, const double hysteresis)
  {
    // Get object position
    const auto & obj_pos = object.kinematics.initial_pose_with_covariance.pose.position;

    // Calculate lateral offset from ego trajectory
    const double lateral_offset = autoware::motion_utils::calcLateralOffset(ego_trajectory, obj_pos);

    // Calculate safety range with hysteresis
    const double safety_range = params.lateral_distance_max_threshold + hysteresis;

    // Check if object is within safety range
    return std::abs(lateral_offset) <= safety_range;
  }
ground_truth.cpp: |-
  bool is_in_range(
    const autoware_perception_msgs::msg::PredictedObject & object,
    const TrajectoryPoints & ego_trajectory, const PlannerParam & params, const double hysteresis)
  {
    const auto distance = std::abs(motion_utils::calcLateralOffset(
      ego_trajectory, object.kinematics.initial_pose_with_covariance.pose.position));
    return distance <= params.minimum_object_distance_from_ego_trajectory +
                         params.ego_lateral_offset + object.shape.dimensions.y / 2.0 + hysteresis;
  }
architecture-codes:
  - ROS Parameter Issue - Use Non-existent Parameter Issue
  - ROS Message Issue - Incorrect Message Member Access Issue
functionality-codes:
  - Incomplete Code Issue - Missing Multiple Steps Issue
  - Condition Issue - Condition Check Logic Misapplication Issue
  - Operation/Calculation Issue - Violation of Physical & Kinematic Constraints Issue
root-cause-codes:
  - Solving Robotic Tasks Issue - Inadequate Understanding of System Requirements
  - Framework Integration Issue - Insufficient understanding of ROS Integration
  - Solving Robotic Tasks Issue - Inadequate Understanding of Existing Codebase 