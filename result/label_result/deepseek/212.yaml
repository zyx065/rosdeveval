compilation.log: |
  Starting >>> nav2_mppi_controller
  Finished <<< nav2_mppi_controller [0.79s]

  Summary: 1 package finished [1.11s]
generate_code.cpp: |-
  inline unsigned int findFirstPathInversion(nav_msgs::msg::Path & path)
  {
      if (path.poses.size() < 2) {
          return 0;
      }

      for (unsigned int i = 1; i < path.poses.size(); ++i) {
          double dx = path.poses[i].pose.position.x - path.poses[i-1].pose.position.x;
          double dy = path.poses[i].pose.position.y - path.poses[i-1].pose.position.y;
          double dz = path.poses[i].pose.position.z - path.poses[i-1].pose.position.z;

          // Check if the direction has inverted (sign change in any component)
          if ((dx != 0.0 && (dx * (path.poses[i].pose.position.x - path.poses[0].pose.position.x) < 0)) ||
              (dy != 0.0 && (dy * (path.poses[i].pose.position.y - path.poses[0].pose.position.y) < 0)) ||
              (dz != 0.0 && (dz * (path.poses[i].pose.position.z - path.poses[0].pose.position.z) < 0))) {
              return i;
          }
      }

      return 0;
  }
ground_truth.cpp: |-
  inline unsigned int findFirstPathInversion(nav_msgs::msg::Path & path)
  {
    // At least 3 poses for a possible inversion
    if (path.poses.size() < 3) {
      return path.poses.size();
    }

    // Iterating through the path to determine the position of the path inversion
    for (unsigned int idx = 1; idx < path.poses.size() - 1; ++idx) {
      // We have two vectors for the dot product OA and AB. Determining the vectors.
      float oa_x = path.poses[idx].pose.position.x -
        path.poses[idx - 1].pose.position.x;
      float oa_y = path.poses[idx].pose.position.y -
        path.poses[idx - 1].pose.position.y;
      float ab_x = path.poses[idx + 1].pose.position.x -
        path.poses[idx].pose.position.x;
      float ab_y = path.poses[idx + 1].pose.position.y -
        path.poses[idx].pose.position.y;

      // Checking for the existance of cusp, in the path, using the dot product.
      float dot_product = (oa_x * ab_x) + (oa_y * ab_y);
      if (dot_product < 0.0) {
        return idx + 1;
      }
    }

    return path.poses.size();
  }
architecture-codes: []

functionality-codes:
  - Operation/Calculation Issue - Fundamental Mathematical and Geometric Issue 
  - Incomplete Code Issue - Missing One Step Issue
  - Operation/Calculation Issue - Algorithmic State and Initialization Issue 
  - Condition Issue - Condition Check Logic Misapplication Issue 
  - Constant Value Issue

root-cause-codes:
  - Solving Robotic Tasks Issue - Inadequate Understanding of Task Logic
  - Solving Robotic Tasks Issue - Inadequate Understanding in Domain Knowledge