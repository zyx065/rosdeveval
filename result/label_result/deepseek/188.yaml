compilation.log: |
  Starting >>> nav2_velocity_smoother
  Finished <<< nav2_velocity_smoother [0.23s]

  Summary: 1 package finished [0.53s]
generate_code.cpp: "double VelocitySmoother::applyConstraints(\n  const double v_curr,\
  \ const double v_cmd,\n  const double accel, const double decel, const double eta)\n\
  {\n  double v_diff = v_cmd - v_curr;\n  double max_accel = (v_diff > 0.0) ? accel\
  \ : decel;\n  double max_v_diff = max_accel * eta;\n  \n  // Limit the velocity\
  \ difference by acceleration/deceleration constraints\n  if (v_diff > max_v_diff)\
  \ {\n    v_diff = max_v_diff;\n  } else if (v_diff < -max_v_diff) {\n    v_diff\
  \ = -max_v_diff;\n  }\n  \n  return v_curr + v_diff;\n}"
ground_truth.cpp: |-
  double VelocitySmoother::applyConstraints(
    const double v_curr, const double v_cmd,
    const double accel, const double decel, const double eta)
  {
    double dv = v_cmd - v_curr;

    double v_component_max;
    double v_component_min;

    // Accelerating if magnitude of v_cmd is above magnitude of v_curr
    // and if v_cmd and v_curr have the same sign (i.e. speed is NOT passing through 0.0)
    // Decelerating otherwise
    if (abs(v_cmd) >= abs(v_curr) && v_curr * v_cmd >= 0.0) {
      v_component_max = accel / smoothing_frequency_;
      v_component_min = -accel / smoothing_frequency_;
    } else {
      v_component_max = -decel / smoothing_frequency_;
      v_component_min = decel / smoothing_frequency_;
    }

    return v_curr + std::clamp(eta * dv, v_component_min, v_component_max);
  }
architecture-codes: []

functionality-codes:
  - Condition Issue - Condition Check Logic Misapplication Issue
  - Operation/Calculation Issue - Fundamental Mathematical and Geometric Issue
  - Incomplete Code Issue - Missing One Step Issue 

root-cause-codes:
  - Solving Robotic Tasks Issue - Inadequate Understanding of Task Logic
  - Framework Integration Issue - Insufficient understanding of ROS Integration
  - Solving Robotic Tasks Issue - Inadequate Understanding in Domain Knowledge