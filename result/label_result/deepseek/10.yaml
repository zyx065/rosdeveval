compilation.log: |
  Starting >>> autoware_ar_tag_based_localizer
  --- stderr: autoware_ar_tag_based_localizer
  /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_landmark_based_localizer/autoware_ar_tag_based_localizer/src/ar_tag_based_localizer.cpp: In constructor ‘ArTagBasedLocalizer::ArTagBasedLocalizer(const rclcpp::NodeOptions&)’:
  /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_landmark_based_localizer/autoware_ar_tag_based_localizer/src/ar_tag_based_localizer.cpp:102:37: error: ‘onMap’ is not a member of ‘ArTagBasedLocalizer’
    102 |     std::bind(&ArTagBasedLocalizer::onMap, this, std::placeholders::_1));
        |                                     ^~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_landmark_based_localizer/autoware_ar_tag_based_localizer/src/ar_tag_based_localizer.cpp:106:37: error: ‘onImage’ is not a member of ‘ArTagBasedLocalizer’
    106 |     std::bind(&ArTagBasedLocalizer::onImage, this, std::placeholders::_1));
        |                                     ^~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_landmark_based_localizer/autoware_ar_tag_based_localizer/src/ar_tag_based_localizer.cpp:110:37: error: ‘onCameraInfo’ is not a member of ‘ArTagBasedLocalizer’
    110 |     std::bind(&ArTagBasedLocalizer::onCameraInfo, this, std::placeholders::_1));
        |                                     ^~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_landmark_based_localizer/autoware_ar_tag_based_localizer/src/ar_tag_based_localizer.cpp:114:37: error: ‘onEkfPose’ is not a member of ‘ArTagBasedLocalizer’
    114 |     std::bind(&ArTagBasedLocalizer::onEkfPose, this, std::placeholders::_1));
        |                                     ^~~~~~~~~
  In file included from /usr/include/c++/11/memory:76,
                   from /workspace/repos/autoware/install/autoware_map_msgs/include/autoware_map_msgs/autoware_map_msgs/msg/detail/lanelet_map_bin__struct.hpp:10,
                   from /workspace/repos/autoware/install/autoware_map_msgs/include/autoware_map_msgs/autoware_map_msgs/msg/lanelet_map_bin.hpp:7,
                   from /workspace/repos/autoware/install/autoware_lanelet2_extension/include/autoware_lanelet2_extension/localization/landmark.hpp:18,
                   from /workspace/repos/autoware/install/autoware_landmark_manager/include/autoware/landmark_manager/landmark_manager.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_landmark_based_localizer/autoware_ar_tag_based_localizer/src/ar_tag_based_localizer.hpp:48,
                   from /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_landmark_based_localizer/autoware_ar_tag_based_localizer/src/ar_tag_based_localizer.cpp:45:
  /usr/include/c++/11/bits/unique_ptr.h: In instantiation of ‘typename std::_MakeUniq<_Tp>::__single_object std::make_unique(_Args&& ...) [with _Tp = autoware::localization_util::SmartPoseBuffer; _Args = {std::shared_ptr<rclcpp::Clock>, double&, double&}; typename std::_MakeUniq<_Tp>::__single_object = std::unique_ptr<autoware::localization_util::SmartPoseBuffer>]’:
  /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_landmark_based_localizer/autoware_ar_tag_based_localizer/src/ar_tag_based_localizer.cpp:96:84:   required from here
  /usr/include/c++/11/bits/unique_ptr.h:962:30: error: no matching function for call to ‘autoware::localization_util::SmartPoseBuffer::SmartPoseBuffer(std::shared_ptr<rclcpp::Clock>, double&, double&)’
    962 |     { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }
        |                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  In file included from /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_landmark_based_localizer/autoware_ar_tag_based_localizer/src/ar_tag_based_localizer.hpp:49,
                   from /workspace/repos/autoware/src/universe/autoware.universe/localization/autoware_landmark_based_localizer/autoware_ar_tag_based_localizer/src/ar_tag_based_localizer.cpp:45:
  /workspace/repos/autoware/install/autoware_localization_util/include/autoware/localization_util/smart_pose_buffer.hpp:42:3: note: candidate: ‘autoware::localization_util::SmartPoseBuffer::SmartPoseBuffer(const rclcpp::Logger&, const double&, const double&)’
     42 |   SmartPoseBuffer(
        |   ^~~~~~~~~~~~~~~
  /workspace/repos/autoware/install/autoware_localization_util/include/autoware/localization_util/smart_pose_buffer.hpp:43:28: note:   no known conversion for argument 1 from ‘std::shared_ptr<rclcpp::Clock>’ to ‘const rclcpp::Logger&’
     43 |     const rclcpp::Logger & logger, const double & pose_timeout_sec,
        |     ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~
  gmake[2]: *** [CMakeFiles/autoware_ar_tag_based_localizer.dir/build.make:76: CMakeFiles/autoware_ar_tag_based_localizer.dir/src/ar_tag_based_localizer.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:159: CMakeFiles/autoware_ar_tag_based_localizer.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_ar_tag_based_localizer [7.60s, exited with code 2]

  Summary: 0 packages finished [9.04s]
    1 package failed: autoware_ar_tag_based_localizer
    1 package had stderr output: autoware_ar_tag_based_localizer
generate_code.cpp: |
  ArTagBasedLocalizer::ArTagBasedLocalizer(const rclcpp::NodeOptions & options)
  : rclcpp::Node("ar_tag_based_localizer", options), cam_info_received_(false)
  {
    // Parameters
    marker_size_ = declare_parameter<double>("marker_size");
    target_tag_ids_ = declare_parameter<std::vector<std::string>>("target_tag_ids");
    base_covariance_ = declare_parameter<std::vector<double>>("base_covariance");
    distance_threshold_ = declare_parameter<double>("distance_threshold");
    consider_orientation_ = declare_parameter<bool>("consider_orientation");
    ekf_time_tolerance_ = declare_parameter<double>("ekf_time_tolerance");
    ekf_position_tolerance_ = declare_parameter<double>("ekf_position_tolerance");

    // Initialize detector
    detector_.setDictionary("ARUCO");
    detector_.setDetectionMode(aruco::DetectionMode::DM_NORMAL);

    // TF
    tf_buffer_ = std::make_unique<tf2_ros::Buffer>(get_clock());
    tf_listener_ = std::make_unique<tf2_ros::TransformListener>(*tf_buffer_);

    // EKF pose buffer
    ekf_pose_buffer_ = std::make_unique<autoware::localization_util::SmartPoseBuffer>(
      this->get_clock(), ekf_time_tolerance_, ekf_position_tolerance_);

    // Subscribers
    map_bin_sub_ = create_subscription<LaneletMapBin>(
      "input/lanelet2_map", rclcpp::QoS(1).transient_local(),
      std::bind(&ArTagBasedLocalizer::onMap, this, std::placeholders::_1));
    
    image_sub_ = create_subscription<Image>(
      "input/image", rclcpp::QoS(1),
      std::bind(&ArTagBasedLocalizer::onImage, this, std::placeholders::_1));
    
    cam_info_sub_ = create_subscription<CameraInfo>(
      "input/camera_info", rclcpp::QoS(1),
      std::bind(&ArTagBasedLocalizer::onCameraInfo, this, std::placeholders::_1));
    
    ekf_pose_sub_ = create_subscription<PoseWithCovarianceStamped>(
      "input/ekf_pose", rclcpp::QoS(1),
      std::bind(&ArTagBasedLocalizer::onEkfPose, this, std::placeholders::_1));

    // Publishers
    pose_pub_ = create_publisher<PoseWithCovarianceStamped>("output/pose", rclcpp::QoS(1));
    image_pub_ = create_publisher<Image>("debug/image", rclcpp::QoS(1));
    detected_tag_pose_pub_ = create_publisher<PoseArray>("debug/detected_tag_pose", rclcpp::QoS(1));
    mapped_tag_pose_pub_ = create_publisher<MarkerArray>("debug/mapped_tag_pose", rclcpp::QoS(1));
    diag_pub_ = create_publisher<DiagnosticArray>("diagnostics", rclcpp::QoS(1));
  }
ground_truth.cpp: |-
  ArTagBasedLocalizer::ArTagBasedLocalizer(const rclcpp::NodeOptions & options)
  : rclcpp::Node("ar_tag_based_localizer", options), cam_info_received_(false)
  {
    /*
      Declare node parameters
    */
    marker_size_ = static_cast<float>(this->declare_parameter<double>("marker_size"));
    target_tag_ids_ = this->declare_parameter<std::vector<std::string>>("target_tag_ids");
    base_covariance_ = this->declare_parameter<std::vector<double>>("base_covariance");
    distance_threshold_ = this->declare_parameter<double>("distance_threshold");
    consider_orientation_ = this->declare_parameter<bool>("consider_orientation");
    ekf_time_tolerance_ = this->declare_parameter<double>("ekf_time_tolerance");
    ekf_position_tolerance_ = this->declare_parameter<double>("ekf_position_tolerance");
    std::string detection_mode = this->declare_parameter<std::string>("detection_mode");
    float min_marker_size = static_cast<float>(this->declare_parameter<double>("min_marker_size"));
    if (detection_mode == "DM_NORMAL") {
      detector_.setDetectionMode(aruco::DM_NORMAL, min_marker_size);
    } else if (detection_mode == "DM_FAST") {
      detector_.setDetectionMode(aruco::DM_FAST, min_marker_size);
    } else if (detection_mode == "DM_VIDEO_FAST") {
      detector_.setDetectionMode(aruco::DM_VIDEO_FAST, min_marker_size);
    } else {
      // Error
      RCLCPP_ERROR_STREAM(this->get_logger(), "Invalid detection_mode: " << detection_mode);
      return;
    }
    ekf_pose_buffer_ = std::make_unique<autoware::localization_util::SmartPoseBuffer>(
      this->get_logger(), ekf_time_tolerance_, ekf_position_tolerance_);

    /*
      Log parameter info
    */
    RCLCPP_INFO_STREAM(this->get_logger(), "min_marker_size: " << min_marker_size);
    RCLCPP_INFO_STREAM(this->get_logger(), "detection_mode: " << detection_mode);
    RCLCPP_INFO_STREAM(this->get_logger(), "thresMethod: " << detector_.getParameters().thresMethod);
    RCLCPP_INFO_STREAM(this->get_logger(), "marker_size_: " << marker_size_);

    /*
      tf
    */
    tf_buffer_ = std::make_unique<tf2_ros::Buffer>(this->get_clock());
    tf_listener_ = std::make_unique<tf2_ros::TransformListener>(*tf_buffer_);

    /*
      Subscribers
    */
    using std::placeholders::_1;
    map_bin_sub_ = this->create_subscription<LaneletMapBin>(
      "~/input/lanelet2_map", rclcpp::QoS(1).durability(rclcpp::DurabilityPolicy::TransientLocal),
      std::bind(&ArTagBasedLocalizer::map_bin_callback, this, _1));

    rclcpp::QoS qos_sub(rclcpp::QoSInitialization::from_rmw(rmw_qos_profile_default));
    qos_sub.best_effort();
    image_sub_ = this->create_subscription<Image>(
      "~/input/image", qos_sub, std::bind(&ArTagBasedLocalizer::image_callback, this, _1));
    cam_info_sub_ = this->create_subscription<CameraInfo>(
      "~/input/camera_info", qos_sub, std::bind(&ArTagBasedLocalizer::cam_info_callback, this, _1));
    ekf_pose_sub_ = this->create_subscription<PoseWithCovarianceStamped>(
      "~/input/ekf_pose", qos_sub, std::bind(&ArTagBasedLocalizer::ekf_pose_callback, this, _1));

    /*
      Publishers
    */
    const rclcpp::QoS qos_pub_once = rclcpp::QoS(rclcpp::KeepLast(1)).transient_local().reliable();
    const rclcpp::QoS qos_pub_periodic(rclcpp::QoSInitialization::from_rmw(rmw_qos_profile_default));
    pose_pub_ = this->create_publisher<PoseWithCovarianceStamped>(
      "~/output/pose_with_covariance", qos_pub_periodic);
    image_pub_ = this->create_publisher<Image>("~/debug/image", qos_pub_periodic);
    mapped_tag_pose_pub_ = this->create_publisher<MarkerArray>("~/debug/mapped_tag", qos_pub_once);
    detected_tag_pose_pub_ =
      this->create_publisher<PoseArray>("~/debug/detected_tag", qos_pub_periodic);
    diag_pub_ = this->create_publisher<DiagnosticArray>("/diagnostics", qos_pub_periodic);

    RCLCPP_INFO(this->get_logger(), "Setup of ar_tag_based_localizer node is successful!");
  }
architecture-codes:
  - Topic/Service Issue - Topic/Service Name Mismatch Issue
  - Topic/Service Issue - QoS Policy Incompatibility Issue
  - Topic/Service Issue - Callback Function Binding Issue
  - ROS Parameter Issue - Insufficient Parameter Design Issue
  - ROS Logger Issue - ROS Logger Missing Issue
  - ROS Message Issue - Message Operation Issue
functionality-codes:
  - Condition Issue - Conditional Check Missing Issue
  - Domain Library Issue - Domain Specific Library Utilization Error
  - Incomplete Code Issue - Missing Multiple Steps Issue
  - Operation/Calculation Issue - Data Structure Semantic Misinterpretation Issue
root-cause-codes:
  - Solving Robotic Tasks Issue - Inadequate Understanding of System Requirements
  - Framework Integration Issue - Insufficient understanding of ROS Integration
  - Framework Integration Issue - Lack of ROS development best practices
  - Solving Robotic Tasks Issue - Inadequate Understanding in Domain Knowledge
  - Framework Integration Issue - Insufficient understanding of ROS Integration