compilation.log: |
  Starting >>> moveit_core
  Finished <<< moveit_core [1.06s]

  Summary: 1 package finished [1.53s]
generate_code.cpp: "double DistanceField::getDistanceGradient(double x, double y,\
  \ double z, double& gradient_x, double& gradient_y,\n                          \
  \              double& gradient_z, bool& in_bounds) const\n{\n    in_bounds = true;\n\
  \    \n    // Check if the point is within bounds\n    int gx, gy, gz;\n    if (!worldToGrid(x,\
  \ y, z, gx, gy, gz) || \n        gx <= 0 || gx >= getXNumCells() - 1 ||\n      \
  \  gy <= 0 || gy >= getXNumCells() - 1 ||\n        gz <= 0 || gz >= getXNumCells()\
  \ - 1)\n    {\n        in_bounds = false;\n        gradient_x = 0.0;\n        gradient_y\
  \ = 0.0;\n        gradient_z = 0.0;\n        return getUninitializedDistance();\n\
  \    }\n\n    // Central difference for gradient calculation\n    double dx1 = getDistance(x\
  \ + inv_twice_resolution_, y, z);\n    double dx2 = getDistance(x - inv_twice_resolution_,\
  \ y, z);\n    gradient_x = (dx1 - dx2) * inv_twice_resolution_;\n\n    double dy1\
  \ = getDistance(x, y + inv_twice_resolution_, z);\n    double dy2 = getDistance(x,\
  \ y - inv_twice_resolution_, z);\n    gradient_y = (dy1 - dy2) * inv_twice_resolution_;\n\
  \n    double dz1 = getDistance(x, y, z + inv_twice_resolution_);\n    double dz2\
  \ = getDistance(x, y, z - inv_twice_resolution_);\n    gradient_z = (dz1 - dz2)\
  \ * inv_twice_resolution_;\n\n    // Return the distance at the point\n    return\
  \ getDistance(x, y, z);\n}"
ground_truth.cpp: |-
  double DistanceField::getDistanceGradient(double x, double y, double z, double& gradient_x, double& gradient_y,
                                            double& gradient_z, bool& in_bounds) const
  {
    int gx, gy, gz;

    worldToGrid(x, y, z, gx, gy, gz);

    // if out of bounds, return max_distance, and 0 gradient
    // we need extra padding of 1 to get gradients
    if (gx < 1 || gy < 1 || gz < 1 || gx >= getXNumCells() - 1 || gy >= getYNumCells() - 1 || gz >= getZNumCells() - 1)
    {
      gradient_x = 0.0;
      gradient_y = 0.0;
      gradient_z = 0.0;
      in_bounds = false;
      return getUninitializedDistance();
    }

    gradient_x = (getDistance(gx + 1, gy, gz) - getDistance(gx - 1, gy, gz)) * inv_twice_resolution_;
    gradient_y = (getDistance(gx, gy + 1, gz) - getDistance(gx, gy - 1, gz)) * inv_twice_resolution_;
    gradient_z = (getDistance(gx, gy, gz + 1) - getDistance(gx, gy, gz - 1)) * inv_twice_resolution_;

    in_bounds = true;
    return getDistance(gx, gy, gz);
  }
architecture-codes: []

functionality-codes:
  - Condition Issue - Condition Check Logic Misapplication Issue
  - Constant Value Issue
  - Operation/Calculation Issue - Fundamental Mathematical and Geometric Issue
  - Operation/Calculation Issue - Algorithmic State and Initialization Issue

root-cause-codes:
  - Solving Robotic Tasks Issue - Inadequate Understanding of Task Logic
  - Solving Robotic Tasks Issue - Inadequate Understanding in Domain Knowledge