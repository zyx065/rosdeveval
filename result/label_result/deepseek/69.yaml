compilation.log: |
  Starting >>> autoware_map_based_prediction
  --- stderr: autoware_map_based_prediction
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_map_based_prediction/src/path_generator.cpp: In member function ‘autoware_perception_msgs::msg::PredictedPath autoware::map_based_prediction::PathGenerator::generatePathToTargetPoint(const TrackedObject&, const Vector2d&) const’:
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_map_based_prediction/src/path_generator.cpp:87:53: error: ‘using element_type = class autoware::universe_utils::TimeKeeper’ {aka ‘class autoware::universe_utils::TimeKeeper’} has no member named ‘getDeltaTime’
     87 |   const double prediction_time_step = time_keeper_->getDeltaTime();
        |                                                     ^~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_map_based_prediction/src/path_generator.cpp:88:52: error: ‘using element_type = class autoware::universe_utils::TimeKeeper’ {aka ‘class autoware::universe_utils::TimeKeeper’} has no member named ‘getPredictionTimeHorizon’
     88 |   const double prediction_duration = time_keeper_->getPredictionTimeHorizon();
        |                                                    ^~~~~~~~~~~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_map_based_prediction/src/path_generator.cpp:101:26: error: ‘createQuaternionFromYaw’ was not declared in this scope; did you mean ‘autoware::universe_utils::createQuaternionFromYaw’?
    101 |       pose.orientation = createQuaternionFromYaw(yaw);
        |                          ^~~~~~~~~~~~~~~~~~~~~~~
        |                          autoware::universe_utils::createQuaternionFromYaw
  In file included from /workspace/repos/autoware/install/autoware_interpolation/include/autoware/interpolation/spline_interpolation.hpp:19,
                   from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_map_based_prediction/src/path_generator.cpp:18:
  /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/geometry/geometry.hpp:314:32: note: ‘autoware::universe_utils::createQuaternionFromYaw’ declared here
    314 | geometry_msgs::msg::Quaternion createQuaternionFromYaw(const double yaw);
        |                                ^~~~~~~~~~~~~~~~~~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_map_based_prediction/src/path_generator.cpp:114:24: error: ‘createQuaternionFromYaw’ was not declared in this scope; did you mean ‘autoware::universe_utils::createQuaternionFromYaw’?
    114 |     pose.orientation = createQuaternionFromYaw(yaw);
        |                        ^~~~~~~~~~~~~~~~~~~~~~~
        |                        autoware::universe_utils::createQuaternionFromYaw
  In file included from /workspace/repos/autoware/install/autoware_interpolation/include/autoware/interpolation/spline_interpolation.hpp:19,
                   from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_map_based_prediction/src/path_generator.cpp:18:
  /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/geometry/geometry.hpp:314:32: note: ‘autoware::universe_utils::createQuaternionFromYaw’ declared here
    314 | geometry_msgs::msg::Quaternion createQuaternionFromYaw(const double yaw);
        |                                ^~~~~~~~~~~~~~~~~~~~~~~
  gmake[2]: *** [CMakeFiles/map_based_prediction_node.dir/build.make:90: CMakeFiles/map_based_prediction_node.dir/src/path_generator.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:159: CMakeFiles/map_based_prediction_node.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_map_based_prediction [7.13s, exited with code 2]

  Summary: 0 packages finished [8.56s]
    1 package failed: autoware_map_based_prediction
    1 package had stderr output: autoware_map_based_prediction
generate_code.cpp: |-
  PredictedPath PathGenerator::generatePathToTargetPoint(
    const TrackedObject & object, const Eigen::Vector2d & point) const
  {
    PredictedPath path;
    const auto & current_position = object.kinematics.pose_with_covariance.pose.position;
    const auto & current_velocity = object.kinematics.twist_with_covariance.twist.linear;

    // Convert to Eigen vectors for easier calculations
    Eigen::Vector2d current_pos(current_position.x, current_position.y);
    Eigen::Vector2d velocity(current_velocity.x, current_velocity.y);

    // Calculate direction to target point
    Eigen::Vector2d direction = point - current_pos;
    double distance_to_target = direction.norm();

    // If already at target or no velocity, return single-point path
    if (distance_to_target < 1e-6 || velocity.norm() < 1e-6) {
      path.path.push_back(object.kinematics.pose_with_covariance.pose);
      return path;
    }

    // Normalize direction
    direction.normalize();

    // Calculate yaw angle (heading) toward target
    double yaw = std::atan2(direction.y(), direction.x());

    // Time parameters
    const double prediction_time_step = time_keeper_->getDeltaTime();
    const double prediction_duration = time_keeper_->getPredictionTimeHorizon();

    // Generate path points
    for (double t = 0.0; t <= prediction_duration; t += prediction_time_step) {
      // Calculate distance traveled in this time step
      double step_distance = velocity.norm() * t;

      // Stop if we've reached the target
      if (step_distance >= distance_to_target) {
        geometry_msgs::msg::Pose pose;
        pose.position.x = point.x();
        pose.position.y = point.y();
        pose.position.z = current_position.z;
        pose.orientation = createQuaternionFromYaw(yaw);
        path.path.push_back(pose);
        break;
      }

      // Calculate new position
      Eigen::Vector2d new_pos = current_pos + direction * step_distance;

      // Create pose
      geometry_msgs::msg::Pose pose;
      pose.position.x = new_pos.x();
      pose.position.y = new_pos.y();
      pose.position.z = current_position.z;
      pose.orientation = createQuaternionFromYaw(yaw);

      path.path.push_back(pose);
    }

    return path;
  }
ground_truth.cpp: |-
  PredictedPath PathGenerator::generatePathToTargetPoint(
    const TrackedObject & object, const Eigen::Vector2d & point) const
  {
    std::unique_ptr<ScopedTimeTrack> st_ptr;
    if (time_keeper_) st_ptr = std::make_unique<ScopedTimeTrack>(__func__, *time_keeper_);

    PredictedPath predicted_path{};
    const double ep = 0.001;

    const auto & obj_pos = object.kinematics.pose_with_covariance.pose.position;
    const auto & obj_vel = object.kinematics.twist_with_covariance.twist.linear;

    const Eigen::Vector2d pedestrian_to_entry_point(point.x() - obj_pos.x, point.y() - obj_pos.y);
    const auto velocity = std::max(std::hypot(obj_vel.x, obj_vel.y), min_crosswalk_user_velocity_);
    const auto arrival_time = pedestrian_to_entry_point.norm() / velocity;

    const auto pedestrian_to_entry_point_normalized = pedestrian_to_entry_point.normalized();
    const auto pedestrian_to_entry_point_orientation =
      autoware::universe_utils::createQuaternionFromYaw(std::atan2(
        pedestrian_to_entry_point_normalized.y(), pedestrian_to_entry_point_normalized.x()));

    for (double dt = 0.0; dt < arrival_time + ep; dt += sampling_time_interval_) {
      geometry_msgs::msg::Pose world_frame_pose;
      world_frame_pose.position.x =
        obj_pos.x + velocity * pedestrian_to_entry_point_normalized.x() * dt;
      world_frame_pose.position.y =
        obj_pos.y + velocity * pedestrian_to_entry_point_normalized.y() * dt;
      world_frame_pose.position.z = obj_pos.z;
      world_frame_pose.orientation = pedestrian_to_entry_point_orientation;
      predicted_path.path.push_back(world_frame_pose);
      if (predicted_path.path.size() >= predicted_path.path.max_size()) {
        break;
      }
    }

    predicted_path.confidence = 1.0;
    predicted_path.time_step = rclcpp::Duration::from_seconds(sampling_time_interval_);

    return predicted_path;
  }
architecture-codes:
  - ROS Parameter Issue - Use Non-existent Parameter Issue
  - ROS Parameter Issue - Insufficient Parameter Design Issue
  - ROS Message Issue - Message Initialization Issue
  - ROS Diagnostic Issue - Incomplete Diagnostic Lifecycle Implementation Issue

functionality-codes:
  - Condition Issue - Condition Check Logic Misapplication Issue
  - Operation/Calculation Issue - Algorithmic State and Initialization Issue
  - Incomplete Code Issue - Missing Multiple Steps Issue
  - Constant Value Issue

root-cause-codes:
  - Solving Robotic Tasks Issue - Inadequate Understanding of Task Logic
  - Framework Integration Issue - Insufficient understanding of ROS Integration
  - Framework Integration Issue - Lack of ROS development best practices
  - Solving Robotic Tasks Issue - Inadequate Understanding of Existing Codebase 