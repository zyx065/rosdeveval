compilation.log: |
  Starting >>> moveit_core
  Finished <<< moveit_core [0.82s]

  Summary: 1 package finished [1.29s]
generate_code.cpp: |-
  ConstraintEvaluationResult JointConstraint::decide(const moveit::core::RobotState& state, bool verbose) const
  {
    double current_position = state.getVariablePosition(joint_variable_index_);
    double distance = 0.0;
    bool satisfied = false;

    if (joint_is_continuous_)
    {
      // For continuous joints, we need to normalize the angles to compare them properly
      double normalized_current = normalizeAngle(current_position);
      double normalized_desired = normalizeAngle(joint_position_);
      double diff = normalized_current - normalized_desired;
      distance = normalizeAngle(diff);

      // Check if within tolerance
      if (distance <= joint_tolerance_above_ && distance >= -joint_tolerance_below_)
      {
        satisfied = true;
      }
    }
    else
    {
      // For non-continuous joints, simple comparison
      distance = current_position - joint_position_;

      // Check if within tolerance
      if (distance <= joint_tolerance_above_ && distance >= -joint_tolerance_below_)
      {
        satisfied = true;
      }
    }

    // Apply constraint weight to distance
    distance *= constraint_weight_;

    return ConstraintEvaluationResult(satisfied, distance);
  }
ground_truth.cpp: |-
  ConstraintEvaluationResult JointConstraint::decide(const moveit::core::RobotState& state, bool verbose) const
  {
    if (!joint_model_)
      return ConstraintEvaluationResult(true, 0.0);

    double current_joint_position = state.getVariablePosition(joint_variable_index_);
    double dif = 0.0;

    // compute signed shortest distance for continuous joints
    if (joint_is_continuous_)
    {
      dif = normalizeAngle(current_joint_position) - joint_position_;

      if (dif > M_PI)
        dif = 2.0 * M_PI - dif;
      else if (dif < -M_PI)
        dif += 2.0 * M_PI;  // we include a sign change to have dif > 0
    }
    else
      dif = current_joint_position - joint_position_;

    // check bounds
    bool result = dif <= (joint_tolerance_above_ + 2.0 * std::numeric_limits<double>::epsilon()) &&
                  dif >= (-joint_tolerance_below_ - 2.0 * std::numeric_limits<double>::epsilon());
    if (verbose)
      RCLCPP_INFO(LOGGER,
                  "Constraint %s:: Joint name: '%s', actual value: %f, desired value: %f, "
                  "tolerance_above: %f, tolerance_below: %f",
                  result ? "satisfied" : "violated", joint_variable_name_.c_str(), current_joint_position,
                  joint_position_, joint_tolerance_above_, joint_tolerance_below_);
    return ConstraintEvaluationResult(result, constraint_weight_ * fabs(dif));
  }
architecture-codes:
  - ROS Logger Issue - ROS Logger Missing Issue

functionality-codes:
  - Condition Issue - Conditional Check Missing Issue
  - Operation/Calculation Issue - Fundamental Mathematical and Geometric Issue
  - Incomplete Code Issue - Missing One Step Issue

root-cause-codes:
  - Solving Robotic Tasks Issue - Inadequate Understanding of Task Logic
  - Framework Integration Issue - Lack of ROS development best practices
  - Framework Integration Issue - Insufficient understanding of ROS Integration