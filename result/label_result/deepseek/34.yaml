compilation.log: |
  Starting >>> autoware_detected_object_validation
  [Processing: autoware_detected_object_validation]
  [Processing: autoware_detected_object_validation]
  Finished <<< autoware_detected_object_validation [1min 7s]

  Summary: 1 package finished [1min 9s]
generate_code.cpp: |-
  void ObjectLaneletFilterNode::objectCallback(
    const autoware_perception_msgs::msg::DetectedObjects::ConstSharedPtr input_msg)
  {
    if (stop_watch_ptr_) {
      stop_watch_ptr_->tic("total");
    }

    // Transform objects to lanelet frame
    autoware_perception_msgs::msg::DetectedObjects transformed_objects;
    if (!autoware::object_recognition_utils::transformObjects(
          *input_msg, "map", tf_buffer_, transformed_objects)) {
      RCLCPP_ERROR(get_logger(), "Failed to transform objects to lanelet frame");
      return;
    }

    // Get convex hull of all objects
    const auto convex_hull = getConvexHull(transformed_objects);

    // Get intersected lanelets with convex hull
    const auto intersected_lanelets = getIntersectedLanelets(convex_hull);

    // Create output message
    autoware_perception_msgs::msg::DetectedObjects output_msg;
    output_msg.header = input_msg->header;

    // Create R-tree for fast spatial queries
    bg::index::rtree<BoxAndLanelet, RtreeAlgo> local_rtree;
    for (const auto & box_and_lanelet : intersected_lanelets) {
      local_rtree.insert(box_and_lanelet);
    }

    // Filter objects based on lanelet intersection
    for (size_t i = 0; i < input_msg->objects.size(); ++i) {
      const auto & input_object = input_msg->objects[i];
      const auto & transformed_object = transformed_objects.objects[i];

      if (filterObject(transformed_object, input_object, local_rtree, output_msg)) {
        // Object passed filtering
        output_msg.objects.push_back(input_object);
      }
    }

    // Publish filtered objects
    object_pub_->publish(output_msg);
    published_time_publisher_->publish_if_subscribed(object_pub_, output_msg.header.stamp);

    // Publish debug markers if enabled
    if (filter_settings_.debug) {
      publishDebugMarkers(input_msg->header.stamp, convex_hull, intersected_lanelets);
    }

    if (stop_watch_ptr_) {
      stop_watch_ptr_->toc("total", "Total processing time");
    }
  }
ground_truth.cpp: |-
  void ObjectLaneletFilterNode::objectCallback(
    const autoware_perception_msgs::msg::DetectedObjects::ConstSharedPtr input_msg)
  {
    stop_watch_ptr_->tic("processing_time");

    // Guard
    if (object_pub_->get_subscription_count() < 1) return;

    autoware_perception_msgs::msg::DetectedObjects output_object_msg;
    output_object_msg.header = input_msg->header;

    if (!lanelet_map_ptr_) {
      RCLCPP_ERROR(get_logger(), "No vector map received.");
      return;
    }
    autoware_perception_msgs::msg::DetectedObjects transformed_objects;
    if (!autoware::object_recognition_utils::transformObjects(
          *input_msg, lanelet_frame_id_, tf_buffer_, transformed_objects)) {
      RCLCPP_ERROR(get_logger(), "Failed transform to %s.", lanelet_frame_id_.c_str());
      return;
    }
    // vehicle base pose :map -> base_link
    if (filter_settings_.use_height_threshold) {
      try {
        ego_base_height_ = tf_buffer_
                             .lookupTransform(
                               lanelet_frame_id_, "base_link", transformed_objects.header.stamp,
                               rclcpp::Duration::from_seconds(0.5))
                             .transform.translation.z;
      } catch (const tf2::TransformException & ex) {
        RCLCPP_ERROR_STREAM(get_logger(), "Failed to get transform: " << ex.what());
        return;
      }
    }

    if (!transformed_objects.objects.empty()) {
      // calculate convex hull
      const auto convex_hull = getConvexHull(transformed_objects);

      // get intersected lanelets
      std::vector<BoxAndLanelet> intersected_lanelets_with_bbox = getIntersectedLanelets(convex_hull);

      // create R-Tree with intersected_lanelets for fast search
      bgi::rtree<BoxAndLanelet, RtreeAlgo> local_rtree;
      for (const auto & bbox_and_lanelet : intersected_lanelets_with_bbox) {
        local_rtree.insert(bbox_and_lanelet);
      }

      if (filter_settings_.debug) {
        publishDebugMarkers(input_msg->header.stamp, convex_hull, intersected_lanelets_with_bbox);
      }
      // filtering process
      for (size_t index = 0; index < transformed_objects.objects.size(); ++index) {
        const auto & transformed_object = transformed_objects.objects.at(index);
        const auto & input_object = input_msg->objects.at(index);
        filterObject(transformed_object, input_object, local_rtree, output_object_msg);
      }
    }

    object_pub_->publish(output_object_msg);
    published_time_publisher_->publish_if_subscribed(object_pub_, output_object_msg.header.stamp);

    // Publish debug info
    const double pipeline_latency =
      std::chrono::duration<double, std::milli>(
        std::chrono::nanoseconds(
          (this->get_clock()->now() - output_object_msg.header.stamp).nanoseconds()))
        .count();
    debug_publisher_->publish<autoware_internal_debug_msgs::msg::Float64Stamped>(
      "debug/pipeline_latency_ms", pipeline_latency);
    debug_publisher_->publish<autoware_internal_debug_msgs::msg::Float64Stamped>(
      "debug/processing_time_ms", stop_watch_ptr_->toc("processing_time", true));
  }
architecture-codes:
  - ROS Parameter Issue - Use Non-existent Parameter Issue
  - ROS Parameter Issue - Insufficient Parameter Design Issue
  - ROS Timer Issue - Clock Source Usage Issue
  - ROS Diagnostic Issue - ROS Diagnostic API Misuse Issue

functionality-codes:
  - Condition Issue - Conditional Check Missing Issue
  - Condition Issue - Condition Check Logic Misapplication Issue
  - Incomplete Code Issue - Missing Multiple Steps Issue
  - Constant Value Issue

root-cause-codes:
  - Solving Robotic Tasks Issue - Inadequate Understanding of Task Logic
  - Solving Robotic Tasks Issue - Inadequate Understanding of System Requirements
  - Framework Integration Issue - Lack of ROS development best practices
  - Framework Integration Issue - Insufficient understanding of ROS Integration
  - Solving Robotic Tasks Issue - Inadequate Understanding of Existing Codebase 