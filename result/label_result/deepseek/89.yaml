compilation.log: |
  Starting >>> autoware_radar_object_tracker
  --- stderr: autoware_radar_object_tracker
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_radar_object_tracker/src/utils/radar_object_tracker_utils.cpp: In function ‘bool autoware::radar_object_tracker::utils::checkCloseLaneletCondition(const std::pair<double, lanelet::Lanelet>&, const TrackedObject&, double, double)’:
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_radar_object_tracker/src/utils/radar_object_tracker_utils.cpp:84:56: error: no matching function for call to ‘project(const lanelet::ConstLineString3d&, const _position_type&)’
     84 |   const auto nearest_point = lanelet::geometry::project(centerline, object_pose.position);
        |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  In file included from /opt/ros/humble/include/lanelet2_core/geometry/LineString.h:307,
                   from /opt/ros/humble/include/lanelet2_core/geometry/Polygon.h:4,
                   from /opt/ros/humble/include/lanelet2_core/geometry/impl/Lanelet.h:10,
                   from /opt/ros/humble/include/lanelet2_core/geometry/Lanelet.h:195,
                   from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_radar_object_tracker/include/autoware_radar_object_tracker/utils/radar_object_tracker_utils.hpp:32,
                   from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_radar_object_tracker/src/utils/radar_object_tracker_utils.cpp:15:
  /opt/ros/humble/include/lanelet2_core/geometry/impl/LineString.h:762:14: note: candidate: ‘template<class LineString3dT, class> lanelet::BasicPoint3d lanelet::geometry::project(const LineString3dT&, const BasicPoint3d&)’
    762 | BasicPoint3d project(const LineString3dT& lineString, const BasicPoint3d& pointToProject) {
        |              ^~~~~~~
  /opt/ros/humble/include/lanelet2_core/geometry/impl/LineString.h:762:14: note:   template argument deduction/substitution failed:
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_radar_object_tracker/src/utils/radar_object_tracker_utils.cpp:84:81: note:   cannot convert ‘object_pose.geometry_msgs::msg::Pose_<std::allocator<void> >::position’ (type ‘const _position_type’ {aka ‘const geometry_msgs::msg::Point_<std::allocator<void> >’}) to type ‘const BasicPoint3d&’ {aka ‘const Eigen::Matrix<double, 3, 1>&’}
     84 |   const auto nearest_point = lanelet::geometry::project(centerline, object_pose.position);
        |                                                                     ~~~~~~~~~~~~^~~~~~~~
  In file included from /opt/ros/humble/include/lanelet2_core/geometry/LineString.h:307,
                   from /opt/ros/humble/include/lanelet2_core/geometry/Polygon.h:4,
                   from /opt/ros/humble/include/lanelet2_core/geometry/impl/Lanelet.h:10,
                   from /opt/ros/humble/include/lanelet2_core/geometry/Lanelet.h:195,
                   from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_radar_object_tracker/include/autoware_radar_object_tracker/utils/radar_object_tracker_utils.hpp:32,
                   from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_radar_object_tracker/src/utils/radar_object_tracker_utils.cpp:15:
  /opt/ros/humble/include/lanelet2_core/geometry/impl/LineString.h:768:14: note: candidate: ‘template<class LineString2dT, class> lanelet::BasicPoint2d lanelet::geometry::project(const LineString2dT&, const BasicPoint2d&)’
    768 | BasicPoint2d project(const LineString2dT& lineString, const BasicPoint2d& pointToProject) {
        |              ^~~~~~~
  /opt/ros/humble/include/lanelet2_core/geometry/impl/LineString.h:768:14: note:   template argument deduction/substitution failed:
  In file included from /usr/include/c++/11/bits/stl_iterator_base_types.h:67,
                   from /usr/include/c++/11/iterator:61,
                   from /usr/include/boost/iterator/iterator_traits.hpp:10,
                   from /usr/include/boost/range/mutable_iterator.hpp:23,
                   from /usr/include/boost/range/iterator.hpp:20,
                   from /usr/include/boost/range/value_type.hpp:19,
                   from /usr/include/boost/geometry/core/point_type.hpp:19,
                   from /usr/include/boost/geometry/core/coordinate_system.hpp:20,
                   from /usr/include/boost/geometry/core/cs.hpp:27,
                   from /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/geometry/boost_geometry.hpp:18,
                   from /workspace/repos/autoware/install/autoware_universe_utils/include/autoware/universe_utils/geometry/geometry.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_radar_object_tracker/include/autoware_radar_object_tracker/utils/radar_object_tracker_utils.hpp:18,
                   from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_radar_object_tracker/src/utils/radar_object_tracker_utils.cpp:15:
  /usr/include/c++/11/type_traits: In substitution of ‘template<bool _Cond, class _Tp> using enable_if_t = typename std::enable_if::type [with bool _Cond = false; _Tp = void]’:
  /opt/ros/humble/include/lanelet2_core/geometry/LineString.h:185:35:   required from here
  /usr/include/c++/11/type_traits:2579:11: error: no type named ‘type’ in ‘struct std::enable_if<false, void>’
   2579 |     using enable_if_t = typename enable_if<_Cond, _Tp>::type;
        |           ^~~~~~~~~~~
  In file included from /opt/ros/humble/include/lanelet2_core/geometry/Polygon.h:4,
                   from /opt/ros/humble/include/lanelet2_core/geometry/impl/Lanelet.h:10,
                   from /opt/ros/humble/include/lanelet2_core/geometry/Lanelet.h:195,
                   from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_radar_object_tracker/include/autoware_radar_object_tracker/utils/radar_object_tracker_utils.hpp:32,
                   from /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_radar_object_tracker/src/utils/radar_object_tracker_utils.cpp:15:
  /opt/ros/humble/include/lanelet2_core/geometry/LineString.h:188:14: note: candidate: ‘lanelet::BasicPoint2d lanelet::geometry::project(const BasicSegment2d&, const BasicPoint2d&)’
    188 | BasicPoint2d project(const BasicSegment2d& segment, const BasicPoint2d& pointToProject);
        |              ^~~~~~~
  /opt/ros/humble/include/lanelet2_core/geometry/LineString.h:188:44: note:   no known conversion for argument 1 from ‘const lanelet::ConstLineString3d’ to ‘const BasicSegment2d&’ {aka ‘const std::pair<Eigen::Matrix<double, 2, 1, 2>, Eigen::Matrix<double, 2, 1, 2> >&’}
    188 | BasicPoint2d project(const BasicSegment2d& segment, const BasicPoint2d& pointToProject);
        |                      ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~
  /opt/ros/humble/include/lanelet2_core/geometry/LineString.h:189:14: note: candidate: ‘lanelet::BasicPoint3d lanelet::geometry::project(const BasicSegment3d&, const BasicPoint3d&)’
    189 | BasicPoint3d project(const BasicSegment3d& segment, const BasicPoint3d& pointToProject);
        |              ^~~~~~~
  /opt/ros/humble/include/lanelet2_core/geometry/LineString.h:189:44: note:   no known conversion for argument 1 from ‘const lanelet::ConstLineString3d’ to ‘const BasicSegment3d&’ {aka ‘const std::pair<Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1> >&’}
    189 | BasicPoint3d project(const BasicSegment3d& segment, const BasicPoint3d& pointToProject);
        |                      ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~
  /workspace/repos/autoware/src/universe/autoware.universe/perception/autoware_radar_object_tracker/src/utils/radar_object_tracker_utils.cpp:85:53: error: ‘tangentAngleAt’ is not a member of ‘lanelet::geometry’
     85 |   const auto lanelet_direction = lanelet::geometry::tangentAngleAt(centerline, nearest_point);
        |                                                     ^~~~~~~~~~~~~~
  gmake[2]: *** [CMakeFiles/autoware_radar_object_tracker_utils.dir/build.make:90: CMakeFiles/autoware_radar_object_tracker_utils.dir/src/utils/radar_object_tracker_utils.cpp.o] Error 1
  gmake[1]: *** [CMakeFiles/Makefile2:161: CMakeFiles/autoware_radar_object_tracker_utils.dir/all] Error 2
  gmake: *** [Makefile:146: all] Error 2
  ---
  Failed   <<< autoware_radar_object_tracker [11.5s, exited with code 2]

  Summary: 0 packages finished [13.0s]
    1 package failed: autoware_radar_object_tracker
    1 package had stderr output: autoware_radar_object_tracker
generate_code.cpp: "bool checkCloseLaneletCondition(\n  const std::pair<double, lanelet::Lanelet>\
  \ & lanelet,\n  const autoware_perception_msgs::msg::TrackedObject & object, const\
  \ double max_distance_from_lane,\n  const double max_angle_diff_from_lane)\n{\n\
  \  // Check distance condition\n  if (lanelet.first > max_distance_from_lane) {\n\
  \    return false;\n  }\n\n  // Get object pose\n  const auto & object_pose = object.kinematics.pose_with_covariance.pose;\n\
  \  const double object_yaw = tf2::getYaw(object_pose.orientation);\n\n  // Get lanelet\
  \ centerline\n  const auto centerline = lanelet.second.centerline();\n  if (centerline.empty())\
  \ {\n    return false;\n  }\n\n  // Calculate lanelet direction at nearest point\n\
  \  const auto nearest_point = lanelet::geometry::project(centerline, object_pose.position);\n\
  \  const auto lanelet_direction = lanelet::geometry::tangentAngleAt(centerline,\
  \ nearest_point);\n  \n  // Normalize angles and calculate difference\n  const double\
  \ normalized_object_yaw = autoware::universe_utils::normalizeRadian(object_yaw);\n\
  \  const double normalized_lanelet_direction = autoware::universe_utils::normalizeRadian(lanelet_direction);\n\
  \  const double angle_diff = std::abs(normalized_object_yaw - normalized_lanelet_direction);\n\
  \  const double normalized_angle_diff = std::min(angle_diff, 2 * M_PI - angle_diff);\n\
  \n  // Check angle condition\n  return normalized_angle_diff <= max_angle_diff_from_lane;\n\
  }"
ground_truth.cpp: |-
  bool checkCloseLaneletCondition(
    const std::pair<double, lanelet::Lanelet> & lanelet,
    const autoware_perception_msgs::msg::TrackedObject & object, const double max_distance_from_lane,
    const double max_angle_diff_from_lane)
  {
    if (lanelet.second.centerline().size() <= 1) {
      return false;
    }

    lanelet::BasicPoint2d search_point(
      object.kinematics.pose_with_covariance.pose.position.x,
      object.kinematics.pose_with_covariance.pose.position.y);
    if (!lanelet::geometry::inside(lanelet.second, search_point)) {
      const auto distance = lanelet.first;
      if (distance > max_distance_from_lane) {
        return false;
      }
    }

    const double object_yaw = tf2::getYaw(object.kinematics.pose_with_covariance.pose.orientation);
    const double lane_yaw = lanelet::utils::getLaneletAngle(
      lanelet.second, object.kinematics.pose_with_covariance.pose.position);
    double object_motion_yaw = object_yaw;
    bool velocity_is_reverted = object.kinematics.twist_with_covariance.twist.linear.x < 0.0;
    if (velocity_is_reverted) {
      object_motion_yaw = autoware::universe_utils::normalizeRadian(object_yaw + M_PI);
    }
    const double delta_yaw = object_motion_yaw - lane_yaw;
    const double normalized_delta_yaw = autoware::universe_utils::normalizeRadian(delta_yaw);
    const double abs_norm_delta_yaw = std::fabs(normalized_delta_yaw);

    if (abs_norm_delta_yaw > max_angle_diff_from_lane) {
      return false;
    }

    return true;
  }
architecture-codes:
  - ROS Message Issue - Message Operation Issue

functionality-codes:
  - Condition Issue - Conditional Check Missing Issue
  - Domain Library Issue - Domain Specific Library Utilization Error
  - Incomplete Code Issue - Missing Multiple Steps Issue

root-cases-codes:
  - Solving Robotic Tasks Issue - Inadequate Understanding in Domain Knowledge
  - Framework Integration Issue - Insufficient understanding of ROS Integration
  - Solving Robotic Tasks Issue - Inadequate Understanding of Task Logic