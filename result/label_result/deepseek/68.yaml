compilation.log: |
  Starting >>> autoware_euclidean_cluster
  Finished <<< autoware_euclidean_cluster [13.2s]

  Summary: 1 package finished [14.5s]
generate_code.cpp: |-
  void VoxelGridBasedEuclideanClusterNode::onPointCloud(
    const sensor_msgs::msg::PointCloud2::ConstSharedPtr input_msg)
  {
    // Start timer for performance measurement
    stop_watch_ptr_->tic("total_processing_time");

    // Convert ROS PointCloud2 to PCL PointCloud
    pcl::PointCloud<pcl::PointXYZ>::Ptr pcl_input(new pcl::PointCloud<pcl::PointXYZ>);
    pcl::fromROSMsg(*input_msg, *pcl_input);

    // Perform clustering
    std::vector<pcl::PointCloud<pcl::PointXYZ>> clusters;
    cluster_->cluster(pcl_input, clusters);

    // Convert clusters to DetectedObjectsWithFeature message
    tier4_perception_msgs::msg::DetectedObjectsWithFeature output_msg;
    output_msg.header = input_msg->header;

    for (const auto &cluster : clusters) {
      tier4_perception_msgs::msg::DetectedObjectWithFeature feature_object;
      feature_object.feature.cluster.header = input_msg->header;
      pcl::toROSMsg(cluster, feature_object.feature.cluster);
      output_msg.feature_objects.push_back(feature_object);
    }

    // Publish the clustered objects
    cluster_pub_->publish(output_msg);

    // Publish debug information if enabled
    if (debug_pub_) {
      pcl::PointCloud<pcl::PointXYZ> debug_cloud;
      for (const auto &cluster : clusters) {
        debug_cloud += cluster;
      }
      sensor_msgs::msg::PointCloud2 debug_msg;
      pcl::toROSMsg(debug_cloud, debug_msg);
      debug_msg.header = input_msg->header;
      debug_pub_->publish(debug_msg);
    }

    // Publish processing time
    if (debug_publisher_) {
      const double total_time_ms = stop_watch_ptr_->toc("total_processing_time", true);
      debug_publisher_->publish<tier4_debug_msgs::msg::Float64Stamped>(
        "debug/processing_time_ms", total_time_ms);
    }
  }
ground_truth.cpp: |-
  void VoxelGridBasedEuclideanClusterNode::onPointCloud(
    const sensor_msgs::msg::PointCloud2::ConstSharedPtr input_msg)
  {
    stop_watch_ptr_->toc("processing_time", true);

    // convert ros to pcl
    if (input_msg->data.empty()) {
      // NOTE: prevent pcl log spam
      RCLCPP_WARN_STREAM_THROTTLE(
        this->get_logger(), *this->get_clock(), 1000, "Empty sensor points!");
    }
    // cluster and build output msg
    tier4_perception_msgs::msg::DetectedObjectsWithFeature output;

    cluster_->cluster(input_msg, output);
    cluster_pub_->publish(output);

    // build debug msg
    if (debug_pub_->get_subscription_count() >= 1) {
      sensor_msgs::msg::PointCloud2 debug;
      convertObjectMsg2SensorMsg(output, debug);
      debug_pub_->publish(debug);
    }
    if (debug_publisher_) {
      const double processing_time_ms = stop_watch_ptr_->toc("processing_time", true);
      const double cyclic_time_ms = stop_watch_ptr_->toc("cyclic_time", true);
      const double pipeline_latency_ms =
        std::chrono::duration<double, std::milli>(
          std::chrono::nanoseconds((this->get_clock()->now() - output.header.stamp).nanoseconds()))
          .count();
      debug_publisher_->publish<autoware_internal_debug_msgs::msg::Float64Stamped>(
        "debug/cyclic_time_ms", cyclic_time_ms);
      debug_publisher_->publish<autoware_internal_debug_msgs::msg::Float64Stamped>(
        "debug/processing_time_ms", processing_time_ms);
      debug_publisher_->publish<autoware_internal_debug_msgs::msg::Float64Stamped>(
        "debug/pipeline_latency_ms", pipeline_latency_ms);
    }
  }
architecture-codes:
  - ROS Message Issue - Improper Message Type Usage Issue
  - ROS Logger Issue - ROS Logger Missing Issue
  - Topic/Service Issue - Topic/Service Use Error Issue
  - ROS Timer Issue - Clock Source Usage Issue

functionality-codes:
  - Condition Issue - Conditional Check Missing Issue
  - Domain Library Issue - Domain Specific Library Utilization Error
  - Incomplete Code Issue - Missing Multiple Steps Issue
  - Operation/Calculation Issue - Algorithmic State and Initialization Issue

root-cause-codes:
  - Solving Robotic Tasks Issue - Inadequate Understanding of Task Logic
  - Framework Integration Issue - Insufficient understanding of ROS Integration
  - Framework Integration Issue - Lack of ROS development best practices
  - Solving Robotic Tasks Issue - Inadequate Understanding of Existing Codebase 