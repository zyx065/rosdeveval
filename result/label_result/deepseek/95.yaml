compilation.log: ""
generate_code.cpp: |-
  std::optional<double> calcDecelDistWithJerkAndAccConstraints(
    const double current_vel, const double target_vel, const double current_acc, const double acc_min,
    const double jerk_acc, const double jerk_dec)
  {
    if (current_vel < target_vel) {
      return std::nullopt;
    }

    // Check if we need to use PlanType1 (with minimum acceleration constraint)
    const auto dist_plan1 = calcDecelDistPlanType1(
      current_vel, target_vel, current_acc, acc_min, jerk_acc, jerk_dec, 0.0);
    if (dist_plan1) {
      return dist_plan1;
    }

    // Check if we need to use PlanType2 (without minimum acceleration constraint)
    const auto dist_plan2 = calcDecelDistPlanType2(
      current_vel, target_vel, current_acc, jerk_acc, jerk_dec);
    if (dist_plan2) {
      return dist_plan2;
    }

    // Check if we need to use PlanType3 (simple deceleration profile)
    const auto dist_plan3 = calcDecelDistPlanType3(
      current_vel, target_vel, current_acc, jerk_dec);
    if (dist_plan3) {
      return dist_plan3;
    }

    // If none of the plans worked, return nullopt
    return std::nullopt;
  }
ground_truth.cpp: |-
  std::optional<double> calcDecelDistWithJerkAndAccConstraints(
    const double current_vel, const double target_vel, const double current_acc, const double acc_min,
    const double jerk_acc, const double jerk_dec)
  {
    if (current_vel < target_vel) {
      return {};
    }

    constexpr double epsilon = 1e-3;
    const double jerk_before_min_acc = acc_min < current_acc ? jerk_dec : jerk_acc;
    const double t_before_min_acc = (acc_min - current_acc) / jerk_before_min_acc;
    const double jerk_after_min_acc = jerk_acc;
    const double t_after_min_acc = (0.0 - acc_min) / jerk_after_min_acc;

    const double t_during_min_acc =
      (target_vel - current_vel - current_acc * t_before_min_acc -
       0.5 * jerk_before_min_acc * std::pow(t_before_min_acc, 2) - acc_min * t_after_min_acc -
       0.5 * jerk_after_min_acc * std::pow(t_after_min_acc, 2)) /
      acc_min;

    // check if it is possible to decelerate to the target velocity
    // by simply bringing the current acceleration to zero.
    const auto is_decel_needed =
      0.5 * (0.0 - current_acc) / jerk_acc * current_acc > target_vel - current_vel;

    if (t_during_min_acc > epsilon) {
      return calcDecelDistPlanType1(
        current_vel, target_vel, current_acc, acc_min, jerk_acc, jerk_dec, t_during_min_acc);
    }
    if (is_decel_needed || current_acc > epsilon) {
      return calcDecelDistPlanType2(current_vel, target_vel, current_acc, jerk_acc, jerk_dec);
    }

    return calcDecelDistPlanType3(current_vel, target_vel, current_acc, jerk_acc);
  }
architecture-codes: []

functionality-codes:
  - Operation/Calculation Issue - Algorithmic State and Initialization Issue
  - Operation/Calculation Issue - Violation of Physical & Kinematic Constraints Issue
  - Condition Issue - Condition Check Logic Misapplication Issue
  - Incomplete Code Issue - Missing Multiple Steps Issue
  - Operation/Calculation Issue - Data Structure Semantic Misinterpretation Issue

root-cause-codes:
  - Solving Robotic Tasks Issue - Inadequate Understanding of Task Logic
  - Solving Robotic Tasks Issue - Inadequate Understanding in Domain Knowledge